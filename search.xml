<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1. Java 面向对象基础</title>
    <url>/2019/11/15/Java-Object-Base/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了更好的构建知识框架，这里归档的信息部分内容引用于来源于网络，如有侵权，请联系作者。</p>
<a id="more"></a>

<p>面向对象简称 OO（Object Oriented），20 世纪 80 年代以后，有了面向对象分析（OOA）、 面向对象设计（OOD）、面向对象程序设计（OOP）等新的系统开发方式模型的研究。</p>
<p>对语言来说，一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组成了完整的程序设计，这些对象可以是独立存在的，也可以是从别的对象继承过来的。对象之间通过相互作用传递信息，实现程序开发。</p>
<h2 id="对象的概念"><a href="#对象的概念" class="headerlink" title="对象的概念"></a>对象的概念</h2><p>Java 是面向对象的编程语言，<span class="label success">对象</span>就是面向对象程序设计的核心。所谓对象就是真实世界中的实体，对象与实体是一一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。对象有以下特点：</p>
<ul>
<li>对象具有属性和行为。</li>
<li>对象具有变化的状态。</li>
<li>对象具有唯一性。</li>
<li>对象都是某个类别的实例。</li>
<li>一切皆为对象，真实世界中的所有事物都可以视为对象。</li>
</ul>
<h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><ul>
<li><p>面向过程：<br>  一种较早的编程思想，顾名思义就是该思想是站在过程的角度思考问题，强调的是功能行为。功能的执行过程，即先后顺序，而每一个功能我们都使用函数（类似于方法）把这些步骤一步一步实现。使用的时候依次调用函数就可以了。</p>
</li>
<li><p>面向过程的设计：<br>  最小的程序单元是函数，每个函数负责完成某一个功能，用于接受输入数据，函数对输入数据进行处理，然后输出结果数据，整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能。<br>      面向过程最大的问题在于随着系统的膨胀，面向过程将无法应对，最终导致系统的崩溃。为了解决这一种软件危机，我们提出面向对象思想。</p>
</li>
<li><p>面向过程的缺陷：<br>  是采用指定下的设计模式，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每一个子模块又细分为更小的子模块，如此类推，直到将模块细化为一个个函数。</p>
</li>
<li><p>存在的问题<br>  设计不够直观，与人类的思维习惯不一致<br>  系统软件适应新差，可拓展性差，维护性低</p>
</li>
<li><p>面向对象：<br>  一种基于面向过程的新编程思想，顾名思义就是该思想是站在对象的角度思考问题，我们把多个功能合理的放到不同对象里，强调的是具备某些功能的对象。 </p>
<p>  具备某种功能的实体，称为对象。面向对象最小的程序单元是：类。面向对象更加符合常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。 </p>
<p>  在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。</p>
</li>
</ul>
<h2 id="面向对象的三大核心特性简介"><a href="#面向对象的三大核心特性简介" class="headerlink" title="面向对象的三大核心特性简介"></a>面向对象的三大核心特性简介</h2><p>面向对象开发模式更有利于人们开拓思维，在具体的开发过程中便于程序的划分，方便程序员分工合作，提高开发效率。</p>
<p>该开发模式之所以使程序设计更加完善和强大，主要是因为面向对象具有继承、封装和多态 3 个核心特性。</p>
<p><strong>1、继承的概念</strong></p>
<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/14B0951E-FC75-47A3-B611-4E1883887339.jpg" alt="img"></p>
<p>兔子和羊属于食草动物类，狮子和豹属于食肉动物类。</p>
<p>食草动物和食肉动物又是属于动物类。</p>
<p>所以继承需要符合的关系是：is-a，父类更通用，子类更具体。</p>
<p>虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。</p>
<p><strong>2、Java 多态</strong></p>
<hr>
<p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/dt-java.png" alt="img"></p>
<p>多态性是对象多种表现形式的体现。</p>
<blockquote>
<p>现实中，比如我们按下 F1 键这个动作：</p>
<ul>
<li>如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；</li>
<li>如果当前在 Word 下弹出的就是 Word 帮助；</li>
<li>在 Windows 下弹出的就是 Windows 帮助和支持。</li>
</ul>
<p>同一个事件发生在不同的对象上会产生不同的结果。</p>
</blockquote>
<p><strong>3、Java 封装</strong></p>
<hr>
<p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<h2 id="面向对象编程三大特性详解"><a href="#面向对象编程三大特性详解" class="headerlink" title="面向对象编程三大特性详解"></a>面向对象编程三大特性详解</h2><p>面向对象编程是利用 类和对象编程的一种思想。万物可归类，类是对于世界事物的高度抽象 ，不同的事物之间有不同的关系 ，一个类自身与外界的封装关系，一个父类和子类的继承关系， 一个类和多个类的多态关系。万物皆对象，对象是具体的世界事物，面向对象的三大特征封装，继承，多态，封装，封装说明一个类行为和属性与其他类的关系，低耦合，高内聚；继承是父类和子类的关系，多态说的是类与类的关系。</p>
<h3 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h3><h4 id="1、继承的概念"><a href="#1、继承的概念" class="headerlink" title="1、继承的概念"></a>1、继承的概念</h4><p>如同生活中的子女继承父母拥有的所有财产，程序中的继承性是指子类拥有父类<a href="http://c.biancheng.net/data_structure/" target="_blank" rel="noopener">数据结构</a>的方法和机制，这是类之间的一种关系；继承只能是单继承。</p>
<p>例如定义一个语文老师类和数学老师类，如果不采用继承方式，那么两个类中需要定义的属性和方法如图 1 所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181017/3-1Q01G40613629.jpg" alt><br>图1 语文老师类和数学老师类中的属性和方法</p>
<p>从图 1 能够看出，语文老师类和数学老师类中的许多属性和方法相同，这些相同的属性和方法可以提取出来放在一个父类中，这个父类用于被语文老师类和数学老师类继承。当然父类还可以继承别的类，如图 2 所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181017/3-1Q01G40AR23.jpg" alt><br>图2 父类继承示例图</p>
<p>总结图 2 的继承关系，可以用概括的树形关系来表示，如图 3 所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181017/3-1Q01G40RT47.jpg" alt><br>图3 类继承示例图</p>
<p>从图 3 中可以看出，学校主要人员是一个大的类别，老师和学生是学校主要人员的两个子类，而老师又可以分为语文老师和数学老师两个子类，学生也可以分为班长和组长两个子类。</p>
<p>使用这种层次形的分类方式，是为了将多个类的通用属性和方法提取出来，放在它们的父类中，然后只需要在子类中各自定义自己独有的属性和方法，并以继承的形式在父类中获取它们的通用属性和方法即可。</p>
<p>　继承是类与类的一种关系，是一种“is a”的关系。比如“狗”继承“动物”，这里动物类是狗类的父类或者基类，狗类是动物类的子类或者派生类。如下图所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170701123011243-2128400556.png" alt="img"></p>
<p>注：java中的继承是<strong>单继承</strong>，即<strong>一个类只有一个父类。</strong></p>
<p><strong>补充：Java中的继承只能单继承，但是可以通过内部类继承其他类来实现多继承。</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">	public void go () &#123;</span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">"son go"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	public void eat () &#123;</span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">"son eat"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	public void sleep() &#123;</span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">"zzzzzz"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	public void cook() &#123;</span><br><span class="line">		<span class="comment">//匿名内部类实现的多继承</span></span><br><span class="line">		<span class="keyword">new</span> <span class="type">Mother</span>().cook();</span><br><span class="line">		<span class="comment">//内部类继承第二个父类来实现多继承</span></span><br><span class="line">		<span class="type">Mom</span> mom = <span class="keyword">new</span> <span class="type">Mom</span>();</span><br><span class="line">		mom.cook();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Mom</span> <span class="keyword">extends</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span> <span class="comment">//(子类)方法的重写</span></span><br><span class="line">		public void cook() &#123;</span><br><span class="line">			<span class="type">System</span>.out.println(<span class="string">"mom cook"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、继承的好处</strong></p>
<p>　子类拥有父类的所有属性和方法（除了private修饰的属性不能拥有）从而实现了代码的复用；　</p>
<p><strong>3、语法规则</strong></p>
<p><img src="https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170701123421961-647167245.png" alt="img"></p>
<hr>
<h5 id="A、方法的重写"><a href="#A、方法的重写" class="headerlink" title="A、方法的重写"></a>A、方法的重写</h5><p>　子类如果对继承的父类的方法不满意（不适合），可以自己编写继承的方法，这种方式就称为<strong>方法的重写。当调用方法时会优先调用子类的方法。</strong></p>
<p>　<strong>重写要注意：</strong></p>
<p>　  a、返回值类型</p>
<p>　　b、方法名</p>
<p>　　c、参数类型及个数</p>
<p>　都要与父类继承的方法相同，才叫方法的重写。</p>
<p>　<strong>重载和重写的区别：</strong></p>
<p>　　方法重载：在同一个类中处理不同数据的多个相同方法名的多态手段。</p>
<p>　　方法重写：相对继承而言，子类中对父类已经存在的方法进行区别化的修改。</p>
<hr>
<h5 id="B、继承的初始化顺序"><a href="#B、继承的初始化顺序" class="headerlink" title="B、继承的初始化顺序"></a>B、继承的初始化顺序</h5><p>　　1、初始化父类再初始化子类</p>
<p>　　2、先执行初始化对象中属性，再执行构造方法中的初始化。</p>
<p>　基于上面两点，我们就知道实例化一个子类，java程序的执行顺序是：</p>
<p>　<strong>父类对象属性初始化—-&gt;父类对象构造方法—-&gt;子类对象属性初始化—&gt;子类对象构造方法</strong>　　　</p>
<p>　下面有个形象的图：</p>
<p><img src="https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170701144019071-1063399032.png" alt="img"></p>
<hr>
<h5 id="C、final关键字"><a href="#C、final关键字" class="headerlink" title="C、final关键字"></a>C、final关键字</h5><p>　使用final关键字做标识有“最终的”含义。</p>
<p>　　1. final 修饰类，则该类<strong>不允许被继承。</strong></p>
<p>　　2. final 修饰方法，则该方法不允许被<strong>覆盖(重写)</strong>。</p>
<p>　　3. final 修饰属性，则该类的该属性不会进行隐式的初始化，所以 该final 属性的<strong>初始化属性必须有值</strong>，或在<strong>构造方法中赋值(但只能选其一，且必须选其一，因为没有默认值！)，</strong>且初始化之后就不能改了，<strong>只能赋值一次</strong>。</p>
<p>　　4. final 修饰变量，则该变量的值只能赋一次值，在声明变量的时候才能赋值，即变为<strong>常量</strong>。</p>
<hr>
<h5 id="D、super关键字"><a href="#D、super关键字" class="headerlink" title="D、super关键字"></a>D、super关键字</h5><p>　在对象的内部使用，可以代表父类对象。</p>
<p>　　1、访问父类的属性：super.age</p>
<p>　　 2、访问父类的方法：super.eat()</p>
<p>　super的应用：</p>
<p>　首先我们知道子类的构造的过程当中必须调用父类的构造方法。其实这个过程已经隐式地使用了我们的super关键字。</p>
<p>　这是因为如果子类的构造方法中没有显示调用父类的构造方法，则系统默认调用父类无参的构造方法。</p>
<p>　那么如果自己用super关键字在子类里调用父类的构造方法，则必须在子类的构造方法中的<strong>第一行</strong>。</p>
<p>　<strong>要注意的是：如果子类构造方法中既没有显示调用父类的构造方法，而父类没有无参的构造方法，则编译出错。</strong></p>
<p>（补充说明，虽然没有显示声明父类的无参的构造方法，系统会自动默认生成一个无参构造方法，但是，如果你声明了一个有参的构造方法，而没有声明无参的构造方法，这时系统不会动默认生成一个无参构造方法，此时称为父类有没有无参的构造方法。）</p>
<hr>
<h3 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h3><h4 id="1、封装的概念"><a href="#1、封装的概念" class="headerlink" title="1、封装的概念"></a>1、封装的概念</h4><p>封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。封装的目的在于保护信息，使用它的主要优点如下。</p>
<ul>
<li>保护类中的信息，它可以阻止在外部定义的代码随意访问内部代码和数据。</li>
<li>隐藏细节信息，一些不需要程序员修改和使用的信息，比如取款机中的键盘，用户只需要知道按哪个键实现什么操作就可以，至于它内部是如何运行的，用户不需要知道。</li>
<li>有助于建立各个系统之间的松耦合关系，提高系统的独立性。当一个系统的实现方式发生变化时，只要它的接口不变，就不会影响其他系统的使用。例如 U 盘，不管里面的存储方式怎么改变，只要 U 盘上的 USB 接口不变，就不会影响用户的正常操作。</li>
<li>提高软件的复用率，降低成本。每个系统都是一个相对独立的整体，可以在不同的环境中得到使用。例如，一个 U 盘可以在多台电脑上使用。</li>
</ul>
<p>Java 语言的基本封装单位是类。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。</p>
<h4 id="2、封装的优点"><a href="#2、封装的优点" class="headerlink" title="2、封装的优点"></a>2、封装的优点</h4><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<p>封装的优点</p>
<ol>
<li><p>良好的封装能够减少耦合。</p>
</li>
<li><p>类内部的结构可以自由修改。</p>
</li>
<li><p>可以对成员变量进行更精确的控制。</p>
</li>
<li><p>隐藏信息，实现细节。</p>
</li>
</ol>
<p>Java 封装，说白了就是将一大坨公共通用的实现逻辑玩意，装到一个盒子里（class），出入口都在这个盒子上。你要用就将这个盒子拿来用，连接出入口，就能用了，不用就可以直接扔，对你代码没什么影响。</p>
<p>对程序员来说，使用封装的目的：</p>
<ol>
<li><p>偷懒，辛苦一次，后面都能少敲很多代码，增强了代码得复用性</p>
</li>
<li><p>简化代码，看起来更容易懂</p>
</li>
<li><p>隐藏核心实现逻辑代码，简化外部逻辑，并且不让其他人修改，jar 都这么干</p>
</li>
<li><p>一对一，一个功能就只为这个功能服务；避免头发绳子一块用，导致最后一团糟</p>
</li>
</ol>
<h4 id="3、封装的实现步骤"><a href="#3、封装的实现步骤" class="headerlink" title="3、封装的实现步骤"></a>3、封装的实现步骤</h4><p><img src="https://images2015.cnblogs.com/blog/1189312/201706/1189312-20170630170717493-357592353.png" alt="img"></p>
<p>　　　　需要注意：对封装的属性不一定要通过get/set方法，其他方法也可以对封装的属性进行操作。当然最好使用get/set方法，比较标准。</p>
<hr>
<h5 id="A、访问修饰符"><a href="#A、访问修饰符" class="headerlink" title="A、访问修饰符"></a>A、访问修饰符</h5><p><img src="https://images2015.cnblogs.com/blog/1189312/201706/1189312-20170630174919274-1857293801.png" alt="img"></p>
<p>　　　　从表格可以看出<strong>从上到下封装性越来越差</strong>。</p>
<h5 id="B、this关键字"><a href="#B、this关键字" class="headerlink" title="B、this关键字"></a>B、this关键字</h5><p>　1.this关键字<strong>代表当前对象</strong></p>
<p>　　this.属性 操作当前对象的属性</p>
<p>　　this.方法 调用当前对象的方法。</p>
<p>　2.封装对象的属性的时候，经常会使用this关键字。</p>
<p>　3.当getter和setter函数参数名和成员函数名重合的时候，<strong>可以使用this**</strong>区别。如：**</p>
<p><img src="https://images2015.cnblogs.com/blog/1189312/201706/1189312-20170630180217524-833886832.png" alt="img"></p>
<h5 id="C、Java-中的内部类"><a href="#C、Java-中的内部类" class="headerlink" title="C、Java 中的内部类"></a>C、Java 中的内部类</h5><p>　内部类（ Inner Class ）就是定义在另外一个类<strong>里面</strong>的类。与之对应，包含内部类的类被称为外部类。</p>
<p>　那么问题来了：那为什么要将一个类定义在另一个类里面呢？清清爽爽的独立的一个类多好啊！！</p>
<p>　答：内部类的主要作用如下：</p>
<p>　　1. 内部类提供了<strong>更好的封装</strong>，可以把内部类<strong>隐藏</strong>在外部类之内，<strong>不允许</strong>同一个包中的其他类访问该类。</p>
<p>　　2. 内部类的方法可以<strong>直接访问外部类的所有数据</strong>，包括<strong>私有的数据</strong>。</p>
<p>　　3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。</p>
<p>　　内部类可分为以下几种： </p>
<ul>
<li>成员内部类</li>
<li>静态内部类</li>
<li>方法内部类</li>
<li>匿名内部类　　</li>
</ul>
<h3 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h3><h4 id="1、多态的概念"><a href="#1、多态的概念" class="headerlink" title="1、多态的概念"></a>1、多态的概念</h4><p>面向对象的多态性，即“一个接口，多个方法”。多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。多态性允许一个接口被多个同类使用，弥补了单继承的不足。多态概念可以用树形关系来表示，如图 4 所示。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181017/3-1Q01G4095bW.jpg" alt></p>
<p>图4 多态示例图</p>
<p>从图 4 中可以看出，老师类中的许多属性和方法可以被语文老师类和数学老师类同时使用，这样也不易出错。</p>
<h4 id="2、多态的好处"><a href="#2、多态的好处" class="headerlink" title="2、多态的好处"></a>2、多态的好处</h4><p>可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。</p>
<p>可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。</p>
<p>接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。</p>
<p>灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。</p>
<p>简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p>
<p>子代父类实例化，然后就相当于一个父亲有很多儿子，送快递的给这个父亲的儿子送东西，他只需要送到父亲的家就行了，至于具体是那个儿子的，父亲还会分不清自己的儿子么，所以你就不用操心了。</p>
<p><strong>使用多态是一种好习惯</strong><br>多态方式声明是一种好的习惯。当我们创建的类，使用时，只用到它的超类或接口定义的方法时，我们可以将其索引声明为它的超类或接口类型。</p>
<p>它的好处是，如果某天我们对这个接口方法的实现方式变了，对这个接口又有一个新的实现类，我们的程序也需要使用最新的实现方式，此时只要将对象实现修改一下，索引无需变化。</p>
<p>比如Map&lt; String,String&gt; map = new HashMap &lt; String,String&gt;();</p>
<p>想换成HashTable实现，可以Map&lt; String,String&gt; map = new HashTable &lt; String,String&gt;();</p>
<p>比如写一个方法，参数要求传递List类型，你就可以用List list = new ArrayList()中的list传递，但是你写成ArrayList list = new ArrayList()是传递不进去的。尽管方法处理时都一样。另外，方法还可以根据你传递的不同list（ArrayList或者LinkList）进行不同处理。</p>
<h4 id="3、Java中的多态"><a href="#3、Java中的多态" class="headerlink" title="3、Java中的多态"></a>3、Java中的多态</h4><p>java里的多态主要表现在两个方面：</p>
<h5 id="A、引用多态"><a href="#A、引用多态" class="headerlink" title="A、引用多态　　"></a>A、引用多态　　</h5><p>　　父类的引用可以指向本类的对象；</p>
<p>　　父类的引用可以指向子类的对象；</p>
<p>　　这两句话是什么意思呢，让我们用代码来体验一下，首先我们创建一个父类Animal和一个子类Dog，在主函数里如下所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170701155536086-1897896282.png" alt="img"></p>
<p>　　注意：我们不能使用一个子类的引用来指向父类的对象，如：<img src="https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170701155839586-923083573.png" alt="img">。</p>
<p>　　这里我们必须深刻理解引用多态的意义，才能更好记忆这种多态的特性。为什么子类的引用不能用来指向父类的对象呢？我在这里通俗给大家讲解一下：就以上面的例子来说，我们能说“狗是一种动物”，但是不能说“动物是一种狗”，狗和动物是父类和子类的继承关系，它们的从属是不能颠倒的。当父类的引用指向子类的对象时，该对象将只是看成一种特殊的父类（里面有重写的方法和属性），反之，一个子类的引用来指向父类的对象是不可行的！！</p>
<h5 id="B、方法多态"><a href="#B、方法多态" class="headerlink" title="B、方法多态"></a>B、方法多态</h5><p>　　根据上述创建的两个对象：本类对象和子类对象，同样都是父类的引用，当我们指向不同的对象时，它们调用的方法也是多态的。</p>
<p>　　创建本类对象时，调用的方法为本类方法；</p>
<p>　　创建子类对象时，调用的方法为子类重写的方法或者继承的方法；</p>
<p>　　使用多态的时候要注意：<strong>如果我们在子类中编写一个独有的方法（没有继承父类的方法），此时就不能通过父类的引用创建的子类对象来调用该方法！！！</strong></p>
<p>　　<strong>注意： 继承是多态的基础。</strong></p>
<hr>
<h5 id="C、引用类型转换"><a href="#C、引用类型转换" class="headerlink" title="C、引用类型转换"></a>C、引用类型转换</h5><p>　了解了多态的含义后，我们在日常使用多态的特性时经常需要进行引用类型转换。</p>
<p>　引用类型转换：</p>
<p>　<strong>1.向上类型转换(隐式/自动类型转换)，是小类型转换到大类型</strong></p>
<p>　 就以上述的父类Animal和一个子类Dog来说明，当父类的引用可以指向子类的对象时，就是<strong>向上类型转换</strong>。如：</p>
<p><img src="https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170701162630508-961507659.png" alt="img"></p>
<p>　 <strong>2. 向下类型转换(强制类型转换)，是大类型转换到小类型(有风险,可能出现数据溢出)。</strong></p>
<p>　　将上述代码再加上一行，我们再次将父类转换为子类引用，那么会出现错误，编译器不允许我们直接这么做<strong>，</strong>虽然我们知道这个父类引用指向的就是子类对象，但是编译器认为这种转换是存在风险的<strong>。</strong>如：</p>
<p><img src="https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170701162926477-3857975.png" alt="img"></p>
<p>　　那么我们该怎么解决这个问题呢，我们可以在animal前加上（Dog）来强制类型转换。如：<img src="https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170701163408383-2003626729.png" alt="img"></p>
<p>　　但是如果父类引用没有指向<strong>该子类的对象</strong>，则不能向下类型转换，虽然编译器不会报错，但是运行的时候程序会出错，如：<img src="https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170701164229899-1055190774.png" alt="img"></p>
<p>　　其实这就是上面所说的子类的引用指向父类的对象，而强制转换类型也不能转换！！</p>
<p>　　还有一种情况是父类的引用指向<strong>其他子类的对象</strong>，则不能通过强制转为<strong>该子类的对象</strong>。如：</p>
<p>　　　　<img src="https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170701165133289-717439360.png" alt="img"></p>
<p>　　这是因为我们在编译的时候进行了强制类型转换，编译时的类型是我们强制转换的类型，所以编译器不会报错，而当我们运行的时候，程序给animal开辟的是Dog类型的内存空间，这与Cat类型内存空间不匹配，所以无法正常转换。这两种情况出错的本质是一样的，所以我们在使用强制类型转换的时候要特别注意这两种错误！！下面有个更安全的方式来实现向下类型转换。。。。</p>
<p>　    <strong>3. instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。</strong></p>
<p>　　<strong>instanceof</strong>是Java的一个二元操作符，和==，&gt;，&lt;是同一类东东。由于它是由字母组成的，所以也是Java的保留关键字。<strong>它的作用是测试它左边的对象是否是它右边的类的实例</strong>，返回boolean类型的数据。</p>
<p>　　我们来使用instanceof运算符来规避上面的错误，代码修改如下：</p>
<p>　　<img src="https://images2015.cnblogs.com/blog/1189312/201707/1189312-20170701165626571-501228254.png" alt="img"></p>
<p>　　利用if语句和instanceof运算符来判断两个对象的类型是否一致。</p>
<p>　　<strong>补充说明：</strong>在比较一个对象是否和另一个对象属于同一个类实例的时候，我们通常可以采用instanceof和getClass两种方法通过两者是否相等来判断，但是两者在判断上面是有差别的。Instanceof进行类型检查规则是:<strong>你属于该类吗？或者你属于该类的派生类吗？</strong>而通过getClass获得类型信息采用==来进行检查是否相等的操作是<strong>严格的判断</strong>,<strong>不会存在继承方面的考虑</strong>；</p>
<p>　　<strong>总结：</strong>在写程序的时候，如果要进行类型转换，我们最好使用instanceof运算符来判断它左边的对象是否是它右边的类的实例，再进行强制转换。</p>
<hr>
<p><strong>D、重写和重载</strong>　</p>
<p>多态一般可以分为两种，一个是重写override，一个是重载overload。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">重写是由于继承关系中的子类有一个和父类同名同参数的方法，会覆盖掉父类的方法。重载是因为一个同名方法可以传入多个参数组合。</span><br><span class="line"></span><br><span class="line">注意，同名方法如果参数相同，即使返回值不同也是不能同时存在的，编译会出错。</span><br><span class="line"></span><br><span class="line">从<span class="keyword">jvm</span>实现的角度来看，重写又叫运行时多态，编译时看不出子类调用的是哪个方法，但是运行时操作数栈会先根据子类的引用去子类的类信息中查找方法，找不到的话再到父类的类信息中查找方法。</span><br><span class="line"></span><br><span class="line">而重载则是编译时多态，因为编译期就可以确定传入的参数组合，决定调用的具体方法是哪一个了。</span><br></pre></td></tr></table></figure>

<p><strong>1. 向上转型和向下转型</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    Son son = <span class="keyword">new</span> Son();</span><br><span class="line">    <span class="comment">//首先先明确一点，转型指的是左侧引用的改变。</span></span><br><span class="line">    <span class="comment">//father引用类型是Father，指向Son实例，就是向上转型，既可以使用子类的方法，也可以使用父类的方法。</span></span><br><span class="line">    <span class="comment">//向上转型,此时运行father的方法</span></span><br><span class="line">    Father father = son;</span><br><span class="line">    father.smoke();</span><br><span class="line">    <span class="comment">//不能使用子类独有的方法。</span></span><br><span class="line">    <span class="comment">// father.play();编译会报错</span></span><br><span class="line">    father.drive();</span><br><span class="line">    <span class="comment">//Son类型的引用指向Father的实例，所以是向下转型，不能使用子类非重写的方法，可以使用父类的方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向下转型，此时运行了son的方法</span></span><br><span class="line">    Son son1 = (Son) father;</span><br><span class="line">    <span class="comment">//转型后就是一个正常的Son实例</span></span><br><span class="line">    son1.play();</span><br><span class="line">    son1.drive();</span><br><span class="line">    son1.smoke();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为向下转型之前必须先经历向上转型。</span></span><br><span class="line">	<span class="comment">//在向下转型过程中，分为两种情况：</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//情况一：如果父类引用的对象如果引用的是指向的子类对象，</span></span><br><span class="line">	<span class="comment">//那么在向下转型的过程中是安全的。也就是编译是不会出错误的。</span></span><br><span class="line">    <span class="comment">//因为运行期Son实例确实有这些方法</span></span><br><span class="line">    Father f1 = <span class="keyword">new</span> Son();</span><br><span class="line">    Son s1 = (Son) f1;</span><br><span class="line">    s1.smoke();</span><br><span class="line">    s1.drive();</span><br><span class="line">    s1.play();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况二：如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，</span></span><br><span class="line">    <span class="comment">//但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误。</span></span><br><span class="line">    <span class="comment">//因为运行期Father实例并没有这些方法。</span></span><br><span class="line">        Father f2 = <span class="keyword">new</span> Father();</span><br><span class="line">        Son s2 = (Son) f2;</span><br><span class="line">        s2.drive();</span><br><span class="line">        s2.smoke();</span><br><span class="line">        s2.play();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向下转型和向上转型的应用，有些人觉得这个操作没意义，何必先向上转型再向下转型呢，不是多此一举么。其实可以用于方法参数中的类型聚合，然后具体操作再进行分解。</span></span><br><span class="line">    <span class="comment">//比如add方法用List引用类型作为参数传入，传入具体类时经历了向下转型</span></span><br><span class="line">    add(<span class="keyword">new</span> LinkedList());</span><br><span class="line">    add(<span class="keyword">new</span> ArrayList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总结</span></span><br><span class="line">    <span class="comment">//向上转型和向下转型都是针对引用的转型，是编译期进行的转型，根据引用类型来判断使用哪个方法</span></span><br><span class="line">    <span class="comment">//并且在传入方法时会自动进行转型（有需要的话）。运行期将引用指向实例，如果是不安全的转型则会报错。</span></span><br><span class="line">    <span class="comment">//若安全则继续执行方法。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">//在操作具体集合时又经历了向上转型</span></span><br><span class="line"><span class="comment">//        ArrayList arr = (ArrayList) list;</span></span><br><span class="line"><span class="comment">//        LinkedList link = (LinkedList) list;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>向上转型和向下转型都是针对引用的转型，是编译期进行的转型，根据引用类型来判断使用哪个方法。并且在传入方法时会自动进行转型（有需要的话）。运行期将引用指向实例，如果是不安全的转型则会报错，若安全则继续执行方法。</p>
<p><strong>2. 编译期的静态分派</strong></p>
<p>其实就是根据引用类型来调用对应方法。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    Father father  = <span class="keyword">new</span> Son();</span><br><span class="line">    静态分派 a= <span class="keyword">new</span> 静态分派();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译期确定引用类型为Father。</span></span><br><span class="line">    <span class="comment">//所以调用的是第一个方法。</span></span><br><span class="line">    a.play(father);</span><br><span class="line">    <span class="comment">//向下转型后，引用类型为Son，此时调用第二个方法。</span></span><br><span class="line">    <span class="comment">//所以，编译期只确定了引用，运行期再进行实例化。</span></span><br><span class="line">    a.play((Son)father);</span><br><span class="line">    <span class="comment">//当没有Son引用类型的方法时，会自动向上转型调用第一个方法。</span></span><br><span class="line">    a.smoke(father);</span><br><span class="line">    <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoke</span><span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"father smoke"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span> <span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"father"</span>);</span><br><span class="line">    <span class="comment">//father.drive();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span> <span class="params">(Son son)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"son"</span>);</span><br><span class="line">    <span class="comment">//son.drive();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 方法重载优先级匹配</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    方法重载优先级匹配 a = <span class="keyword">new</span> 方法重载优先级匹配();</span><br><span class="line">    <span class="comment">//普通的重载一般就是同名方法不同参数。</span></span><br><span class="line">    <span class="comment">//这里我们来讨论当同名方法只有一个参数时的情况。</span></span><br><span class="line">    <span class="comment">//此时会调用char参数的方法。</span></span><br><span class="line">    <span class="comment">//当没有char参数的方法。会调用int类型的方法，如果没有int就调用long</span></span><br><span class="line">    <span class="comment">//即存在一个调用顺序char -&gt; int -&gt; long -&gt;double -&gt; ..。</span></span><br><span class="line">    <span class="comment">//当没有基本类型对应的方法时，先自动装箱，调用包装类方法。</span></span><br><span class="line">    <span class="comment">//如果没有包装类方法，则调用包装类实现的接口的方法。</span></span><br><span class="line">    <span class="comment">//最后再调用持有多个参数的char...方法。</span></span><br><span class="line">    a.eat(<span class="string">'a'</span>);</span><br><span class="line">    a.eat(<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">short</span> i)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"short"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"int"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">double</span> i)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"double"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">long</span> i)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"long"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Character c)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Character"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Comparable c)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Comparable"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">char</span> ... c)</span> </span>&#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(Arrays.toString(c));</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void eat(char i) &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("char");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000009707894" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009707894</a></p>
<p><a href="https://www.cnblogs.com/hysum/p/7100874.html" target="_blank" rel="noopener">https://www.cnblogs.com/hysum/p/7100874.html</a></p>
<p><a href="http://c.biancheng.net/view/939.html" target="_blank" rel="noopener">http://c.biancheng.net/view/939.html</a></p>
<p><a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a></p>
<p><a href="https://blog.csdn.net/android_hl/article/details/53228348" target="_blank" rel="noopener">https://blog.csdn.net/android_hl/article/details/53228348</a></p>
<h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>Java【基础】</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java【基础】</tag>
      </tags>
  </entry>
  <entry>
    <title>10.Java异常</title>
    <url>/2019/11/15/Java-Abnormal/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文部分内容来源于网络，为了把本文主题讲得清晰透彻，也整合了很多我认为不错的技术博客内容，引用其中了一些比较好的博客文章，如有侵权，请联系作者。<br>该系列博文会告诉你如何从入门到进阶，一步步地学习Java基础知识，并上手进行实战，接着了解每个Java知识点背后的实现原理，更完整地了解整个Java技术体系，形成自己的知识框架。为了更好地总结和检验你的学习成果，本系列文章也会提供每个知识点对应的面试题以及参考答案。</p>
<a id="more"></a>

<h2 id="为什么要使用异常"><a href="#为什么要使用异常" class="headerlink" title="为什么要使用异常"></a>为什么要使用异常</h2><blockquote>
<p>  首先我们可以明确一点就是异常的处理机制可以确保我们程序的健壮性，提高系统可用率。虽然我们不是特别喜欢看到它，但是我们不能不承认它的地位，作用。</p>
</blockquote>
<p>在没有异常机制的时候我们是这样处理的：通过函数的返回值来判断是否发生了异常（这个返回值通常是已经约定好了的），调用该函数的程序负责检查并且分析返回值。虽然可以解决异常问题，但是这样做存在几个缺陷：</p>
<blockquote>
<p>  1、 容易混淆。如果约定返回值为-11111时表示出现异常，那么当程序最后的计算结果真的为-1111呢？</p>
<p>  2、 代码可读性差。将异常处理代码和程序代码混淆在一起将会降低代码的可读性。</p>
<p>  3、 由调用函数来分析异常，这要求程序员对库函数有很深的了解。</p>
</blockquote>
<p> 在OO中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它。</p>
<p>而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。</p>
<p>这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。（摘自《Think in java 》）。</p>
<p>该部分内容选自<a href="http://www.cnblogs.com/chenssy/p/3438130.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3438130.html</a></p>
<h2 id="异常基本定义"><a href="#异常基本定义" class="headerlink" title="异常基本定义"></a>异常基本定义</h2><blockquote>
<p>  在《Think in java》中是这样定义异常的：异常情形是指阻止当前方法或者作用域继续执行的问题。在这里一定要明确一点：异常代码某种程度的错误，尽管Java有异常处理机制，但是我们不能以“正常”的眼光来看待异常，异常处理机制的原因就是告诉你：这里可能会或者已经产生了错误，您的程序出现了不正常的情况，可能会导致程序失败！</p>
</blockquote>
<blockquote>
<p>  那么什么时候才会出现异常呢？只有在你当前的环境下程序无法正常运行下去，也就是说程序已经无法来正确解决问题了，这时它所就会从当前环境中跳出，并抛出异常。抛出异常后，它首先会做几件事。</p>
</blockquote>
<blockquote>
<p>首先，它会使用new创建一个异常对象，然后在产生异常的位置终止程序，并且从当前环境中弹出对异常对象的引用，这时。异常处理机制就会接管程序，并开始寻找一个恰当的地方来继续执行程序，这个恰当的地方就是异常处理程序。</p>
</blockquote>
<blockquote>
<p> 总的来说异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。</p>
</blockquote>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p>[外链图片转存失败(img-KNxcBTK0-1569073569353)(<a href="https://images0.cnblogs.com/blog/381060/201311/22185952-834d92bc2bfe498f9a33414cc7a2c8a4.png)]" target="_blank" rel="noopener">https://images0.cnblogs.com/blog/381060/201311/22185952-834d92bc2bfe498f9a33414cc7a2c8a4.png)]</a></p>
<p>从上面这幅图可以看出，Throwable是java语言中所有错误和异常的超类（万物即可抛）。它有两个子类：Error、Exception。</p>
<p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。</p>
<p>Throwable又派生出Error类和Exception类。</p>
<p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p>
<p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。</p>
<p>总体上我们根据Javac对异常的处理要求，将异常类分为2类。</p>
<blockquote>
<p>非检查异常（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。</p>
</blockquote>
<blockquote>
<p>对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。</p>
</blockquote>
<blockquote>
<p>检查异常（checked exception）：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。</p>
</blockquote>
<blockquote>
<p>这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。</p>
</blockquote>
<p>需要明确的是：检查和非检查是对于javac来说的，这样就很好理解和区分了。</p>
<p>这部分内容摘自<a href="http://www.importnew.com/26613.html" target="_blank" rel="noopener">http://www.importnew.com/26613.html</a></p>
<h2 id="初识异常"><a href="#初识异常" class="headerlink" title="初识异常"></a>初识异常</h2><p>异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么他的所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成的了异常追踪栈。</p>
<p>异常最先发生的地方，叫做异常抛出点。</p>
<pre><code>public class 异常 {
    public static void main (String [] args )
    {
        System . out. println( &quot;----欢迎使用命令行除法计算器----&quot; ) ;
        CMDCalculate ();
    }
    public static void CMDCalculate ()
    {
        Scanner scan = new Scanner ( System. in );
        int num1 = scan .nextInt () ;
        int num2 = scan .nextInt () ;
        int result = devide (num1 , num2 ) ;
        System . out. println( &quot;result:&quot; + result) ;
        scan .close () ;
    }
    public static int devide (int num1, int num2 ){
        return num1 / num2 ;
    }

//    ----欢迎使用命令行除法计算器----
//            1
//            0
//    Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero
//    at com.javase.异常.异常.devide(异常.java:24)
//    at com.javase.异常.异常.CMDCalculate(异常.java:19)
//    at com.javase.异常.异常.main(异常.java:12)</code></pre><p>​<br>    //  —-欢迎使用命令行除法计算器—-<br>    //    r<br>    //    Exception in thread “main” java.util.InputMismatchException<br>    //    at java.util.Scanner.throwFor(Scanner.java:864)<br>    //    at java.util.Scanner.next(Scanner.java:1485)<br>    //    at java.util.Scanner.nextInt(Scanner.java:2117)<br>    //    at java.util.Scanner.nextInt(Scanner.java:2076)<br>    //    at com.javase.异常.异常.CMDCalculate(异常.java:17)<br>    //    at com.javase.异常.异常.main(异常.java:12)</p>
<p>[外链图片转存失败(img-9rqUQJQj-1569073569354)(<a href="http://incdn1.b0.upaiyun.com/2017/09/0b3e4ca2f4cf8d7116c7ad354940601f.png)]" target="_blank" rel="noopener">http://incdn1.b0.upaiyun.com/2017/09/0b3e4ca2f4cf8d7116c7ad354940601f.png)]</a></p>
<p>从上面的例子可以看出，当devide函数发生除0异常时，devide函数将抛出ArithmeticException异常，因此调用他的CMDCalculate函数也无法正常完成，因此也发送异常，而CMDCalculate的caller——main 因为CMDCalculate抛出异常，也发生了异常，这样一直向调用栈的栈底回溯。</p>
<p>这种行为叫做异常的冒泡，异常的冒泡是为了在当前发生异常的函数或者这个函数的caller中找到最近的异常处理程序。由于这个例子中没有使用任何异常处理机制，因此异常最终由main函数抛给JRE，导致程序终止。</p>
<blockquote>
<p>上面的代码不使用异常处理机制，也可以顺利编译，因为2个异常都是非检查异常。但是下面的例子就必须使用异常处理机制，因为异常是检查异常。</p>
</blockquote>
<p>代码中我选择使用throws声明异常，让函数的调用者去处理可能发生的异常。但是为什么只throws了IOException呢？因为FileNotFoundException是IOException的子类，在处理范围内。</p>
<h2 id="异常和错误"><a href="#异常和错误" class="headerlink" title="异常和错误"></a>异常和错误</h2><p>下面看一个例子</p>
<pre><code>//错误即error一般指jvm无法处理的错误
//异常是Java定义的用于简化错误处理流程和定位错误的一种工具。
public class 错误和错误 {
    Error error = new Error();

    public static void main(String[] args) {
        throw new Error();
    }

    //下面这四个异常或者错误有着不同的处理方法
    public void error1 (){
        //编译期要求必须处理，因为这个异常是最顶层异常，包括了检查异常，必须要处理
        try {
            throw new Throwable();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }
    //Exception也必须处理。否则报错，因为检查异常都继承自exception，所以默认需要捕捉。
    public void error2 (){
        try {
            throw new Exception();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //error可以不处理，编译不报错,原因是虚拟机根本无法处理，所以啥都不用做
    public void error3 (){
        throw new Error();
    }

    //runtimeexception众所周知编译不会报错
    public void error4 (){
        throw new RuntimeException();
    }
//    Exception in thread &quot;main&quot; java.lang.Error
//    at com.javase.异常.错误.main(错误.java:11)

}</code></pre><h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><p>在编写代码处理异常时，对于检查异常，有2种不同的处理方式：</p>
<blockquote>
<p>使用try…catch…finally语句块处理它。</p>
</blockquote>
<blockquote>
<p>或者，在函数签名中使用throws 声明交给函数调用者caller去解决。</p>
</blockquote>
<p>下面看几个具体的例子，包括error，exception和throwable</p>
<p>上面的例子是运行时异常，不需要显示捕获。<br>下面这个例子是可检查异常需，要显示捕获或者抛出。</p>
<pre><code>@Test
public void testException() throws IOException
{
    //FileInputStream的构造函数会抛出FileNotFoundException
    FileInputStream fileIn = new FileInputStream(&quot;E:\\a.txt&quot;);

    int word;
    //read方法会抛出IOException
    while((word =  fileIn.read())!=-1)
    {
        System.out.print((char)word);
    }
    //close方法会抛出IOException
    fileIn.close();
}</code></pre><p>一般情况下的处理方式 try catch finally</p>
<pre><code>public class 异常处理方式 {

@Test
public void main() {
    try{
        //try块中放可能发生异常的代码。
        InputStream inputStream = new FileInputStream(&quot;a.txt&quot;);

        //如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。
        int i = 1/0;
        //如果发生异常，则尝试去匹配catch块。
        throw new SQLException();
        //使用1.8jdk同时捕获多个异常，runtimeexception也可以捕获。只是捕获后虚拟机也无法处理，所以不建议捕获。
    }catch(SQLException | IOException | ArrayIndexOutOfBoundsException exception){
        System.out.println(exception.getMessage());
        //每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。

        //catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。

        //在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。

        //如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。

        //如果try中没有发生异常，则所有的catch块将被忽略。

    }catch(Exception exception){
        System.out.println(exception.getMessage());
        //...
    }finally{
        //finally块通常是可选的。
        //无论异常是否发生，异常是否匹配被处理，finally都会执行。

        //finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。
    }</code></pre><p>一个try至少要跟一个catch或者finally</p>
<pre><code>    try {
        int i = 1;
    }finally {
        //一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。
    }
}</code></pre><p>异常出现时该方法后面的代码不会运行，即使异常已经被捕获。这里举出一个奇特的例子，在catch里再次使用try catch finally</p>
<pre><code>@Test
public void test() {
    try {
        throwE();
        System.out.println(&quot;我前面抛出异常了&quot;);
        System.out.println(&quot;我不会执行了&quot;);
    } catch (StringIndexOutOfBoundsException e) {
        System.out.println(e.getCause());
    }catch (Exception ex) {
    //在catch块中仍然可以使用try catch finally
        try {
            throw new Exception();
        }catch (Exception ee) {

        }finally {
            System.out.println(&quot;我所在的catch块没有执行，我也不会执行的&quot;);
        }
    }
}
//在方法声明中抛出的异常必须由调用方法处理或者继续往上抛，
// 当抛到jre时由于无法处理终止程序
public void throwE (){
//        Socket socket = new Socket(&quot;127.0.0.1&quot;, 80);

        //手动抛出异常时，不会报错，但是调用该方法的方法需要处理这个异常，否则会出错。
//        java.lang.StringIndexOutOfBoundsException
//        at com.javase.异常.异常处理方式.throwE(异常处理方式.java:75)
//        at com.javase.异常.异常处理方式.test(异常处理方式.java:62)
        throw new StringIndexOutOfBoundsException();
    }</code></pre><p>其实有的语言在遇到异常后仍然可以继续运行</p>
<blockquote>
<p>有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handling（恢复式异常处理模式 ）</p>
<p>而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handling（终结式异常处理模式）</p>
</blockquote>
<h2 id="“不负责任”的throws"><a href="#“不负责任”的throws" class="headerlink" title="“不负责任”的throws"></a>“不负责任”的throws</h2><p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p>
<p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p>
<pre><code>public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN
{ 
     //foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。
}</code></pre><h2 id="纠结的finally"><a href="#纠结的finally" class="headerlink" title="纠结的finally"></a>纠结的finally</h2><p>finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。</p>
<p>良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源。</p>
<p>需要注意的地方:</p>
<p>1、finally块没有处理异常的能力。处理异常的只能是catch块。</p>
<p>2、在同一try…catch…finally块中 ，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有catch块匹配，则先执行finally，然后去外面的调用者中寻找合适的catch块。</p>
<p>3、在同一try…catch…finally块中 ，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：首先执行finally块，然后去外围调用者中寻找合适的catch块。</p>
<pre><code>public class finally使用 {
    public static void main(String[] args) {
        try {
            throw new IllegalAccessException();
        }catch (IllegalAccessException e) {
            // throw new Throwable();
            //此时如果再抛异常，finally无法执行，只能报错。
            //finally无论何时都会执行
            //除非我显示调用。此时finally才不会执行
            System.exit(0);

        }finally {
            System.out.println(&quot;算你狠&quot;);
        }
    }
}</code></pre><h2 id="throw-JRE也使用的关键字"><a href="#throw-JRE也使用的关键字" class="headerlink" title="throw : JRE也使用的关键字"></a>throw : JRE也使用的关键字</h2><p>throw exceptionObject</p>
<p>程序员也可以通过throw语句手动显式的抛出一个异常。throw语句的后面必须是一个异常对象。</p>
<p>throw 语句必须写在函数中，执行throw 语句的地方就是一个异常抛出点，==它和由JRE自动形成的异常抛出点没有任何差别。==</p>
<pre><code>public void save(User user)
{
      if(user  == null) 
          throw new IllegalArgumentException(&quot;User对象为空&quot;);
      //......

}</code></pre><p>后面开始的大部分内容都摘自<a href="http://www.cnblogs.com/lulipro/p/7504267.html" target="_blank" rel="noopener">http://www.cnblogs.com/lulipro/p/7504267.html</a></p>
<p>该文章写的十分细致到位，令人钦佩，是我目前为之看到关于异常最详尽的文章，可以说是站在巨人的肩膀上了。</p>
<h2 id="异常调用链"><a href="#异常调用链" class="headerlink" title="异常调用链"></a>异常调用链</h2><p>异常的链化</p>
<p>在一些大型的，模块化的软件开发中，一旦一个地方发生异常，则如骨牌效应一样，将导致一连串的异常。假设B模块完成自己的逻辑需要调用A模块的方法，如果A模块发生异常，则B也将不能完成而发生异常。</p>
<p>==但是B在抛出异常时，会将A的异常信息掩盖掉，这将使得异常的根源信息丢失。异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。==</p>
<blockquote>
<p>异常链化:以一个异常对象为参数构造新的异常对象。新的异对象将包含先前异常的信息。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫他根源异常（cause）。</p>
</blockquote>
<p>查看Throwable类源码，可以发现里面有一个Throwable字段cause，就是它保存了构造时传递的根源异常参数。这种设计和链表的结点类设计如出一辙，因此形成链也是自然的了。</p>
<pre><code>public class Throwable implements Serializable {
    private Throwable cause = this;

    public Throwable(String message, Throwable cause) {
        fillInStackTrace();
        detailMessage = message;
        this.cause = cause;
    }
     public Throwable(Throwable cause) {
        fillInStackTrace();
        detailMessage = (cause==null ? null : cause.toString());
        this.cause = cause;
    }

    //........
}</code></pre><p>下面看一个比较实在的异常链例子哈</p>
<pre><code>public class 异常链 {
    @Test
    public void test() {
        C();
    }
    public void A () throws Exception {
        try {
            int i = 1;
            i = i / 0;
            //当我注释掉这行代码并使用B方法抛出一个error时，运行结果如下
//            四月 27, 2018 10:12:30 下午 org.junit.platform.launcher.core.ServiceLoaderTestEngineRegistry loadTestEngines
//            信息: Discovered TestEngines with IDs: [junit-jupiter]
//            java.lang.Error: B也犯了个错误
//            at com.javase.异常.异常链.B(异常链.java:33)
//            at com.javase.异常.异常链.C(异常链.java:38)
//            at com.javase.异常.异常链.test(异常链.java:13)
//            at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
//            Caused by: java.lang.Error
//            at com.javase.异常.异常链.B(异常链.java:29)

        }catch (ArithmeticException e) {
            //这里通过throwable类的构造方法将最底层的异常重新包装并抛出，此时注入了A方法的信息。最后打印栈信息时可以看到caused by
            A方法的异常。
            //如果直接抛出，栈信息打印结果只能看到上层方法的错误信息，不能看到其实是A发生了错误。
            //所以需要包装并抛出
            throw new Exception(&quot;A方法计算错误&quot;, e);
        }

    }
    public void B () throws Exception,Error {
        try {
            //接收到A的异常，
            A();
            throw new Error();
        }catch (Exception e) {
            throw e;
        }catch (Error error) {
            throw new Error(&quot;B也犯了个错误&quot;, error);
        }
    }
    public void C () {
        try {
            B();
        }catch (Exception | Error e) {
            e.printStackTrace();
        }

    }

    //最后结果
//    java.lang.Exception: A方法计算错误
//    at com.javase.异常.异常链.A(异常链.java:18)
//    at com.javase.异常.异常链.B(异常链.java:24)
//    at com.javase.异常.异常链.C(异常链.java:31)
//    at com.javase.异常.异常链.test(异常链.java:11)
//    省略
//    Caused by: java.lang.ArithmeticException: / by zero
//    at com.javase.异常.异常链.A(异常链.java:16)
//            ... 31 more
}</code></pre><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。</p>
<p>按照国际惯例，自定义的异常应该总是包含如下的构造函数：</p>
<p>一个无参构造函数<br>一个带有String参数的构造函数，并传递给父类的构造函数。<br>一个带有String参数和Throwable参数，并都传递给父类构造函数<br>一个带有Throwable 参数的构造函数，并传递给父类的构造函数。<br>下面是IOException类的完整源代码，可以借鉴。</p>
<pre><code>public class IOException extends Exception
{
    static final long serialVersionUID = 7818375828146090155L;

    public IOException()
    {
        super();
    }

    public IOException(String message)
    {
        super(message);
    }

    public IOException(String message, Throwable cause)
    {
        super(message, cause);
    }

    public IOException(Throwable cause)
    {
        super(cause);
    }
}</code></pre><h2 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h2><p>异常的注意事项</p>
<blockquote>
<p>当子类重写父类的带有 throws声明的函数时，其throws声明的异常必须在父类异常的可控范围内——用于处理父类的throws方法的异常处理器，必须也适用于子类的这个带throws方法 。这是为了支持多态。</p>
<p>例如，父类方法throws 的是2个异常，子类就不能throws 3个及以上的异常。父类throws IOException，子类就必须throws IOException或者IOException的子类。</p>
</blockquote>
<p>至于为什么？我想，也许下面的例子可以说明。</p>
<pre><code>class Father
{
    public void start() throws IOException
    {
        throw new IOException();
    }
}

class Son extends Father
{
    public void start() throws Exception
    {
        throw new SQLException();
    }
}</code></pre><p>/<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>假设上面的代码是允许的（实质是错误的）<strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong>/</p>
<pre><code>class Test
{
    public static void main(String[] args)
    {
        Father[] objs = new Father[2];
        objs[0] = new Father();
        objs[1] = new Son();

        for(Father obj:objs)
        {
        //因为Son类抛出的实质是SQLException，而IOException无法处理它。
        //那么这里的try。。catch就不能处理Son中的异常。
        //多态就不能实现了。
            try {
                 obj.start();
            }catch(IOException)
            {
                 //处理IOException
            }
         }
   }
}</code></pre><p>==Java的异常执行流程是线程独立的，线程之间没有影响==</p>
<blockquote>
<p>Java程序可以是多线程的。每一个线程都是一个独立的执行流，独立的函数调用栈。如果程序只有一个线程，那么没有被任何代码处理的异常 会导致程序终止。如果是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。</p>
<p>也就是说，Java中的异常是线程独立的，线程的问题应该由线程自己来解决，而不要委托到外部，也不会直接影响到其它线程的执行。</p>
</blockquote>
<p>下面看一个例子</p>
<pre><code>public class 多线程的异常 {
    @Test
    public void test() {
        go();
    }
    public void go () {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for (int i = 0;i &lt;= 2;i ++) {
            int finalI = i;
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            executorService.execute(new Runnable() {
                @Override
                //每个线程抛出异常时并不会影响其他线程的继续执行
                public void run() {
                    try {
                        System.out.println(&quot;start thread&quot; + finalI);
                        throw new Exception();
                    }catch (Exception e) {
                        System.out.println(&quot;thread&quot; + finalI + &quot; go wrong&quot;);
                    }
                }
            });
        }
//        结果：
//        start thread0
//        thread0 go wrong
//        start thread1
//        thread1 go wrong
//        start thread2
//        thread2 go wrong
    }
}</code></pre><h2 id="当finally遇上return"><a href="#当finally遇上return" class="headerlink" title="当finally遇上return"></a>当finally遇上return</h2><p>首先一个不容易理解的事实：</p>
<p>在 try块中即便有return，break，continue等改变执行流的语句，finally也会执行。</p>
<pre><code>public static void main(String[] args)
{
    int re = bar();
    System.out.println(re);
}
private static int bar() 
{
    try{
        return 5;
    } finally{
        System.out.println(&quot;finally&quot;);
    }
}
/*输出：
finally
*/</code></pre><p>很多人面对这个问题时，总是在归纳执行的顺序和规律，不过我觉得还是很难理解。我自己总结了一个方法。用如下GIF图说明。</p>
<p>[外链图片转存失败(img-SceF4t85-1569073569354)(<a href="http://incdn1.b0.upaiyun.com/2017/09/0471c2805ebd5a463211ced478eaf7f8.gif)]" target="_blank" rel="noopener">http://incdn1.b0.upaiyun.com/2017/09/0471c2805ebd5a463211ced478eaf7f8.gif)]</a></p>
<p>也就是说：try…catch…finally中的return 只要能执行，就都执行了，他们共同向同一个内存地址（假设地址是0×80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。那么，按照这个思想，下面的这个例子也就不难理解了。</p>
<p>finally中的return 会覆盖 try 或者catch中的返回值。</p>
<pre><code>public static void main(String[] args)
    {
        int result;

        result  =  foo();
        System.out.println(result);     /////////2

        result = bar();
        System.out.println(result);    /////////2
    }

    @SuppressWarnings(&quot;finally&quot;)
    public static int foo()
    {
        trz{
            int a = 5 / 0;
        } catch (Exception e){
            return 1;
        } finally{
            return 2;
        }

    }

    @SuppressWarnings(&quot;finally&quot;)
    public static int bar()
    {
        try {
            return 1;
        }finally {
            return 2;
        }
    }</code></pre><p>finally中的return会抑制（消灭）前面try或者catch块中的异常</p>
<pre><code>class TestException
{
    public static void main(String[] args)
    {
        int result;
        try{
            result = foo();
            System.out.println(result);           //输出100
        } catch (Exception e){
            System.out.println(e.getMessage());    //没有捕获到异常
        }

        try{
            result  = bar();
            System.out.println(result);           //输出100
        } catch (Exception e){
            System.out.println(e.getMessage());    //没有捕获到异常
        }
    }

    //catch中的异常被抑制
    @SuppressWarnings(&quot;finally&quot;)
    public static int foo() throws Exception
    {
        try {
            int a = 5/0;
            return 1;
        }catch(ArithmeticException amExp) {
            throw new Exception(&quot;我将被忽略，因为下面的finally中使用了return&quot;);
        }finally {
            return 100;
        }
    }

    //try中的异常被抑制
    @SuppressWarnings(&quot;finally&quot;)
    public static int bar() throws Exception
    {
        try {
            int a = 5/0;
            return 1;
        }finally {
            return 100;
        }
    }
}</code></pre><p>finally中的异常会覆盖（消灭）前面try或者catch中的异常</p>
<pre><code>class TestException
{
    public static void main(String[] args)
    {
        int result;
        try{
            result = foo();
        } catch (Exception e){
            System.out.println(e.getMessage());    //输出：我是finaly中的Exception
        }

        try{
            result  = bar();
        } catch (Exception e){
            System.out.println(e.getMessage());    //输出：我是finaly中的Exception
        }
    }

    //catch中的异常被抑制
    @SuppressWarnings(&quot;finally&quot;)
    public static int foo() throws Exception
    {
        try {
            int a = 5/0;
            return 1;
        }catch(ArithmeticException amExp) {
            throw new Exception(&quot;我将被忽略，因为下面的finally中抛出了新的异常&quot;);
        }finally {
            throw new Exception(&quot;我是finaly中的Exception&quot;);
        }
    }

    //try中的异常被抑制
    @SuppressWarnings(&quot;finally&quot;)
    public static int bar() throws Exception
    {
        try {
            int a = 5/0;
            return 1;
        }finally {
            throw new Exception(&quot;我是finaly中的Exception&quot;);
        }

    }
}</code></pre><p>上面的3个例子都异于常人的编码思维，因此我建议：</p>
<blockquote>
<p>不要在fianlly中使用return。</p>
</blockquote>
<blockquote>
<p>不要在finally中抛出异常。</p>
</blockquote>
<blockquote>
<p>减轻finally的任务，不要在finally中做一些其它的事情，finally块仅仅用来释放资源是最合适的。</p>
</blockquote>
<blockquote>
<p>将尽量将所有的return写在函数的最后面，而不是try … catch … finally中。</p>
</blockquote>
<h2 id="JAVA异常常见面试题"><a href="#JAVA异常常见面试题" class="headerlink" title="JAVA异常常见面试题"></a>JAVA异常常见面试题</h2><p>　　下面是我个人总结的在Java和J2EE开发者在面试中经常被问到的有关Exception和Error的知识。在分享我的回答的时候，我也给这些问题作了快速修订，并且提供源码以便深入理解。我总结了各种难度的问题，适合新手码农和高级Java码农。如果你遇到了我列表中没有的问题，并且这个问题非常好，请在下面评论中分享出来。你也可以在评论中分享你面试时答错的情况。</p>
<p><strong>1) Java中什么是Exception?</strong><br>　　这个问题经常在第一次问有关异常的时候或者是面试菜鸟的时候问。我从来没见过面高级或者资深工程师的时候有人问这玩意，但是对于菜鸟，是很愿意问这个的。简单来说，异常是Java传达给你的系统和程序错误的方式。在java中，异常功能是通过实现比如Throwable，Exception，RuntimeException之类的类，然后还有一些处理异常时候的关键字，比如throw，throws，try，catch，finally之类的。 所有的异常都是通过Throwable衍生出来的。Throwable把错误进一步划分为 java.lang.Exception<br>和 java.lang.Error.  java.lang.Error 用来处理系统错误，例如java.lang.StackOverFlowError 之类的。然后 Exception用来处理程序错误，请求的资源不可用等等。</p>
<p><strong>2) Java中的检查型异常和非检查型异常有什么区别？</strong></p>
<p>　　这又是一个非常流行的Java异常面试题，会出现在各种层次的Java面试中。检查型异常和非检查型异常的主要区别在于其处理方式。检查型异常需要使用try, catch和finally关键字在编译期进行处理，否则会出现编译器会报错。对于非检查型异常则不需要这样做。Java中所有继承自java.lang.Exception类的异常都是检查型异常，所有继承自RuntimeException的异常都被称为非检查型异常。</p>
<p><strong>3) Java中的NullPointerException和ArrayIndexOutOfBoundException之间有什么相同之处？</strong></p>
<p>　　在Java异常面试中这并不是一个很流行的问题，但会出现在不同层次的初学者面试中，用来测试应聘者对检查型异常和非检查型异常的概念是否熟悉。顺便说一下，该题的答案是，这两个异常都是非检查型异常，都继承自RuntimeException。该问题可能会引出另一个问题，即Java和C的数组有什么不同之处，因为C里面的数组是没有大小限制的，绝对不会抛出ArrayIndexOutOfBoundException。</p>
<p><strong>4)在Java异常处理的过程中，你遵循的那些最好的实践是什么？</strong></p>
<p>　　这个问题在面试技术经理是非常常见的一个问题。因为异常处理在项目设计中是非常关键的，所以精通异常处理是十分必要的。异常处理有很多最佳实践，下面列举集中，它们提高你代码的健壮性和灵活性：</p>
<p>　　1) 调用方法的时候返回布尔值来代替返回null，这样可以 NullPointerException。由于空指针是java异常里最恶心的异常</p>
<p>　　2) catch块里别不写代码。空catch块是异常处理里的错误事件，因为它只是捕获了异常，却没有任何处理或者提示。通常你起码要打印出异常信息，当然你最好根据需求对异常信息进行处理。</p>
<p>　　3)能抛受控异常（checked Exception）就尽量不抛受非控异常(checked Exception)。通过去掉重复的异常处理代码，可以提高代码的可读性。</p>
<p>　　4) 绝对不要让你的数据库相关异常显示到客户端。由于绝大多数数据库和SQLException异常都是受控异常，在Java中，你应该在DAO层把异常信息处理，然后返回处理过的能让用户看懂并根据异常提示信息改正操作的异常信息。</p>
<p>　　5) 在Java中，一定要在数据库连接，数据库查询，流处理后，在finally块中调用close()方法。</p>
<p><strong>5) 既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常?</strong></p>
<p>　　这是一个有争议的问题，在回答该问题时你应当小心。虽然他们肯定愿意听到你的观点，但其实他们最感兴趣的还是有说服力的理由。我认为其中一个理由是，存在检查型异常是一个设计上的决定，受到了诸如C++等比Java更早编程语言设计经验的影响。绝大多数检查型异常位于java.io包内，这是合乎情理的，因为在你请求了不存在的系统资源的时候，一段强壮的程序必须能够优雅的处理这种情况。通过把IOException声明为检查型异常，Java 确保了你能够优雅的对异常进行处理。另一个可能的理由是，可以使用catch或finally来确保数量受限的系统资源（比如文件描述符）在你使用后尽早得到释放。 Joshua<br>Bloch编写的 <a href="http://www.amazon.com/dp/0321356683/?tag=javamysqlanta-20" target="_blank" rel="noopener">Effective Java 一书</a> 中多处涉及到了该话题，值得一读。</p>
<p><strong>6)  throw 和 throws这两个关键字在java中有什么不同?</strong></p>
<p>　　一个java初学者应该掌握的面试问题。 throw 和 throws乍看起来是很相似的尤其是在你还是一个java初学者的时候。尽管他们看起来相似，都是在处理异常时候使用到的。但在代码里的使用方法和用到的地方是不同的。throws总是出现在一个函数头中，用来标明该成员函数可能抛出的各种异常, 你也可以申明未检查的异常，但这不是编译器强制的。如果方法抛出了异常那么调用这个方法的时候就需要将这个异常处理。另一个关键字  throw 是用来抛出任意异常的，按照语法你可以抛出任意 Throwable (i.e. Throwable<br>或任何Throwable的衍生类) , throw可以中断程序运行，因此可以用来代替return . 最常见的例子是用 throw 在一个空方法中需要return的地方抛出 UnSupportedOperationException 代码如下 :</p>
<table>
<thead>
<tr>
<th>123</th>
<th><code>private``static</code> <code>void</code> <code>show() {``throw``new</code> <code>UnsupportedOperationException(``&quot;Notyet implemented&quot;``);``}</code></th>
</tr>
</thead>
</table>
<p>　　可以看下这篇 <a href="http://javarevisited.blogspot.com/2012/02/difference-between-throw-and-throws-in.html" target="_blank" rel="noopener">文章</a>查看这两个关键字在java中更多的差异 。</p>
<p><strong>7) 什么是“异常链”?</strong></p>
<p>　　“异常链”是Java中非常流行的异常处理概念，是指在进行一个异常处理时抛出了另外一个异常，由此产生了一个异常链条。该技术大多用于将“ 受检查异常” （ checked exception）封装成为“非受检查异常”（unchecked exception)或者RuntimeException。顺便说一下，如果因为因为异常你决定抛出一个新的异常，你一定要包含原有的异常，这样，处理程序才可以通过getCause()和initCause()方法来访问异常最终的根源。</p>
<p><strong>) 你曾经自定义实现过异常吗？怎么写的?</strong></p>
<p>　　很显然，我们绝大多数都写过自定义或者业务异常，像AccountNotFoundException。在面试过程中询问这个Java异常问题的主要原因是去发现你如何使用这个特性的。这可以更准确和精致的去处理异常，当然这也跟你选择checked 还是unchecked exception息息相关。通过为每一个特定的情况创建一个特定的异常，你就为调用者更好的处理异常提供了更好的选择。相比通用异常（general exception)，我更倾向更为精确的异常。大量的创建自定义异常会增加项目class的个数，因此，在自定义异常和通用异常之间维持一个平衡是成功的关键。</p>
<p><strong>9) JDK7中对异常处理做了什么改变？</strong></p>
<p>　　这是最近新出的Java异常处理的面试题。JDK7中对错误(Error)和异常(Exception)处理主要新增加了2个特性，一是在一个catch块中可以出来多个异常，就像原来用多个catch块一样。另一个是自动化资源管理(ARM), 也称为try-with-resource块。这2个特性都可以在处理异常时减少代码量，同时提高代码的可读性。对于这些特性了解，不仅帮助开发者写出更好的异常处理的代码，也让你在面试中显的更突出。我推荐大家读一下Java 7攻略，这样可以更深入的了解这2个非常有用的特性。</p>
<p><strong>10) 你遇到过 OutOfMemoryError 错误嘛？你是怎么搞定的？</strong></p>
<p>　　这个面试题会在面试高级程序员的时候用，面试官想知道你是怎么处理这个危险的OutOfMemoryError错误的。必须承认的是，不管你做什么项目，你都会碰到这个问题。所以你要是说没遇到过，面试官肯定不会买账。要是你对这个问题不熟悉，甚至就是没碰到过，而你又有3、4年的Java经验了，那么准备好处理这个问题吧。在回答这个问题的同时，你也可以借机向面试秀一下你处理内存泄露、调优和调试方面的牛逼技能。我发现掌握这些技术的人都能给面试官留下深刻的印象。</p>
<p><strong>11) 如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗？</strong></p>
<p>　　这个问题也可以换个方式问：“如果在try或者finally的代码块中调用了System.exit()，结果会是怎样”。了解finally块是怎么执行的，即使是try里面已经使用了return返回结果的情况，对了解Java的异常处理都非常有价值。只有在try里面是有System.exit(0)来退出JVM的情况下finally块中的代码才不会执行。</p>
<p><strong>12)Java中final,finalize,finally关键字的区别</strong></p>
<p>　　这是一个经典的Java面试题了。我的一个朋友为Morgan Stanley招电信方面的核心Java开发人员的时候就问过这个问题。final和finally是Java的关键字，而finalize则是方法。final关键字在创建不可变的类的时候非常有用，只是声明这个类是final的。而finalize()方法则是垃圾回收器在回收一个对象前调用，但也Java规范里面没有保证这个方法一定会被调用。finally关键字是唯一一个和这篇文章讨论到的异常处理相关的关键字。在你的产品代码中，在关闭连接和资源文件的是时候都必须要用到finally块。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.xuebuyuan.com/3248044.html" target="_blank" rel="noopener">https://www.xuebuyuan.com/3248044.html</a><br><a href="https://www.jianshu.com/p/49d2c3975c56" target="_blank" rel="noopener">https://www.jianshu.com/p/49d2c3975c56</a><br><a href="http://c.biancheng.net/view/1038.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1038.html</a><br><a href="https://blog.csdn.net/Lisiluan/article/details/88745820" target="_blank" rel="noopener">https://blog.csdn.net/Lisiluan/article/details/88745820</a><br><a href="https://blog.csdn.net/michaelgo/article/details/82790253" target="_blank" rel="noopener">https://blog.csdn.net/michaelgo/article/details/82790253</a></p>
<h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>Java【基础】</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java【基础】</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Java 基本数据类型</title>
    <url>/2019/11/15/Java-Base-Data-Class/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
<a id="more"></a>

<h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
<p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/memorypic1.jpg" alt></p>
<p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
<h2 id="Java-的两大数据类型"><a href="#Java-的两大数据类型" class="headerlink" title="Java 的两大数据类型:"></a>Java 的两大数据类型:</h2><ul>
<li>内置数据类型</li>
<li>引用数据类型</li>
<li><ul>
<li>*</li>
</ul>
</li>
</ul>
<h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h3><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<p><strong>byte：</strong></p>
<ul>
<li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li>
<li>最小值是 -128（-2^7）；</li>
<li>最大值是 127（2^7-1）；</li>
<li>默认值是 0；</li>
<li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li>
<li>例子：byte a = 100，byte b = -50。</li>
</ul>
<p><strong>short：</strong></p>
<ul>
<li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>
<li>最小值是 -32768（-2^15）；</li>
<li>最大值是 32767（2^15 - 1）；</li>
<li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>
<li>默认值是 0；</li>
<li>例子：short s = 1000，short r = -20000。</li>
</ul>
<p><strong>int：</strong></p>
<ul>
<li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 -2,147,483,648（-2^31）；</li>
<li>最大值是 2,147,483,647（2^31 - 1）；</li>
<li>一般地整型变量默认为 int 类型；</li>
<li>默认值是 0 ；</li>
<li>例子：int a = 100000, int b = -200000。</li>
</ul>
<p><strong>long：</strong></p>
<ul>
<li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 -9,223,372,036,854,775,808（-2^63）；</li>
<li>最大值是 9,223,372,036,854,775,807（2^63 -1）；</li>
<li>这种类型主要使用在需要比较大整数的系统上；</li>
<li>默认值是 0L；</li>
<li>例子： long a = 100000L，Long b = -200000L。<br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li>
</ul>
<p><strong>float：</strong></p>
<ul>
<li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>
<li>float 在储存大型浮点数组的时候可节省内存空间；</li>
<li>默认值是 0.0f；</li>
<li>浮点数不能用来表示精确的值，如货币；</li>
<li>例子：float f1 = 234.5f。</li>
</ul>
<p><strong>double：</strong></p>
<ul>
<li>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</li>
<li>浮点数的默认类型为double类型；</li>
<li>double类型同样不能表示精确的值，如货币；</li>
<li>默认值是 0.0d；</li>
<li>例子：double d1 = 123.4。</li>
</ul>
<p><strong>boolean：</strong></p>
<ul>
<li>boolean数据类型表示一位的信息；</li>
<li>只有两个取值：true 和 false；</li>
<li>这种类型只作为一种标志来记录 true/false 情况；</li>
<li>默认值是 false；</li>
<li>例子：boolean one = true。</li>
</ul>
<p><strong>char：</strong></p>
<ul>
<li>char类型是一个单一的 16 位 Unicode 字符；</li>
<li>最小值是 \u0000（即为0）；</li>
<li>最大值是 \uffff（即为65,535）；</li>
<li>char 数据类型可以储存任何字符；</li>
<li>例子：char letter = ‘A’;。</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8位</span></span><br><span class="line"><span class="keyword">byte</span> bx = <span class="keyword">Byte</span>.MAX_VALUE;</span><br><span class="line"><span class="keyword">byte</span> bn = <span class="keyword">Byte</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">//16位</span></span><br><span class="line"><span class="keyword">short</span> sx = <span class="keyword">Short</span>.MAX_VALUE;</span><br><span class="line"><span class="keyword">short</span> sn = <span class="keyword">Short</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">//32位</span></span><br><span class="line"><span class="keyword">int</span> ix = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> in = Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">//64位</span></span><br><span class="line"><span class="keyword">long</span> lx = <span class="keyword">Long</span>.MAX_VALUE;</span><br><span class="line"><span class="keyword">long</span> ln = <span class="keyword">Long</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">//32位</span></span><br><span class="line"><span class="keyword">float</span> fx = <span class="keyword">Float</span>.MAX_VALUE;</span><br><span class="line"><span class="keyword">float</span> fn = <span class="keyword">Float</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">//64位</span></span><br><span class="line"><span class="keyword">double</span> dx = <span class="keyword">Double</span>.MAX_VALUE;</span><br><span class="line"><span class="keyword">double</span> dn = <span class="keyword">Double</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">//16位</span></span><br><span class="line"><span class="keyword">char</span> cx = Character.MAX_VALUE;</span><br><span class="line"><span class="keyword">char</span> cn = Character.MIN_VALUE;</span><br><span class="line"><span class="comment">//1位</span></span><br><span class="line"><span class="keyword">boolean</span> bt = <span class="keyword">Boolean</span>.<span class="keyword">TRUE</span>;</span><br><span class="line"><span class="keyword">boolean</span> bf = <span class="keyword">Boolean</span>.<span class="keyword">FALSE</span>;</span><br></pre></td></tr></table></figure>

<pre><code>`127`
`-128`
`32767`
`-32768`
`2147483647`
`-2147483648`
`9223372036854775807`
`-9223372036854775808`
`3.4028235E38`
`1.4E-45`
`1.7976931348623157E308`
`4.9E-324`
`￿`

`true`
`false`</code></pre><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul>
<li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li>
<li>对象、数组都是引用数据类型。</li>
<li>所有引用类型的默认值都是null。</li>
<li>一个引用变量可以用来引用任何与之兼容的类型。</li>
<li>例子：Site site = new Site(“Runoob”)。</li>
</ul>
<h3 id="Java-常量"><a href="#Java-常量" class="headerlink" title="Java 常量"></a>Java 常量</h3><p>常量在程序运行时是不能被修改的。</p>
<p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">double</span> PI = <span class="number">3.1415927</span>;</span><br></pre></td></tr></table></figure>

<p>虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。</p>
<p>字面量可以赋给任何内置类型的变量。例如：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">byte a</span> = 68;</span><br><span class="line"><span class="attribute">char a</span> = <span class="string">'A'</span></span><br></pre></td></tr></table></figure>

<h2 id="自动拆箱和装箱（详解）"><a href="#自动拆箱和装箱（详解）" class="headerlink" title="自动拆箱和装箱（详解）"></a>自动拆箱和装箱（详解）</h2><p>Java 5增加了自动装箱与自动拆箱机制，方便基本类型与包装类型的相互转换操作。在Java 5之前，如果要将一个int型的值转换成对应的包装器类型Integer，必须显式的使用new创建一个新的Integer对象，或者调用静态方法Integer.valueOf()。</p>
<pre><code>//在Java 5之前，只能这样做
Integer value = new Integer(10);
//或者这样做
Integer value = Integer.valueOf(10);
//直接赋值是错误的
//Integer value = 10;`</code></pre><p>在Java 5中，可以直接将整型赋给Integer对象，由编译器来完成从int型到Integer类型的转换，这就叫自动装箱。</p>
<pre><code>`//在Java 5中，直接赋值是合法的，由编译器来完成转换`
`Integer value = 10;`
`与此对应的，自动拆箱就是可以将包装类型转换为基本类型，具体的转换工作由编译器来完成。`
`//在Java 5 中可以直接这么做`
`Integer value = new Integer(10);`
`int i = value;`</code></pre><p>自动装箱与自动拆箱为程序员提供了很大的方便，而在实际的应用中，自动装箱与拆箱也是使用最广泛的特性之一。自动装箱和自动拆箱其实是Java编译器提供的一颗语法糖（语法糖是指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通过可提高开发效率，增加代码可读性，增加代码的安全性）。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在八种包装类型中，每一种包装类型都提供了两个方法：</p>
<p>静态方法valueOf(基本类型)：将给定的基本类型转换成对应的包装类型；</p>
<p>实例方法xxxValue()：将具体的包装类型对象转换成基本类型；<br>下面我们以int和Integer为例，说明Java中自动装箱与自动拆箱的实现机制。看如下代码：</p>
<pre><code>class Auto //code1
{
    public static void main(String[] args) 
    {
        //自动装箱
        Integer inte = 10;
        //自动拆箱
        int i = inte;

    //再double和Double来验证一下
    Double doub = 12.40;
    double d = doub;

    }

}</code></pre><p>上面的代码先将int型转为Integer对象，再讲Integer对象转换为int型，毫无疑问，这是可以正确运行的。可是，这种转换是怎么进行的呢？使用反编译工具，将生成的Class文件在反编译为Java文件，让我们看看发生了什么：</p>
<pre><code>class Auto//code2
{
  public static void main(String[] paramArrayOfString)
  {
    Integer localInteger = Integer.valueOf(10);</code></pre><p>​<br>​    int i = localInteger.intValue();</p>
<p>​<br>​<br>​    Double localDouble = Double.valueOf(12.4D);<br>​    double d = localDouble.doubleValue();<br>​<br>​      }<br>​    }</p>
<p>我们可以看到经过javac编译之后，code1的代码被转换成了code2，实际运行时，虚拟机运行的就是code2的代码。也就是说，虚拟机根本不知道有自动拆箱和自动装箱这回事；在将Java源文件编译为class文件的过程中，javac编译器在自动装箱的时候，调用了Integer.valueOf()方法，在自动拆箱时，又调用了intValue()方法。我们可以看到，double和Double也是如此。<br>实现总结：其实自动装箱和自动封箱是编译器为我们提供的一颗语法糖。在自动装箱时，编译器调用包装类型的valueOf()方法；在自动拆箱时，编译器调用了相应的xxxValue()方法。</p>
<h3 id="自动装箱与拆箱中的“坑”"><a href="#自动装箱与拆箱中的“坑”" class="headerlink" title="自动装箱与拆箱中的“坑”"></a>自动装箱与拆箱中的“坑”</h3><p>在使用自动装箱与自动拆箱时，要注意一些陷阱，为了避免这些陷阱，我们有必要去看一下各种包装类型的源码。</p>
<p>Integer源码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="symbol">Integer</span> <span class="symbol">extends</span> <span class="symbol">Number</span> <span class="symbol">implements</span> <span class="symbol">Comparable</span>&lt;<span class="symbol">Integer</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="built_in">int</span> value;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Integer的构造方法，接受一个整型参数,Integer对象表示的int值，保存在value中*/</span></span><br><span class="line"> <span class="keyword">public</span> Integer(<span class="built_in">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*equals()方法判断的是:所代表的int型的值是否相等*/</span></span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">bool</span>ean equals(Object obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj instanceof Integer) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Integer)obj).<span class="built_in">int</span>Value();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*返回这个Integer对象代表的int值，也就是保存在value中的值*/</span></span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> <span class="built_in">int</span>Value() &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 首先会判断i是否在[IntegerCache.low,Integer.high]之间</span></span><br><span class="line"><span class="comment">  * 如果是，直接返回Integer.cache中相应的元素</span></span><br><span class="line"><span class="comment">  * 否则，调用构造方法，创建一个新的Integer对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> static Integer valueOf(<span class="built_in">int</span> i) &#123;</span><br><span class="line">    assert IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> new Integer(i);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 静态内部类，缓存了从[low,high]对应的Integer对象</span></span><br><span class="line"><span class="comment">  * low -128这个值不会被改变</span></span><br><span class="line"><span class="comment">  * high 默认是127，可以改变，最大不超过：Integer.MAX_VALUE - (-low) -1</span></span><br><span class="line"><span class="comment">  * cache 保存从[low,high]对象的Integer对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> static <span class="keyword">class</span> <span class="symbol">IntegerCache</span> &#123;</span><br><span class="line">    static <span class="keyword">final</span> <span class="built_in">int</span> low = <span class="number">-128</span>;</span><br><span class="line">    static <span class="keyword">final</span> <span class="built_in">int</span> high;</span><br><span class="line">    static <span class="keyword">final</span> Integer cache[];</span><br><span class="line"> </span><br><span class="line">    static &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="built_in">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String <span class="built_in">int</span>egerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">int</span>egerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">int</span> i = parseInt(<span class="built_in">int</span>egerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"> </span><br><span class="line">        cache = new Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上是Oracle(Sun)公司JDK 1.7中Integer源码的一部分，通过分析上面的代码，得到：</p>
<p>1）Integer有一个实例域value，它保存了这个Integer所代表的int型的值，且它是final的，也就是说这个Integer对象一经构造完成，它所代表的值就不能再被改变。</p>
<p>2）Integer重写了equals()方法，它通过比较两个Integer对象的value，来判断是否相等。</p>
<p>3）重点是静态内部类IntegerCache，通过类名就可以发现：它是用来缓存数据的。它有一个数组，里面保存的是连续的Integer对象。<br>   (a) low：代表缓存数据中最小的值，固定是-128。</p>
<p>   (b) high：代表缓存数据中最大的值，它可以被该改变，默认是127。high最小是127，最大是Integer.MAX_VALUE-(-low)-1，如果high超过了这个值，那么cache[ ]的长度就超过Integer.MAX_VALUE了，也就溢出了。</p>
<p>   (c) cache[]：里面保存着从[low,high]所对应的Integer对象，长度是high-low+1(因为有元素0，所以要加1)。</p>
<p>4）调用valueOf(inti)方法时，首先判断i是否在[low,high]之间，如果是，则复用Integer.cache[i-low]。比如，如果Integer.valueOf(3)，直接返回Integer.cache[131]；如果i不在这个范围，则调用构造方法，构造出一个新的Integer对象。</p>
<p>5）调用intValue()，直接返回value的值。<br>通过3）和4）可以发现，默认情况下，在使用自动装箱时，VM会复用[-128,127]之间的Integer对象。</p>
<pre><code>Integer  a1 = 1;
Integer  a2 = 1;
Integer  a3 = new Integer(1);
//会打印true，因为a1和a2是同一个对象,都是Integer.cache[129]
System.out.println(a1 == a2);
//false，a3构造了一个新的对象，不同于a1,a2
System.out.println(a1 == a3);</code></pre><h3 id="了解基本类型缓存（常量池）的最佳实践"><a href="#了解基本类型缓存（常量池）的最佳实践" class="headerlink" title="了解基本类型缓存（常量池）的最佳实践"></a>了解基本类型缓存（常量池）的最佳实践</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//基本数据类型的常量池是<span class="number">-128</span>到<span class="number">127</span>之间。</span><br><span class="line">// 在这个范围中的基本数据类的包装类可以自动拆箱，比较时直接比较数值大小。</span><br><span class="line"><span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">    //<span class="type">int</span>的自动拆箱和装箱只在<span class="number">-128</span>到<span class="number">127</span>范围中进行，超过该范围的两个<span class="type">integer</span>的 == 判断是会返回<span class="keyword">false</span>的。</span><br><span class="line">    <span class="type">Integer</span> a1 = <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> a2 = <span class="number">-128</span>;</span><br><span class="line">    <span class="type">Integer</span> a3 = <span class="number">-128</span>;</span><br><span class="line">    <span class="type">Integer</span> a4 = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(a1 == a4);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(a2 == a3);</span><br><span class="line"></span><br><span class="line">    Byte b1 = <span class="number">127</span>;</span><br><span class="line">    Byte b2 = <span class="number">127</span>;</span><br><span class="line">    Byte b3 = <span class="number">-128</span>;</span><br><span class="line">    Byte b4 = <span class="number">-128</span>;</span><br><span class="line">    //byte都是相等的，因为范围就在<span class="number">-128</span>到<span class="number">127</span>之间</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(b1 == b2);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(b3 == b4);</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    Long c1 = <span class="number">128</span>L;</span><br><span class="line">    Long c2 = <span class="number">128</span>L;</span><br><span class="line">    Long c3 = <span class="number">-128</span>L;</span><br><span class="line">    Long c4 = <span class="number">-128</span>L;</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(c1 == c2);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(c3 == c4);</span><br><span class="line"></span><br><span class="line">    //<span class="type">char</span>没有负值</span><br><span class="line">    //发现<span class="type">char</span>也是在<span class="number">0</span>到<span class="number">127</span>之间自动拆箱</span><br><span class="line">    <span class="type">Character</span> d1 = <span class="number">128</span>;</span><br><span class="line">    <span class="type">Character</span> d2 = <span class="number">128</span>;</span><br><span class="line">    <span class="type">Character</span> d3 = <span class="number">127</span>;</span><br><span class="line">    <span class="type">Character</span> d4 = <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(d1 == d2);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(d3 == d4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    `结果`</span><br><span class="line">    </span><br><span class="line">    `<span class="keyword">false</span>`</span><br><span class="line">    `<span class="keyword">true</span>`</span><br><span class="line">    `<span class="keyword">true</span>`</span><br><span class="line">    `<span class="keyword">true</span>`</span><br><span class="line">    `<span class="keyword">false</span>`</span><br><span class="line">    `<span class="keyword">true</span>`</span><br><span class="line">    `<span class="keyword">false</span>`</span><br><span class="line">    `<span class="keyword">true</span>`</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> i = <span class="number">10</span>;</span><br><span class="line">    Byte b = <span class="number">10</span>;</span><br><span class="line">    //比较Byte和<span class="type">Integer</span>.两个对象无法直接比较，报错</span><br><span class="line">    //<span class="keyword">System</span>.<span class="keyword">out</span>.println(i == b);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("i == b " + i.equals(b));</span><br><span class="line">    //答案是<span class="keyword">false</span>,因为包装类的比较时先比较是否是同一个类，不是的话直接返回<span class="keyword">false</span>.</span><br><span class="line">    <span class="type">int</span> ii = <span class="number">128</span>;</span><br><span class="line">    short ss = <span class="number">128</span>;</span><br><span class="line">    long ll = <span class="number">128</span>;</span><br><span class="line">    <span class="type">char</span> cc = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("ii == bb " + (ii == ss));</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("ii == ll " + (ii == ll));</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("ii == cc " + (ii == cc));</span><br><span class="line">    </span><br><span class="line">    结果</span><br><span class="line">    i == b <span class="keyword">false</span></span><br><span class="line">    ii == bb <span class="keyword">true</span></span><br><span class="line">    ii == ll <span class="keyword">true</span></span><br><span class="line">    ii == cc <span class="keyword">true</span></span><br><span class="line">    </span><br><span class="line">    //这时候都是<span class="keyword">true</span>，因为基本数据类型直接比较值，值一样就可以。</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>通过上面的代码，我们分析一下自动装箱与拆箱发生的时机：</p>
<p>（1）当需要一个对象的时候会自动装箱，比如Integer a = 10;equals(Object o)方法的参数是Object对象，所以需要装箱。</p>
<p>（2）当需要一个基本类型时会自动拆箱，比如int a = new Integer(10);算术运算是在基本类型间进行的，所以当遇到算术运算时会自动拆箱，比如代码中的 c == (a + b);</p>
<p>（3） 包装类型 == 基本类型时，包装类型自动拆箱；</p>
<p>需要注意的是：“==”在没遇到算术运算时，不会自动拆箱；基本类型只会自动装箱为对应的包装类型，代码中最后一条说明的内容。</p>
<p>在JDK 1.5中提供了自动装箱与自动拆箱，这其实是Java 编译器的语法糖，编译器通过调用包装类型的valueOf()方法实现自动装箱，调用xxxValue()方法自动拆箱。自动装箱和拆箱会有一些陷阱，那就是包装类型复用了某些对象。</p>
<p>（1）Integer默认复用了[-128,127]这些对象，其中高位置可以修改；</p>
<p>（2）Byte复用了全部256个对象[-128,127]；</p>
<p>（3）Short服用了[-128,127]这些对象；</p>
<p>（4）Long服用了[-128,127];</p>
<p>（5）Character复用了[0,127],Charater不能表示负数;</p>
<p>Double和Float是连续不可数的，所以没法复用对象，也就不存在自动装箱复用陷阱。</p>
<p>Boolean没有自动装箱与拆箱，它也复用了Boolean.TRUE和Boolean.FALSE，通过Boolean.valueOf(boolean b)返回的Blooean对象要么是TRUE，要么是FALSE，这点也要注意。</p>
<p>本文介绍了“真实的”自动装箱与拆箱，为了避免写出错误的代码，又从包装类型的源码入手，指出了各种包装类型在自动装箱和拆箱时存在的陷阱，同时指出了自动装箱与拆箱发生的时机。</p>
<h2 id="基本数据类型的存储方式"><a href="#基本数据类型的存储方式" class="headerlink" title="基本数据类型的存储方式"></a>基本数据类型的存储方式</h2><p>上面自动拆箱和装箱的原理其实与常量池有关。</p>
<h3 id="存在栈中"><a href="#存在栈中" class="headerlink" title="存在栈中"></a>存在栈中</h3><p>public void(int a)<br>{<br>int i = 1;<br>int j = 1;<br>}<br>方法中的i 存在虚拟机栈的局部变量表里，i是一个引用，j也是一个引用，它们都指向局部变量表里的整型值 1.<br>int a是传值引用，所以a也会存在局部变量表。</p>
<h3 id="存在堆里"><a href="#存在堆里" class="headerlink" title="存在堆里"></a>存在堆里</h3><p>class A{<br>int i = 1;<br>A a = new A();<br>}<br>i是类的成员变量。类实例化的对象存在堆中，所以成员变量也存在堆中，引用a存的是对象的地址，引用i存的是值，这个值1也会存在堆中。可以理解为引用i指向了这个值1。也可以理解为i就是1.</p>
<p>3 包装类对象怎么存<br>其实我们说的常量池也可以叫对象池。<br>比如String a= new String(“a”).intern()时会先在常量池找是否有“a”对象如果有的话直接返回“a”对象在常量池的地址，即让引用a指向常量”a”对象的内存地址。<br>public native String intern();<br>Integer也是同理。</p>
<p>下图是Integer类型在常量池中查找同值对象的方法。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static Integer value<span class="constructor">Of(<span class="params">int</span> <span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="module-access"><span class="module"><span class="identifier">IntegerCache</span>.</span></span>low<span class="operator"> &amp;&amp; </span>i &lt;= <span class="module-access"><span class="module"><span class="identifier">IntegerCache</span>.</span></span>high)</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">IntegerCache</span>.</span></span>cache<span class="literal">[<span class="identifier">i</span> + (-I<span class="identifier">ntegerCache</span>.<span class="identifier">low</span>)]</span>;</span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">Integer(<span class="params">i</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">class</span> IntegerCache &#123;</span><br><span class="line">    static final <span class="built_in">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    static final <span class="built_in">int</span> high;</span><br><span class="line">    static final Integer cache<span class="literal">[]</span>;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="built_in">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.<span class="module-access"><span class="module"><span class="identifier">VM</span>.</span></span>get<span class="constructor">SavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != null) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">int</span> i = parse<span class="constructor">Int(<span class="params">integerCacheHighPropValue</span>)</span>;</span><br><span class="line">                i = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer<span class="literal">[(<span class="identifier">high</span> - <span class="identifier">low</span>) + <span class="number">1</span>]</span>;</span><br><span class="line">        <span class="built_in">int</span> j = low;</span><br><span class="line">        for(<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache<span class="literal">[<span class="identifier">k</span>]</span> = <span class="keyword">new</span> <span class="constructor">Integer(<span class="params">j</span><span class="operator">++</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="module-access"><span class="module"><span class="identifier">IntegerCache</span>.</span></span>high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="constructor">IntegerCache()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以基本数据类型的包装类型可以在常量池查找对应值的对象，找不到就会自动在常量池创建该值的对象。</p>
<p>而String类型可以通过intern来完成这个操作。</p>
<p>JDK1.7后，常量池被放入到堆空间中，这导致intern()函数的功能不同，具体怎么个不同法，且看看下面代码，这个例子是网上流传较广的一个例子，分析图也是直接粘贴过来的，这里我会用自己的理解去解释这个例子：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">java] </span>view plain copy</span><br><span class="line">String s = new String(<span class="string">"1"</span>)<span class="comment">;  </span></span><br><span class="line">s.intern()<span class="comment">;  </span></span><br><span class="line">String <span class="built_in">s2</span> = <span class="string">"1"</span><span class="comment">;  </span></span><br><span class="line">System.out.println(s == <span class="built_in">s2</span>)<span class="comment">;  </span></span><br><span class="line">  </span><br><span class="line">String <span class="built_in">s3</span> = new String(<span class="string">"1"</span>) + new String(<span class="string">"1"</span>)<span class="comment">;  </span></span><br><span class="line"><span class="built_in">s3</span>.intern()<span class="comment">;  </span></span><br><span class="line">String <span class="built_in">s4</span> = <span class="string">"11"</span><span class="comment">;  </span></span><br><span class="line">System.out.println(<span class="built_in">s3</span> == <span class="built_in">s4</span>)<span class="comment">;  </span></span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line">[<span class="keyword">java] </span>view plain copy</span><br><span class="line"><span class="keyword">JDK1.6以及以下：false </span>false  </span><br><span class="line"><span class="keyword">JDK1.7以及以上：false </span>true</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180422231916788?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<p><img src="https://img-blog.csdn.net/20180422231929413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3MjQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"><br>JDK1.6查找到常量池存在相同值的对象时会直接返回该对象的地址。</p>
<p>JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。</p>
<p>那么其他字符串在常量池找值时就会返回另一个堆中对象的地址。</p>
<p>下一节详细介绍String以及相关包装类。</p>
<p>具体请见：<a href="https://blog.csdn.net/a724888/article/details/80042298" target="_blank" rel="noopener">https://blog.csdn.net/a724888/article/details/80042298</a></p>
<p>关于Java面向对象三大特性，请参考：</p>
<p><a href="https://blog.csdn.net/a724888/article/details/80033043" target="_blank" rel="noopener">https://blog.csdn.net/a724888/article/details/80033043</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.runoob.com/java/java-basic-datatypes.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-basic-datatypes.html</a></p>
<p><a href="https://www.cnblogs.com/zch1126/p/5335139.html" target="_blank" rel="noopener">https://www.cnblogs.com/zch1126/p/5335139.html</a></p>
<p><a href="https://blog.csdn.net/jreffchen/article/details/81015884" target="_blank" rel="noopener">https://blog.csdn.net/jreffchen/article/details/81015884</a></p>
<p><a href="https://blog.csdn.net/yuhongye111/article/details/31850779" target="_blank" rel="noopener">https://blog.csdn.net/yuhongye111/article/details/31850779</a></p>
<h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>Java【基础】</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java【基础】</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 3 快捷键汇总</title>
    <url>/2019/02/19/ck33bhg88000xw4mkdm5sf3c8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常用 Sublime Text 3 快捷键。</p>
<a id="more"></a>

<h1 id="选择类"><a href="#选择类" class="headerlink" title="选择类"></a>选择类</h1><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>D</kbd></td>
<td align="left">选中光标所在单位上的单词，如果光标位于单词前后，重复则会选中下一个相同的单词；如果光标已选中单词，重复则会选中下一个相同的字符串（即使该字符串位于其他单词中）</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>K</kbd> + <kbd>D</kbd></td>
<td align="left">在重复 <kbd>Ctrl</kbd> + <kbd>D</kbd> 的过程中跳过单词或字符串的选择</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>F3</kbd></td>
<td align="left">选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑<br>举例：快速选中并更改所有相同的变量名、函数名等</td>
</tr>
<tr>
<td align="left"><kbd>Shift</kbd> + <kbd>Right Button</kbd></td>
<td align="left">拖动选取用于矩形选择，功能与鼠标中键拖动相同</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>L</kbd></td>
<td align="left">选中整行，重复则扩展选择下一行，功能与 <kbd>Shift</kbd> + <kbd>↓</kbd> 相同</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd></td>
<td align="left">先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd></td>
<td align="left">扩展选中范围至匹配括号，重复则继续扩展<br>举例：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Space</kbd></td>
<td align="left">扩展选中范围至作用域，重复则继续扩展</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>J</kbd></td>
<td align="left">扩展选中范围至缩进，重复则继续扩展（以缩进层级为依据向外层层选中）</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>A</kbd></td>
<td align="left">扩展选中范围至标签，重复则继续扩展（一般用于html文件）</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Enter</kbd></td>
<td align="left">在下一行插入新行，即使光标不在行尾，也能快速向下插入一行</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Enter</kbd></td>
<td align="left">在上一行插入新行，即使光标不在行首，也能快速向上插入一行</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>[</kbd></td>
<td align="left">选中代码，按下快捷键，折叠代码</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>]</kbd></td>
<td align="left">选中代码，按下快捷键，展开代码</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>K</kbd> + <kbd>0</kbd> / <kbd>J</kbd></td>
<td align="left">展开所有折叠代码</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>←</kbd></td>
<td align="left">向左单位性地移动光标，快速移动光标</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>→</kbd></td>
<td align="left">向右单位性地移动光标，快速移动光标</td>
</tr>
<tr>
<td align="left"><kbd>Shift</kbd> + <kbd>↑</kbd></td>
<td align="left">向上选中多行</td>
</tr>
<tr>
<td align="left"><kbd>Shift</kbd> + <kbd>↓</kbd></td>
<td align="left">向下选中多行</td>
</tr>
<tr>
<td align="left"><kbd>Shift</kbd> + <kbd>←</kbd></td>
<td align="left">向左选中文本</td>
</tr>
<tr>
<td align="left"><kbd>Shift</kbd> + <kbd>→</kbd></td>
<td align="left">向右选中文本</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>←</kbd></td>
<td align="left">向左单位性地选中文本</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>→</kbd></td>
<td align="left">向右单位性地选中文本</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>↑</kbd></td>
<td align="left">将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>↓</kbd></td>
<td align="left">将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>↑</kbd></td>
<td align="left">向上添加多行光标，用于多行编辑</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>↓</kbd></td>
<td align="left">向下添加多行光标，用于多行编辑</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Left Button</kbd></td>
<td align="left">添加多行光标，用于多行编辑</td>
</tr>
</tbody></table>
<h1 id="编辑类"><a href="#编辑类" class="headerlink" title="编辑类"></a>编辑类</h1><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>J</kbd></td>
<td align="left">将下一行添加到本行末尾，或将选中的多行合并为一行<br>举例：将多行格式的CSS属性合并为一行</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>V</kbd></td>
<td align="left">粘贴时保留原有缩进</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>D</kbd></td>
<td align="left">复制光标所在整行，插入到下一行</td>
</tr>
<tr>
<td align="left"><kbd>Tab</kbd></td>
<td align="left">向右缩进</td>
</tr>
<tr>
<td align="left"><kbd>Shift</kbd> + <kbd>Tab</kbd></td>
<td align="left">向左缩进</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>[</kbd></td>
<td align="left">整行向左缩进</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>]</kbd></td>
<td align="left">整行向右缩进</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>K</kbd> + <kbd>Backspace</kbd></td>
<td align="left">从光标处开始删除代码至行首</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>K</kbd> + <kbd>K</kbd></td>
<td align="left">从光标处开始删除代码至行尾</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd></td>
<td align="left">删除整行</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>/</kbd></td>
<td align="left">注释单行</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>/</kbd></td>
<td align="left">注释多行</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>K</kbd> + <kbd>U</kbd></td>
<td align="left">转换大写</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>K</kbd> + <kbd>L</kbd></td>
<td align="left">转换小写</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>T</kbd></td>
<td align="left">左右字母互换</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>.</kbd></td>
<td align="left">关闭当前html标签</td>
</tr>
<tr>
<td align="left"><kbd>F6</kbd></td>
<td align="left">单词检测拼写</td>
</tr>
</tbody></table>
<h1 id="查找类"><a href="#查找类" class="headerlink" title="查找类"></a>查找类</h1><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>F</kbd></td>
<td align="left">打开底部搜索框，查找关键字</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></td>
<td align="left">在文件夹内的所有文件范围内查找</td>
</tr>
<tr>
<td align="left"><kbd>F3</kbd></td>
<td align="left">查找下一个</td>
</tr>
<tr>
<td align="left"><kbd>Shift</kbd> + <kbd>F3</kbd></td>
<td align="left">查找上一个</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>E</kbd></td>
<td align="left">缓存用于查找的内容，方便之后的查找</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>E</kbd></td>
<td align="left">缓存用于替换的内容，方便之后的替换</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>H</kbd></td>
<td align="left">打开底部搜索框，替换关键字</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd></td>
<td align="left">依次替换关键字</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>P</kbd></td>
<td align="left">跳转到文件或定位到其他位置：<li>输入当前项目中的文件名跳转到文件</li><li>输入 @ 和关键字定位到文件中的函数</li><li>输入 ： 和数字，定位到文件中的行号</li><li>输入 # 和关键字定位到变量名、属性名</li></td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>G</kbd></td>
<td align="left">定位到文件中的行号</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>R</kbd></td>
<td align="left">定位到文件中的函数</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>:</kbd></td>
<td align="left">定位到文件中的变量名、属性名</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>F2</kbd></td>
<td align="left">设置/取消定位标记</td>
</tr>
<tr>
<td align="left"><kbd>F2</kbd></td>
<td align="left">跳转到下一个定位标记处</td>
</tr>
<tr>
<td align="left"><kbd>Shift</kbd> + <kbd>F2</kbd></td>
<td align="left">跳转到上一个定位标记处</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>F2</kbd></td>
<td align="left">清楚所有定位标记</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>M</kbd></td>
<td align="left">定位到匹配的括号</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd></td>
<td align="left">打开命令框。<br>举例：输入关键字，调用Sublime Text或插件的功能，如使用package安装插件</td>
</tr>
<tr>
<td align="left"><kbd>Esc</kbd></td>
<td align="left">退出光标多行选择，退出搜索框，命令框等</td>
</tr>
</tbody></table>
<h1 id="显示类"><a href="#显示类" class="headerlink" title="显示类"></a>显示类</h1><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>N</kbd></td>
<td align="left">新建程序窗口</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>N</kbd></td>
<td align="left">新建标签页</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>W</kbd></td>
<td align="left">关闭当前标签页</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>W</kbd></td>
<td align="left">关闭程序窗口</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd></td>
<td align="left">打开最后一次关闭的标签页</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Tab</kbd></td>
<td align="left">循环遍历标签页，功能同<kbd>Ctrl</kbd> + <kbd>PageDown</kbd></td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Tab</kbd></td>
<td align="left">反向循环遍历标签页，功能同 <kbd>Ctrl</kbd> + <kbd>PageUp</kbd></td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>PageDown</kbd></td>
<td align="left">循环遍历标签页，功能同 <kbd>Ctrl</kbd> + <kbd>Tab</kbd></td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>PageUp</kbd></td>
<td align="left">反向循环遍历标签页，功能同 <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Tab</kbd></td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Num</kbd></td>
<td align="left">聚焦于标签页Num</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Num</kbd></td>
<td align="left">聚焦于窗格Num</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Num</kbd></td>
<td align="left">将标签页移动至窗格Num</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>1</kbd></td>
<td align="left">窗口分屏，恢复默认1屏</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>2</kbd></td>
<td align="left">左右分屏-2列</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>3</kbd></td>
<td align="left">左右分屏-3列</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>4</kbd></td>
<td align="left">左右分屏-4列</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>5</kbd></td>
<td align="left">等分4屏</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>8</kbd></td>
<td align="left">垂直分屏-2行</td>
</tr>
<tr>
<td align="left"><kbd>Alt</kbd> + <kbd>Shift</kbd> + <kbd>9</kbd></td>
<td align="left">垂直分屏-3行</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>K</kbd> + <kbd>B</kbd></td>
<td align="left">开启/关闭侧边栏</td>
</tr>
<tr>
<td align="left"><kbd>Ctrl</kbd> + <kbd>`</kbd></td>
<td align="left">显示控制台</td>
</tr>
<tr>
<td align="left"><kbd>F11</kbd></td>
<td align="left">全屏模式</td>
</tr>
<tr>
<td align="left"><kbd>Shift</kbd> + <kbd>F11</kbd></td>
<td align="left">沉浸模式</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Sublime Text 3</category>
      </categories>
      <tags>
        <tag>Sublime Text 3</tag>
      </tags>
  </entry>
  <entry>
    <title>一些小众但很有意思的网站：程序员版</title>
    <url>/2019/02/16/ck33bhg82000qw4mk06q0esf5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>面向程序员的一些精美的小众网站：学习资源或是一些趁手的工具。</p>
<ul>
<li><a href="https://www.mydevice.io/" target="_blank" rel="noopener">mydevice.io</a></li>
<li><a href="https://regexr.com/" target="_blank" rel="noopener">RegExr</a></li>
<li><a href="https://flexboxfroggy.com/" target="_blank" rel="noopener">Flexbox Froggy</a></li>
<li><a href="https://cssgridgarden.com/" target="_blank" rel="noopener">Grid Garden</a></li>
<li><a href="https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/" target="_blank" rel="noopener">Flexbox Playground</a></li>
<li><a href="https://visualgo.net/en" target="_blank" rel="noopener">VisuAlgo</a></li>
</ul>
<p>持续收录中…</p>
<a id="more"></a>

<h1 id="mydevice-io"><a href="#mydevice-io" class="headerlink" title="mydevice.io"></a><a href="https://www.mydevice.io/" target="_blank" rel="noopener">mydevice.io</a></h1><p>获取设备分辨率和像素信息、浏览器兼容性</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/minority-websites-for-programmer/my-device.jpg" alt="mydevice"></p>
<h1 id="RegExr"><a href="#RegExr" class="headerlink" title="RegExr"></a><a href="https://regexr.com/" target="_blank" rel="noopener">RegExr</a></h1><p>学习、构建、测试正则表达式</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/minority-websites-for-programmer/regexr.png" alt="RegExr"></p>
<h1 id="Flexbox-Froggy"><a href="#Flexbox-Froggy" class="headerlink" title="Flexbox Froggy"></a><a href="https://flexboxfroggy.com/" target="_blank" rel="noopener">Flexbox Froggy</a></h1><p>通过游戏的方式学习CSS Flex布局</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/minority-websites-for-programmer/flexbox-froggy.jpg" alt="Flexbox Froggy"></p>
<h1 id="Grid-Garden"><a href="#Grid-Garden" class="headerlink" title="Grid Garden"></a><a href="https://cssgridgarden.com/" target="_blank" rel="noopener">Grid Garden</a></h1><p>通过游戏的方式学习CSS Grid布局</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/minority-websites-for-programmer/grid-garden.jpg" alt="Grid Garden"></p>
<h1 id="Flexbox-Playground"><a href="#Flexbox-Playground" class="headerlink" title="Flexbox Playground"></a><a href="https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/" target="_blank" rel="noopener">Flexbox Playground</a></h1><p>CSS Flex 布局练习，原文见：<a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties#toc-flexbox-container-properties" target="_blank" rel="noopener">A Visual Guide to CSS3 Flexbox Properties</a></p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/minority-websites-for-programmer/flexbox-playground.jpg" alt="Flexbox Playground"></p>
<h1 id="VisuAlgo"><a href="#VisuAlgo" class="headerlink" title="VisuAlgo"></a><a href="https://visualgo.net/en" target="_blank" rel="noopener">VisuAlgo</a></h1><p>可视化演示数据结构和算法</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/minority-websites-for-programmer/visualgo.jpg" alt="VisuAlgo"></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>未分类</tag>
      </tags>
  </entry>
  <entry>
    <title>Web页面中引用iconfont图标</title>
    <url>/2019/01/29/ck33bhg8a000yw4mkemhk0vy4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://yearito-1256884783.image.myqcloud.com/thumbnails/iconfont.png!thumbnail" alt="iconfont 首页" title="iconfont 首页"></p>
<p>阿里妈妈出品的 iconfont 是一个矢量图标管理、交流平台，支持矢量图、位图等格式下载，并提供便捷的前端项目植入引用方法，是当前Web开发中主流的icon解决方案。</p>
<a id="more"></a>

<p>想要在前端页面中引入图标，一个最原始的做法，就是下载图标的PNG图片格式，然后通过标签引入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/icon.png"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>当页面中图标数量比较少时，采用这种简单的做法并无不当，但如果项目中图标数量较多，并且应用需求比较复杂的时候，就会暴漏出以下问题：</p>
<ul>
<li>PNG图片是位图，缩放页面会导致图片模糊。</li>
<li>引入后不方便自由调整图标的大小和颜色，需要在外部编辑修改图片之后重新引入。</li>
</ul>
<p>一个绝佳的解决方案就是 <a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>，在这个平台上不仅可以找到各种精美小图标，还能方便的集成矢量图标到前端项目中。</p>
<p>官方给出了三种 <a href="https://www.iconfont.cn/help/detail?helptype=code" target="_blank" rel="noopener">Web端引入方案</a>：</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>这种方案的思路是将图标变成字体引入，然后通过HTML转义字符来引用图标，特点是：</p>
<ul>
<li>可以按照调整字体样式的方法来调整图标样式，如设置 <code>font-size</code> 调整尺寸大小，设置 <code>color</code> 属性修改图标颜色等。</li>
<li>因为是字体，所以不支持多色，这里所说的多色，意思是同一个图标里不允许出现多种颜色。</li>
</ul>
<p>使用方案如下：</p>
<p>每个图标项目都会自动生成一段唯一的Unicode引用代码（CSS样式），在前端项目中将这段代码引入：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'iconfont'</span>;  <span class="comment">/* project id 964156 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_964156_pr9i6o2kmf.eot'</span>);</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_964156_pr9i6o2kmf.eot?#iefix'</span>) <span class="built_in">format</span>(<span class="string">'embedded-opentype'</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_964156_pr9i6o2kmf.woff2'</span>) <span class="built_in">format</span>(<span class="string">'woff2'</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_964156_pr9i6o2kmf.woff'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_964156_pr9i6o2kmf.ttf'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_964156_pr9i6o2kmf.svg#iconfont'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.iconfont</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>:<span class="string">"iconfont"</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">16px</span>;<span class="attribute">font-style</span>:normal;</span><br><span class="line">  <span class="attribute">-webkit-font-smoothing</span>: antialiased;</span><br><span class="line">  <span class="attribute">-webkit-text-stroke-width</span>: <span class="number">0.2px</span>;</span><br><span class="line">  <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用 <code>@font-face</code> 定义了一种叫做 <code>iconfont</code> 的字体（名字可以自定义），这个 <code>iconfont</code> 字体就跟微软雅黑、宋体等是一种性质了，为了搞定兼容性问题确保字体引入成功，设置了多种常见格式的字体源引入链接，如 eot、woff、ttf等。</p>
<p>后面这段CSS代码的意思就是，所有类名为 <code>iconfont</code> 的元素字体都强制使用 <code>iconfont</code> 字体族，这样就为HTML转义符转义为“图标”（本质还是字体，只不过长成了图标的样子）做好了铺垫。</p>
<p>然后在需要插入图标的位置插入如下HTML代码，其中的转义符可以在 iconfont 的各个图标中找到：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"iconfont"</span>&gt;</span>&amp;#x33;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://yearito-1256884783.image.myqcloud.com/using-iconfont-in-webpage/unicode.png" alt="Unicode 引用" title="Unicode 引用"></p>
<h1 id="Font-Class"><a href="#Font-Class" class="headerlink" title="Font Class"></a>Font Class</h1><p>从Unicode的引用方案中我们可以看到，HTML转义符都是形如 <code>&amp;#***;</code> 的样式，书写不直观，语义不明确，使用和维护都有诸多不便。于是 iconfont 推出一套语义化的方案，这就是 Font Class。使用方案如下：</p>
<p>直接在前端项目的HTML头部外链iconfont的图标项目CSS文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"//at.alicdn.com/t/font_964156_pr9i6o2kmf.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在需要插入图表的位置插入如下HTML代码，其中的元素类名 <code>icon-xxx</code> 可以在iconfont的各个图标中获取：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"iconfont icon-full-screen"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://yearito-1256884783.image.myqcloud.com/using-iconfont-in-webpage/font-class.png" alt="Font Class 引用" title="Font Class 引用"></p>
<p>这个方案只是给Unicode重新包装了一翻，变得更方便使用了而已，为什么这么说呢？我们直接在浏览器中打开这个CSS文件来看看名堂（有删减）：</p>
<figure class="highlight css"><figcaption><span>http://at.alicdn.com/t/font_964156_pr9i6o2kmf.css</span></figcaption><table><tr><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;<span class="attribute">font-family</span>: <span class="string">"iconfont"</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_964156_pr9i6o2kmf.eot?t=1548690018080'</span>); <span class="comment">/* IE9 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_964156_pr9i6o2kmf.eot?t=1548690018080#iefix'</span>) <span class="built_in">format</span>(<span class="string">'embedded-opentype'</span>), <span class="comment">/* IE6-IE8 */</span></span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'data:application/x-font-woff2;charset=utf-8;base64,d09GMgAB......TB+KD1yrAQAAAA=='</span>) <span class="built_in">format</span>(<span class="string">'woff2'</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_964156_pr9i6o2kmf.woff?t=1548690018080'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),</span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_964156_pr9i6o2kmf.ttf?t=1548690018080'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>), <span class="comment">/* chrome, firefox, opera, Safari, Android, iOS 4.2+ */</span></span><br><span class="line">  <span class="built_in">url</span>(<span class="string">'//at.alicdn.com/t/font_964156_pr9i6o2kmf.svg?t=1548690018080#iconfont'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>); <span class="comment">/* iOS 4.1- */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.iconfont</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"iconfont"</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  <span class="attribute">-webkit-font-smoothing</span>: antialiased;</span><br><span class="line">  <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-full-screen</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e616"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-love</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e71e"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-pause</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e615"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-playing</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e643"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-ring</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e601"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-help</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e609"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉似曾相识，这里将 Unicode 的引入代码统一封装了起来，只不过下面多了一些伪类的样式，其意义就是让你可以通过语义化的方法引用图标，比如你给一个图标元素添加了 <code>icon-full-screen</code> 类名，这里 <code>.icon-full-screen:before</code> 伪类样式就会帮你在元素中嵌入图标字符。</p>
<p>该方案的本质依旧和Unicode是一致的：图标变字体，再通过HTML转义符插入。所以Unicode方案中提到的无法使用多色图标的问题，这里依然未得到解决。</p>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>这是一个可以支持多色图标的方案，官方的说法是：</p>
<blockquote>
<p>这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。</p>
</blockquote>
<div class="note ">
            <p>没错，这是你没有体验过的船新版本，但是我才不会告诉你，iconfont平台自己用的是unicode和font-class的方案，可能是为了兼容 ie6 ?</p>
          </div>

<p>这回不是引入CSS文件而是引入JS脚本了，其思路是通过JavaScript把图标项目中所有的SVG矢量图形统一添加到页面中并隐藏起来，后续用到图标的地方直接切图引用即可。</p>
<p>使用方案如下：</p>
<p>首先在前端项目的HTML文件中引入iconfont脚本：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//at.alicdn.com/t/font_964156_pr9i6o2kmf.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在样式文件中添加如下通用样式规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.icon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>; <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: -<span class="number">0.15em</span>;</span><br><span class="line">  <span class="attribute">fill</span>: currentColor;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在需要插入图标的位置插入如下HTML代码，其中的图标名 <code>#icon-xxx</code> 可以在iconfont的各个图标中获取：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#icon-xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://yearito-1256884783.image.myqcloud.com/using-iconfont-in-webpage/symbol.png" alt="Symbol 引用" title="Symbol 引用"></p>
<p>通过这种方案引入 iconfont 图标，会在页面中发现多了一个SVG标签：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/using-iconfont-in-webpage/svg-palette.png" alt="SVG 图标仓库" title="SVG 图标仓库"></p>
<p>你可以把这个SVG标签理解为一个图标仓库，或者说一个原始画板，其样式被刻意隐藏了起来：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">width</span>: 0<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 0<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure>

<p>查看页面中引入的图标元素，会发现 <code>use</code> 标签里多了相应图标的SVG矢量元素：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/using-iconfont-in-webpage/quote-icon.png" alt="图标元素" title="图标元素"></p>
<p>可以理解为这里从图标仓库中引用了一份SVG代码以显示图标，这就是Symbol方案的关键所在了。</p>
<div class="note ">
            <p>有兴趣的可以在 <a href="https://ant.design/components/icon/" target="_blank" rel="noopener">AntDesign Icon</a> 页面F12控制台中查看元素构成。</p>
          </div>



<div class="reference-linking">参考链接</div>

<ul>
<li><a href="https://www.iconfont.cn/help/detail?helptype=code" target="_blank" rel="noopener">iconfont 帮助中心 | 代码应用</a></li>
</ul>
]]></content>
      <categories>
        <category>iconfont</category>
      </categories>
      <tags>
        <tag>iconfont</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的Git命令及其应用场景</title>
    <url>/2019/01/16/frequently-used-git-command/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/01/16/frequently-used-git-command/room-setting.jpg" alt="题图"></p>
<p>Git GUI 客户端和众多IDE都已经通过图形化的操作方式集成了Git的常用功能，但作为程序员，还是应该通过命令行解决问题，知其然，知其所以然。</p>
<p>本文基于简单应用场景储备Git命令，持续更新…</p>
<a id="more"></a>

<h1 id="提交增删行数统计"><a href="#提交增删行数统计" class="headerlink" title="提交增删行数统计"></a>提交增删行数统计</h1><p>统计提交中代码行的增删情况，可以体现最近每次提交的工作量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the version number</span><br><span class="line"></span><br><span class="line"> Rakefile |    2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary <span class="built_in">test</span> code</span><br><span class="line"></span><br><span class="line"> lib/simplegit.rb |    5 -----</span><br><span class="line"> 1 file changed, 5 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"> README           |    6 ++++++</span><br><span class="line"> Rakefile         |   23 +++++++++++++++++++++++</span><br><span class="line"> lib/simplegit.rb |   25 +++++++++++++++++++++++++</span><br><span class="line"> 3 files changed, 54 insertions(+)</span><br></pre></td></tr></table></figure>

<h1 id="图形化查看分支提交日志"><a href="#图形化查看分支提交日志" class="headerlink" title="图形化查看分支提交日志"></a>图形化查看分支提交日志</h1><p>命令行版的 <code>gitk</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --all --graph --decorate</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*   9269419 (HEAD -&gt; master, origin/master) add hide_toc schema</span><br><span class="line">|\</span><br><span class="line">| *   fe1180f modify css rules</span><br><span class="line">| * | c69b90a shorten post end tag</span><br><span class="line">* | | 18c37d5 add css rules</span><br><span class="line">| |/</span><br><span class="line">|/|</span><br><span class="line">* | e935db4 update about page</span><br><span class="line">* | 8f76861 update post</span><br><span class="line">|/</span><br><span class="line">* bbe785c (release/master) update posts</span><br><span class="line">*   a52bc0c fixed bug</span><br><span class="line">|\</span><br><span class="line">| * 20b0c15 adjust footer layout</span><br><span class="line">* | 3e583ca add annotation</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客系列：部署上线篇</title>
    <url>/2018/11/20/hexo-deploy-to-VPS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍了在将 Hexo 博客部署上线过程中将会遇到的一系列问题。</p>
<p>第一章主要介绍了将 Hexo 部署到 VPS 的方案，使得在本地推送更新后自动同步线上内容，部署过程主要分为三步走，首先从本地推送更新到远程仓库，然后触发 Git Hooks 将静态资源部署到 Web 根目录，最后启动 Nginx 服务器。</p>
<p>第二章主要介绍了如何分析页面加载性能瓶颈，并提供了通过CDN和代码压缩合并等方法来优化页面加载速度的方案。</p>
<p>第三章主要介绍了如何将站点提交到各大搜索引擎收录，并讨论了SEO相关话题。</p>
<p>后续章节则零散的介绍了为站点添加404页面和RSS链接。</p>
<a id="more"></a>

<p>部署个人博客主要有两种方案，一种是托管到Github Pages上，一种是部署到自己的VPS上。</p>
<p>对于Github Pages，优势在于完全免费，部署方便快捷，适用于新手，但一个Github账号只能用来部署一个个人站点。另外，Github服务器在国外，理论上从国内加载站点资源会有延迟，并且由于GFW的存在有时候可能访问不到站点。当然，可以通过Coding Pages来实现国内外双线部署来解决这个问题，详情可以参考网上相关教程。</p>
<p>对于VPS，需要独立购买域名和服务器，还需要熟悉Linux系统的基本操作，但同时也提供了更广的自由度。本篇主要介绍使用VPS部署博客的方案。</p>
<h1 id="VPS自动部署"><a href="#VPS自动部署" class="headerlink" title="VPS自动部署"></a>VPS自动部署</h1><div class="note info">
            <p>本章节参考 <a href="https://blog.yizhilee.com/post/deploy-hexo-to-vps/" target="_blank" rel="noopener">荔枝 | 通过 Git Hooks 自动部署 Hexo 到 VPS</a></p>
          </div>

<p>使用VPS部署博客的主要思路分为三步：</p>
<ul>
<li><code>hexo deploy</code> 的时候通过git把 public 目录下的博客静态资源推送到远程仓库中</li>
<li>推送更新时触发 Git Hooks 将静态资源克隆到网站根目录下</li>
<li>使用 nginx 作为Web服务器提供对博客的 HTTP 访问</li>
</ul>
<p>本文基于腾讯云 Ubuntu 16.04实现自动部署。</p>
<h2 id="远程仓库推送"><a href="#远程仓库推送" class="headerlink" title="远程仓库推送"></a>远程仓库推送</h2><p>在推送静态资源之前需要做些准备工作，包括基于公钥的ssh通信以及VPS用户和权限管理。</p>
<div class="note info">
            <p>在进行下一步操作之前请先确认本地已经安装了 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a> 和 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a>。</p>
          </div>

<p>为什么要实现基于公钥的ssh通信？</p>
<p>通常可以使用密码和公钥两种方式登陆VPS，如果在VPS上为某用户添加了授权公钥，则之后每次以该用户身份登陆或者获取授权就无须再重复输入密码了。<strong>Hexo的git自动部署插件不支持使用密码验证授权</strong>，所以要实现基于公钥的ssh通信。</p>
<p>如果尚未生成ssh公钥对，执行如下命令生成新的公钥对：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>无须设置公钥密码，否则每次通过公钥登陆的时候都要输入密码。</p>
          </div>

<p>如果是Windows操作系统，此时会在 C:\Users\Username\.ssh\ 目录下生成密钥文件 id_rsa 和公钥文件 id_rsa.pub。</p>
<p>腾讯云的默认登陆用户名为ubuntu，在设置根用户密码之前无法切换为根用户，可以通过 <code>sudo passwd</code> 命令来设置根用户密码，然后通过 <code>su</code> 命令切换到根用户身份。</p>
<p>以管理员权限执行如下命令新建用户并设置密码：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo adduser git</span><br><span class="line"><span class="variable">$ </span>sudo passwd git</span><br></pre></td></tr></table></figure>

<p>这一步虽然不是必须的，但一般情况下都会单独新建git用户专用于git代码同步，并将远程仓库放在git用户目录下。</p>
<p>为方便后续以git用户身份获取管理员权限来新建目录，此处为其添加管理员操作权限：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo gpasswd -a git sudo</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>该命令指的是将 git 用户添加到 sudo用户组中，也就使得git用户有了sudo用户组的操作权限。</p>
          </div>

<p>在本地Git Bash中执行如下命令将ssh公钥上传到VPS：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ ssh-<span class="keyword">copy</span>-<span class="built_in">id</span> git@yearito.cn</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>该命令会自动把默认ssh公钥id_rsa.pub中的内容拷贝到git用户目录下的 .ssh/authorized_keys文件中。</p>
          </div>

<p>此时在本地cmd中用git用户登陆VPS将会直接成功登陆而无须输入密码：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh git<span class="variable">@yearito</span>.cn</span><br></pre></td></tr></table></figure>

<p>在git用户目录下执行如下命令创建远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir blog.yearito.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog.yearito.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init --bare</span></span><br></pre></td></tr></table></figure>

<p>在本地站点根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>在本地站点配置文件中添加git远程仓库信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@yearito.cn:~/blog.yearito.git</span><br></pre></td></tr></table></figure>

<p>此时在站点根目录下执行 <code>hexo deploy</code> 命令，如果最后一行出现如下提示：</p>
<blockquote>
<p><span style="color: green">INFO</span>  Deploy done: git</p>
</blockquote>
<p>则说明已经实现本地和VPS远程仓库之间的资源同步了。</p>
<div class="note info">
            <p>需要注意的是，同步的仅是 public 目录下的静态资源文件，而非整个项目目录。</p>
          </div>

<p>如果在部署过程中出现如下提示：</p>
<blockquote>
<p>The file will have its original line endings in your working directory. <br><br>warning: LF will be replaced by CRLF in tags/Hexo/index.html.</p>
</blockquote>
<p>这是由 Windows 操作系统和 Linux 操作系统中行尾换行符不一致所引起的，可以通过执行 <code>git config core.autocrlf false</code> 来关闭告警。</p>
<h2 id="Git-Hooks-拷贝资源"><a href="#Git-Hooks-拷贝资源" class="headerlink" title="Git Hooks 拷贝资源"></a>Git Hooks 拷贝资源</h2><p>此时VPS上的远程仓库只是一个裸仓库，无法用于搭建站点服务器。所以我们需要在推送更新的同时触发Git Hooks钩子，来从远程仓库中克隆出完整的博客资源放到Web服务器根目录下。</p>
<p>首先创建Web根目录：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">mkdir</span> /<span class="built_in">var</span>/www/blog.yearito -p</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>其中，-p 参数表示若所要建立目录的上层目录目前尚未建立，则一并建立上层目录。</p>
          </div>

<p>然后改变Web根目录的所有者和所有工作组，以使git用户拥有对该目录的操作权限：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">$ sudo chown g<span class="symbol">it:gi</span><span class="built_in">t</span> -R /<span class="built_in">var</span>/www/blog.yearito</span><br></pre></td></tr></table></figure>

<p>打开到远程仓库中的hooks目录下，默认该目录下是没有post-receive钩子文件的，直接通过 <code>vim post-receive</code> 新建该文件并添加以下代码：</p>
<figure class="highlight bash"><figcaption><span>~/blog.yearito.git/hooks/post-receive</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"post-receive hook is running..."</span></span><br><span class="line"></span><br><span class="line">GIT_REPO=/home/git/blog.yearito.git</span><br><span class="line">TMP_GIT_CLONE=/tmp/blog.yearito</span><br><span class="line">PUBLIC_WWW=/var/www/blog.yearito</span><br><span class="line"></span><br><span class="line">rm -rf <span class="variable">$TMP_GIT_CLONE</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="variable">$GIT_REPO</span> <span class="variable">$TMP_GIT_CLONE</span></span><br><span class="line">rm -rf <span class="variable">$&#123;PUBLIC_WWW&#125;</span>/*</span><br><span class="line">cp -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span>/* <span class="variable">$&#123;PUBLIC_WWW&#125;</span>/</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>为什么不直接将裸仓库克隆到Web根目录下呢？我之前也一直被这个问题困扰，感觉先克隆到 tmp 目录再拷贝到Web根目录是多此一举。后来我觉得可能是出于项目安全的考虑，在执行cp命令的时候，.git作为隐藏目录不会被拷贝到Web根目录下，也就避免了将整个仓库历史暴漏在Web服务中。</p>
          </div>

<p>输入 <code>:wq</code> 保存并退出，此时可以看到 post-receive 文件只有读写权限，没有执行权限：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/post-receive-before.png" alt="修改 post-receive 权限前" title="修改 post-receive 权限前"></p>
<p>执行以下代码：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">chmod +x post-<span class="keyword">receive</span></span><br></pre></td></tr></table></figure>

<p>执行后可以看到 post-receive 已获得执行权限：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/post-receive-after.png" alt="修改 post-receive 权限后" title="修改 post-receive 权限后"></p>
<p>然后在本地站点目录下执行 <code>hexo deploy -g</code>，如果出现我们之前设定好的 <code>remote: post-receive hook is running...</code> 提示，且没有其他权限错误，则说明钩子正确执行了，从远程仓库拷贝资源成功，此时打开 /var/www/blog.yearito/ 目录可以看到完整的博客静态资源文件。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/auto-deploy-success.png" alt="Git Hooks 拷贝资源成功" title="Git Hooks 拷贝资源成功"></p>
<h2 id="配置Nginx服务器"><a href="#配置Nginx服务器" class="headerlink" title="配置Nginx服务器"></a>配置Nginx服务器</h2><p>将静态资源部署到Web服务器根目录后，接下来要做就是通过配置Nginx来启动Web服务。</p>
<p>切换到根用户并安装Nginx：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ apt-<span class="builtin-name">get</span> install nginx</span><br></pre></td></tr></table></figure>

<p>成功安装后可以通过 <code>nginx -v</code> 查看Nginx版本信息，以及可以通过 <code>service nginx status</code> 或者 <code>systemctl status nginx</code> 命令来查看Nginx运行状态。</p>
<p>修改nginx配置文件内容，启动80端口的HTTP服务到Web根目录，此处提供最简配置作为参考，读者可以在此基础上自定义：</p>
<figure class="highlight nginx"><figcaption><span>/etc/nginx/nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> www-data;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">  <span class="attribute">worker_connections</span>  <span class="number">768</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">include</span>  mime.types;</span><br><span class="line">  <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">root</span> /var/www/blog.yearito;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时通过 <code>nginx -s reload</code> 重新加载配置文件，如果此前Nginx服务未启动，则直接执行 <code>nginx</code> 命令即可。</p>
<p>执行以下命令设置Nginx开机自动启动：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ systemctl <span class="builtin-name">enable</span> nginx</span><br></pre></td></tr></table></figure>

<p>此外提供一些其他的Nginx语法命令：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">nginx -s stop <span class="string">//</span>强制关闭</span><br><span class="line">nginx -s <span class="keyword">quit</span> <span class="string">//</span>完成当前服务后关闭</span><br><span class="line">nginx -s <span class="keyword">reload</span> <span class="string">//</span>重新加载配置文件</span><br></pre></td></tr></table></figure>

<p>在浏览器中输入VPS域名，即可打开个人博客站点，至此实现了在本地推送更新后自动同步部署线上站点内容的功能。</p>
<h1 id="页面加载性能"><a href="#页面加载性能" class="headerlink" title="页面加载性能"></a>页面加载性能</h1><p>博客上线后，需要关注页面的加载速度。<a href="https://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="noopener">Google PageSpeed Insights</a> 可用于帮助分析网页加载速度瓶颈，该网站将会针对指定域名进行在线测试，并提供一份详细的页面加载分析报告，报告中还会根据页面资源加载情况给出合理的优化建议及预期优化效果，因此用户可以有的放矢的进行性能优化专项整改。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/pagespeed-insights.png" alt="Google PageSpeed Insights" title="Google Pagespeed Insights"></p>
<p>虽然可以从报告中了解到站点的加载性能瓶颈，但是，报告中仅是提供优化建议，具体的落实还须自己实施。本章节主要介绍CDN加速和代码合并压缩两种比较常见的优化方案。</p>
<h2 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h2><p>在控制台的Network Tab页中可以查看到页面加载瀑布流。在此需要勾选 Disable cache 以避免缓存干扰分析。另外，在所有静态资源中，对加载速度影响较大且存在大幅优化空间的主要还是JS脚本，所以我们先拿它开刀。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/before-optimize.png" alt="页面加载瀑布流" title="页面加载瀑布流"></p>
<p>首先理解一下底部信息栏中的这行文字：</p>
<blockquote>
<p><span style="font-family: Arial">21 / 50 requests | 518 KB / 818KB transferred | Finish: 8.44 s | <span style="color: blue">DOMContentLoaded: 4.36 s</span> | <span style="color: red">Load: 6.80 s</span></span></p>
</blockquote>
<p>主要包括以下几条信息：</p>
<ul>
<li>加载页面总共发起了50次请求，下载了818 KB资源，其中JS脚本资源共计518 KB，占据了21次请求。</li>
<li>在 4.36 s 时DOM树渲染完毕（蓝线），此时已经可以看到正常的页面，由于JS脚本会阻塞DOM解析，所以这段时间是包含了JS脚本的下载与执行过程的。</li>
<li>在 6.80 s 时所有资源加载完毕（红线），包括异步的脚本和其他非阻塞的页面资源，如图片、CSS文件等。</li>
<li>在 8.44 s 时所有HTTP请求响应完毕，包括XHR请求。</li>
</ul>
<div class="note info">
            <p>关于 Finish / DOMContentLoaded / Load 的讨论请参见 <a href="https://stackoverflow.com/questions/31729240/how-to-analyzing-page-speed-in-chrome-dev-tools" target="_blank" rel="noopener">How to analyzing Page Speed in Chrome Dev tools</a> 和 <a href="https://segmentfault.com/q/1010000011840948/a-1020000011947156" target="_blank" rel="noopener">chrome devtools 中 network 一栏中的 Finish 时间代表着什么</a>，两者说法不一致，我倾向于认同后者的观点。</p>
          </div>

<p>分析以上页面加载瀑布流可知，DOM树的解析渲染主要是被从VPS本地下载 jquery、velocity、fancybox 等脚本所滞后，所以对症下药，我们可以改为从开源公共CDN加载脚本。</p>
<p>对于在站点中用到的三方插件，在主题配置文件中为其添加CDN加载源：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">jquery:</span> <span class="string">//cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">fancybox:</span> <span class="string">https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js</span></span><br><span class="line">  <span class="attr">fancybox_css:</span> <span class="string">https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">velocity:</span> <span class="string">https://cdn.jsdelivr.net/npm/velocity-animate@1.2.1/velocity.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">velocity_ui:</span> <span class="string">//cdn.jsdelivr.net/npm/velocity-animate@1.2.1/velocity.ui.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">fontawesome:</span> <span class="string">//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">algolia_instant_js:</span> <span class="string">https://cdn.jsdelivr.net/npm/instantsearch.js@2.4.1/dist/instantsearch.js</span></span><br><span class="line">  <span class="attr">algolia_instant_css:</span> <span class="string">https://cdn.jsdelivr.net/npm/instantsearch.js@2.4.1/dist/instantsearch.min.css</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">pace:</span> <span class="string">//cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js</span></span><br><span class="line">  <span class="attr">pace_css:</span> <span class="string">//cdn.jsdelivr.net/npm/pace-js@1.0.2/themes/blue/pace-theme-minimal.css</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">pangu:</span> <span class="string">//cdn.jsdelivr.net/npm/pangu@3.3.0/dist/browser/pangu.min.js</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">valine:</span> <span class="string">https://cdn.jsdelivr.net/npm/valine@1.3.3/dist/Valine.min.js</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>主题配置文件中给出的CDN链接示例的版本可能已经落后很久了，请查找并使用最新版的插件CDN链接。</p>
          </div>

<p>比较常用的开源项目CDN服务商主要有unpkg、bootcdn、 cdnjs、jsdelivr 和 cloudflare，用户可以自行在浏览器中检测资源下载速度后做取舍。本站中主要使用 jsdelivr 提供的CDN加速服务。</p>
<p>使用CDN加速后页面加载瀑布流如下：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/after-optimize.png" alt="CDN加载三方插件后的页面加载瀑布流" title="CDN加载三方插件后的页面加载瀑布流"></p>
<p>DOM树的渲染完成时间缩减到了654 ms，<strong>也就是说刷新页面后654 ms后就可以看到页面内容了，相比优化前的4.36 s 有了极大的提升</strong>。</p>
<p>如果开启了Live2D看板娘，一样可以通过将脚本来源改为CDN来完成性能优化：</p>
<figure class="highlight diff"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  # Live2D</span><br><span class="line">  ## https://github.com/EYHN/hexo-helper-live2d</span><br><span class="line">  live2d:</span><br><span class="line">    enable: true</span><br><span class="line">    pluginRootPath: live2dw/ # Root path of plugin to be on the site (Relative)</span><br><span class="line">    pluginJsPath: lib/ # JavaScript path related to plugin's root (Relative)</span><br><span class="line">    pluginModelPath: assets/ # Relative model path related to plugin's root (Relative)</span><br><span class="line"><span class="deletion">-   scriptFrom: local # Default</span></span><br><span class="line"><span class="addition">+   scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">    tagMode: true # Whether only to replace live2d tag instead of inject to all pages</span><br><span class="line">    log: false # Whether to show logs in console</span><br><span class="line">    model:</span><br><span class="line">      use: live2d-widget-model-shizuku  # 萌系少女</span><br><span class="line">    display:</span><br><span class="line">      position: left</span><br><span class="line">      width: 100</span><br><span class="line">      height: 180</span><br><span class="line">    mobile:</span><br><span class="line">      show: false</span><br><span class="line">    react:</span><br><span class="line">      opacityDefault: 0.7 # 默认透明度</span><br></pre></td></tr></table></figure>

<p>另外，我们注意到，处理 hotjar 的脚本共计耗时 5 s，那么该脚本是否影响到了页面加载性能呢？事实上没有，在HTML结构树中可以找到 hotjar 的脚本引入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://static.hotjar.com/c/hotjar-1061283.js?sv=6"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>async</code> 属性意味着脚本将以异步形式加载，不会阻塞DOM树的解析和渲染。也就是说该脚本只使得 Load 的完成时间滞后，但没有影响到 DOMContentLoaded 的时间节点。</p>
<p>关于 Hotjar 是否会使得站点加载变慢，Hotjar 官方给出否定的回应，理由如下：</p>
<ul>
<li>通过异步的方式加载脚本</li>
<li>脚本使用CDN加速</li>
<li>脚本合理利用了浏览器缓存</li>
</ul>
<div class="note info">
            <p>更多详情请参考 <a href="https://help.hotjar.com/hc/en-us/articles/115009335727-Will-Hotjar-Slow-Down-My-Site-" target="_blank" rel="noopener">Will Hotjar Slow Down My Site?</a></p>
          </div>

<p>除了可以使用CDN加速三方插件外，还可以使用CDN域名加速来加速站点静态资源，包括HTML文件、CSS样式、字体文件等，具体操作方案参考VPS服务商说明文档。</p>
<p>CDN域名加速也有几个坑点：</p>
<ul>
<li>CDN缓存会导致更新站点后访问到的仍是旧版内容，需要等待缓存刷新后才能看到更新。</li>
<li>加速后就不能通过该域名建立ssh连接了，此时 <code>hexo deploy</code> 将会出现端口连接超时，可以将远程仓库地址改为真实IP地址来确保推送成功。</li>
</ul>
<h2 id="代码合并压缩"><a href="#代码合并压缩" class="headerlink" title="代码合并压缩"></a>代码合并压缩</h2><p>另一种优化页面加载速度的方案是通过删除注释和空格、将长变量名改为短变量名等方式压缩代码体积，从而缩短资源下载时间。</p>
<p><a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="noopener">hexo-all-minifier</a> 插件通过集成下列插件提供一站式的资源压缩服务：</p>
<ul>
<li><a href="https://github.com/hexojs/hexo-html-minifier" target="_blank" rel="noopener">hexo-html-minifier</a>: 基于 <a href="https://github.com/kangax/html-minifier" target="_blank" rel="noopener">HTMLMinifier</a> 提供 HTML 压缩服务。</li>
<li><a href="https://github.com/hexojs/hexo-clean-css" target="_blank" rel="noopener">hexo-clean-css</a>: 基于 <a href="https://github.com/jakubpawlowicz/clean-css" target="_blank" rel="noopener">clean-css</a> 提供 CSS 压缩服务。</li>
<li><a href="https://github.com/hexojs/hexo-uglify" target="_blank" rel="noopener">hexo-uglify</a>: 基于 <a href="http://lisperator.net/uglifyjs/" target="_blank" rel="noopener">UglifyJS</a> 提供 JS 压缩服务。</li>
<li><a href="https://github.com/vseventer/hexo-imagemin" target="_blank" rel="noopener">hexo-imagemin</a>: 基于 <a href="https://github.com/imagemin/imagemin" target="_blank" rel="noopener">imagemin</a> 提供图片压缩服务。</li>
</ul>
<p>此外，该插件还可以把多个JS脚本拼接打包到一个文件中来减少HTTP请求次数，从而减少页面加载时间。</p>
<p>该方案从理论上来讲是有效且可行的，但是和一般的大型软件项目不同，博客项目中的主要资源是Markdown文件解析后的HTML文件，其核心是文本内容而非逻辑代码，压缩空间极其有限，在实际应用过程中效果并不明显，所以本站也就没有应用该插件功能。</p>
<h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><h2 id="提交网址"><a href="#提交网址" class="headerlink" title="提交网址"></a>提交网址</h2><div class="note info">
            <p>本节参考 <a href="https://juejin.im/post/590b451a0ce46300588c43a0" target="_blank" rel="noopener">hexo高阶教程：教你怎么让你的hexo博客在搜索引擎中排第一</a></p>
          </div>

<p>在搜索引擎中输入 site:yearito.cn，会发现暂时还搜不到自己的站点：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/google-search-result.png" alt="谷歌搜索结果" title="谷歌搜索结果"></p>
<p>想要搜到自己的站点，首先要将个人网站提交给搜索引擎收录。针对不同的搜索引擎需要分别提交网址，但提交的步骤是大同小异的：</p>
<p><strong>第一步：提交网站域名</strong></p>
<p>注意需要区分输入 http 与 https。</p>
<p><strong>第二步：验证网站所有权</strong></p>
<p>一般都包括以下三种验证方法，其本质都是通过一段字符串验证码来验证用户的网站所有权，三种方法任选其一：</p>
<ul>
<li>HTML文件验证：将给定的HTML文件上传到站点根目录下（验证码包含在HTML文件中）</li>
<li>HTML元标签验证：在站点首页中添加给定的 <code>meta</code> 标签（验证码包含在 <code>meta</code> 标签属性中）</li>
<li>CNAME验证：添加一个CNAME域名解析记录到指定站点（验证码包含在二级域名中）</li>
</ul>
<p>Next主题中已经内置集成了各大搜索引擎的HTML元标签验证方案，用户只需获取验证码填写到主题配置文件中并重新打包部署即可完成身份验证。</p>
<p><strong>第三步：推送或者提交 sitemap</strong></p>
<p>sitemap，又称站点地图，通常是一个xml格式的文件，最早由谷歌提出，现已被多数引擎所支持。里面包含了站点内的页面列表，帮助搜索引擎理解网站内容的组织架构。</p>
<p>在Hexo中可以通过 <a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="noopener">hexo-generator-sitemap</a> 和 <a href="https://github.com/coneycode/hexo-generator-baidu-sitemap" target="_blank" rel="noopener">hexo-generator-baidu-sitemap</a> 两个插件帮助生成通用站点地图和百度专用站点地图文件。</p>
<p>在站点根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-sitemap --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br><span class="line">$ npm install hexo-generator-baidu-sitemap --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure>

<p>之后在执行 <code>hexo generate</code> 打包后即可在 public 目录下找到 sitemap.xml 和 baidusitemap.xml 两个文件，将该文件提交到搜索引擎站长后台即可帮助搜索引擎分析收录站点内容，各个搜索引擎收录效率不同，可能需要耐心等上几天。</p>
<h3 id="谷歌"><a href="#谷歌" class="headerlink" title="谷歌"></a>谷歌</h3><p>在 <a href="https://search.google.com/search-console" target="_blank" rel="noopener">Google Search Console</a> 中提交站点域名，此时会提供几种验证网站所有权的方法，展开 <strong>其他验证方法</strong> 中的 <strong>HTML 标记</strong>，然后将 <code>meta</code> 标签的 <code>content</code> 属性值复制到主题配置文件中：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/google-verify-site.png" alt="Google 选择验证方式" title="Google 选择验证方式"></p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Google Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.google.com/webmasters/</span></span><br><span class="line"><span class="attr">google_site_verification:</span> <span class="string">cEGDN99xe2gtAy97He-NH4ihW3Y4GrGQl_xTxp7p3sg</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>hexo generate deploy</code> 重新部署站点，此时网站中就已经自动包含了用于验证身份的 <code>meta</code> 标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"google-site-verification"</span> <span class="attr">content</span>=<span class="string">"u9qDJxSM-SphoS5GXBhunqp1UXBY5H4FT6J1V2LxXqI"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>回到 Search Console 页面点击验证按钮，验证成功后将进入控制台，点击左侧 <strong>站点地图</strong> 菜单，在域名后输入 sitemap.xml 并提交，即可添加新的站点地图。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/google-add-sitemap.png" alt="添加站点地图" title="添加站点地图"></p>
<p>在新版的 Search Console 中只能添加站点地图，却没有删除站点地图的接口，后来在 <a href="https://www.dear.today/731.html" target="_blank" rel="noopener">Google Search Console 删除站点地图方法</a> 一文中发现了解决办法：需要在 <a href="www.google.com/webmasters/tools/sitemap-list">旧版 Search Console</a> 中才能删除。</p>
<h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><p>在 <a href="https://ziyuan.baidu.com/site" target="_blank" rel="noopener">百度搜索资源平台</a> 中提交站点域名，勾选站点属性，最后一步中同样会要求验证网站的所有权身份，选择 <strong>HTML标签验证</strong>，然后将 <code>meta</code> 标签的 <code>content</code> 属性值复制到主题配置文件中：：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/baidu-verify-site.png" alt="Baidu 选择验证方式" title="Baidu 选择验证方式"></p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#  Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://ziyuan.baidu.com/site/</span></span><br><span class="line"><span class="attr">baidu_site_verification:</span> <span class="string">UHED80Nn65</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>hexo generate deploy</code> 重新部署站点，此时网站中就已经自动包含了用于验证身份的 <code>meta</code> 标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"baidu-site-verification"</span> <span class="attr">content</span>=<span class="string">"UHED80Nn65"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>回到百度站长管理平台点击完成验证按钮，验证成功后将进入控制台，在左侧 <strong>数据引入</strong> 菜单下点击 <strong>链接提交</strong>，在此可以看到除了sitemap之外还提供了多种推送站点内容的方案：</p>
<ul>
<li>主动推送：通过API接口推送站点内容，实时性较高</li>
<li>自动推送：在网页内添加JS脚本，每当页面被访问的时候会将页面url推送给百度，比较被动</li>
<li>sitemap：填写站点地图文件地址，百度会周期性的抓取其中的内容进行分析收录，收录效率比较低</li>
<li>手动提交：手动填写链接地址进行收录</li>
</ul>
<p>本站采用主动推送和自动推送相结合的形式推送站点内容。</p>
<h4 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h4><p>Hexo中可以借助 <a href="https://github.com/huiwang/hexo-baidu-url-submit" target="_blank" rel="noopener">hexo-baidu-url-submit</a> 插件快捷实现主动推送，在根目录下安装相关依赖：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-baidu-<span class="keyword">url</span>-submit <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>在站点配置文件中添加以下代码：</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 百度主动推送</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">100</span>  <span class="comment"># 提交最新的一个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">yearito.cn</span>  <span class="comment"># 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">xxxxx</span>  <span class="comment"># 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span>  <span class="comment"># 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure>

<p>然后在站点配置文件中修改部署策略：</p>
<figure class="highlight diff"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  # Deployment</span><br><span class="line">  ## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line"><span class="deletion">- deploy:</span></span><br><span class="line"><span class="deletion">-   type: git</span></span><br><span class="line"><span class="deletion">-   repo: git@yearito.cn:~/blog.yearito.git</span></span><br><span class="line"><span class="addition">+ deploy:</span></span><br><span class="line"><span class="addition">+ - type: git</span></span><br><span class="line"><span class="addition">+   repo: git@yearito.cn:~/blog.yearito.git</span></span><br><span class="line"><span class="addition">+ - type: baidu_url_submitter # 百度</span></span><br></pre></td></tr></table></figure>

<p>每次部署的时候将会自动推送网站内容到百度。</p>
<h4 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h4><p>Next主题中内置了一键开启百度自动推送的选项：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span></span><br><span class="line"><span class="attr">baidu_push:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>开启后将会自动在页面中添加如下脚本用于百度推送：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> bp = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> curProtocol = <span class="built_in">window</span>.location.protocol.split(<span class="string">':'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">if</span> (curProtocol === <span class="string">'https'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">    bp.src = <span class="string">'https://zz.bdstatic.com/linksubmit/push.js'</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="actionscript">  <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">    bp.src = <span class="string">'http://push.zhanzhang.baidu.com/push.js'</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];</span></span><br><span class="line">  s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每次访问站点页面都会通过以上脚本推送本页url到百度。</p>
<h3 id="必应"><a href="#必应" class="headerlink" title="必应"></a>必应</h3><p>在 <a href="https://www.bing.com/toolbox/webmaster" target="_blank" rel="noopener">必应网站管理员</a> 中提交站点域名，此时可以同时输入 sitemap 文件链接，然后同样会进入网站所有权验证页面，在选择二中复制 <code>meta</code> 标签的 <code>content</code> 属性值到主题配置文件中：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/bing-verify-site.png" alt="Bing 选择验证方式" title="Bing 选择验证方式"></p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bing Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.bing.com/webmaster/</span></span><br><span class="line"><span class="attr">bing_site_verification:</span> <span class="string">538CCB61234CB4A0B1A71C4581705DCD</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>hexo generate deploy</code> 重新部署站点，此时网站中就已经自动包含了用于验证身份的 <code>meta</code> 标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"msvalidate.01"</span> <span class="attr">content</span>=<span class="string">"538CCB61234CB4A0B1A71C4581705DCD"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>回到网站管理员页面点击验证按钮，验证成功后将进入控制台，可以在左侧导航菜单中点击 <strong>仪表板</strong> -&gt; <strong>配置我的网站</strong> -&gt; ** Sitemaps** 查看已提交的站点地图文件的解析抓取情况。</p>
<h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><div class="note info">
            <p>本节参考 <a href="https://blog.paddings.cn/2016/08/16/blog/Hexo-NexT-SEO/" target="_blank" rel="noopener">Hexo NexT 主题SEO优化指南</a> 及<br><a href="https://sofree.cc/meta-keywords/" target="_blank" rel="noopener">SEO優化：不要使用Meta Keywords關鍵字</a></p>
          </div>

<p>SEO（Search Engine Optimization）意指搜索引擎优化，可以帮助提高目标网站在搜索引擎中的排名，使得在别人搜索相关内容的时候更容易脱颖而出被人所发现，以提高个人站点的存在价值。</p>
<p>在Hexo中可以从以下几个方面进行简单的优化：</p>
<ul>
<li><p><strong>开启Next主题内置seo优化</strong></p>
<p>在主题配置文件中设置 <code>seo: true</code>，将会自动部署Next内置的seo优化方案，比如在 themes\next\layout\_partials\footer.swig 为链接添加 <code>rel=&quot;external nofollow&quot;</code> 属性。</p>
</li>
<li><p><strong>修改文章url地址格式</strong></p>
<p>默认的文章url地址为 <code>http://yoursite.com/:year/:month/:day/:title/</code>，这种url格式层级太多，并且如果文章标题是中文的话可能会发生转义而出现一堆乱码，不利于搜索引擎的爬取分析，因此建议在站点配置中修改 <code>permalink</code> 的格式来简化页面url，并尽量采用英文命名Markdown文件。</p>
</li>
</ul>
<p>在一些SEO优化的教程中会提到通过为页面添加 keywords 来影响搜索结果排名，事实上，在早期搜索引擎技术发展尚未成熟的时候，这样的做法确实有效，但当人们发现了这个规律后，就开始添加甚至无关的keywords来影响搜索结果排名，这一标签的滥用极大的降低了搜索引擎的准确度。随后，各大搜索引擎纷纷宣布不再将keywords作为搜索排名权重因子。</p>
<p>如Google就在2009年发布声明：<a href="https://webmasters.googleblog.com/2009/09/google-does-not-use-keywords-meta-tag.html" target="_blank" rel="noopener">Google does not use the keywords meta tag in web ranking</a>。声明中表示Google不会将keywords标签作为网页排名的依据，未来也不会改变这一政策。部分原文摘录如下：</p>
<blockquote>
<p>Our web search (the well-known search at Google.com that hundreds of millions of people use each day) disregards keyword metatags completely. They simply don’t have any effect in our search ranking at present.</p>
</blockquote>
<blockquote>
<p>Google has ignored the keywords meta tag for years and currently we see no need to change that policy.</p>
</blockquote>
<p>而Bing则表示过多的keywords会被作为垃圾讯号，可能导致你的网站被归类为垃圾网站，详见<a href="https://searchengineland.com/the-meta-keywords-tag-lives-at-bing-why-only-spammers-should-use-it-96874" target="_blank" rel="noopener">The Meta Keywords Tag Lives At Bing &amp; Why Only Spammers Should Use It</a>。</p>
<p>说起keywords，不得不提到另外一个与之相关的meta标签description。那么description是否有助于提升搜索排名呢？Google仍然给出了否定的答案：</p>
<blockquote>
<p>Even though we sometimes use the description meta tag for the snippets we show, we still don’t use the description meta tag in our ranking.</p>
</blockquote>
<p>虽然description不影响搜索排名，但搜索引擎通常会将description作为快照显示在搜索结果页面作为内容补充，因此合适的description还是有助于吸引读者的目光增加网站的点击率的。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/search-snapshot.png" alt="搜索结果快照" title="搜索结果快照"></p>
<p>如果页面上没有description元标签的话，搜索引擎可能会从页面中自动抓取部分内容作为页面描述，至于说抓取质量可就没法保证了。</p>
<p>默认情况下，Next会使用 tags 作为页面 keywords，使用文章前两百个字符作为description。如果文章页面内含有 <code>&lt;!-- more --&gt;</code> 内容分隔符，则会使用分隔符之前的正文 description。用户也可以在Front-Matter中添加 keywords 和 description属性来手动指定页面meta标签内容。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/keywords-description.png" alt="keywords &amp; description" title="keywords &amp; description"></p>
<p>越是容易被人为操控的SEO影响因子，影响力就会越来越低，所以：</p>
<blockquote class="blockquote-center"><p>最好的SEO优化是做好内容，最好的加薪办法是做好工作。</p>
</blockquote>

<h1 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h1><p>Nginx默认的404页面有些简陋，这里有两种自定义404页面的方案。</p>
<p><strong>第一种是仍沿用Hexo主题的页面框架，基于 page 布局搭建404页面。</strong></p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/404pages.png" alt="基于主题布局的404页面" title="基于主题布局的404页面"></p>
<p>在 source 目录下新建 404.md 文件，添加如下内容：</p>
<figure class="highlight html"><figcaption><span>source\404.md</span></figcaption><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:center; font-size: 36px"</span>&gt;</span></span><br><span class="line">  404 页面未找到</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">onclick</span>=<span class="string">"window.history.back()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-angle-double-left fa-fw fa-lg"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    返回</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  &#123;% btn /, 首页, home fa-fw fa-lg %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用户可以在此基础上自定义修改显示内容。</p>
<p><strong>第二种是完全抛弃掉Hexo的框架，搭建一个纯粹的自定义 404 HTML 页面。</strong></p>
<p>在 source 目录下新建 404.html 文件，自行编写页面结构与样式。你也可以直接在网上搜索404页面模板并下载使用，一般都不会太复杂，一个HTML文件就能搞定。例如 <a href="https://freefrontend.com/html-css-404-page-templates/" target="_blank" rel="noopener">28 HTML 404 Page Templates</a> 中就提供了很多精美的动态404页面。</p>
<p>此时打包的时候Hexo仍会渲染该文件，添加上复杂的主题框架与功能，用户可以修改站点配置文件以跳过渲染该文件：</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="number">404.</span><span class="string">html</span></span><br></pre></td></tr></table></figure>

<p>这样以来Hexo在打包的时候就只是将该文件复制到 public 目录下，而不做任何处理了。</p>
<p>以上仅仅是搭建起了404页面，至于如何在服务器返回404响应时重定向到该页面，还要依赖于Nginx的配置规则。修改VPS上的Nginx配置文件，添加一行404页面重定向规则：</p>
<figure class="highlight diff"><figcaption><span>/etc/nginx/nginx.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">  http &#123;</span><br><span class="line">    include  mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">      listen  80;</span><br><span class="line">      root /var/www/blog.yearito;</span><br><span class="line"><span class="addition">+     error_page 404 /404.html;      </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>修改后执行 <code>nginx -s reload</code> 重新加载配置文件即可生效。</p>
<h1 id="RSS链接"><a href="#RSS链接" class="headerlink" title="RSS链接"></a>RSS链接</h1><p>什么是RSS，RSS有什么用？第一次在别人的博客搭建教程中了解到这个概念的时候，同样的问题也困扰着我。通过订阅网站RSS可以第一时间发现站点内容的更新，而不用自己跑到站点去刷新，这是一个轮询到通知的转变。</p>
<div class="note ">
            <p>虽然大致知道它的用途，但还是理解不够深刻，读者可以参考 <a href="http://www.ruanyifeng.com/blog/2006/01/rss.html" target="_blank" rel="noopener">如何使用RSS | 阮一峰</a> 来帮助理解这一概念。</p>
          </div>

<p>在站点根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>然后站点概览中就会自动出现feed链接：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-deploy-to-VPS/rss-feed.png" alt="站点 feed 链接" title="站点 feed 链接"></p>
<p>在主题配置文件中不需要设置rss的值，置空即可，如果设置为 <code>true</code> 反而会导致如下报错：</p>
<blockquote>
<p><a href="https://github.com/iissnan/theme-next-docs/issues/99" target="_blank" rel="noopener">Unhandled rejection TypeError: path.substring is not a function</a></p>
</blockquote>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本文介绍了在站点部署上线过程中将会遇到的各种技术问题，包括部署到VPS中的三步实现方案，优化页面加载性能的方法等。至此，Hexo搭建个人博客系列的最后一篇文章也已经完成，本站历经2个月的修修改改后也终于上线与大家见面了。如果你喜欢本站，可以在我的 <a href="http://github.com/Coodool/hexo-blog-yearito" target="_blank" rel="noopener">Github仓库</a> 上Fork或者Star。关于本系列文章如果有什么疑问与指正，也欢迎私信或者评论。</p>
<div class="reference-linking">参考链接</div>

<ul>
<li><a href="https://blog.yizhilee.com/post/deploy-hexo-to-vps/" target="_blank" rel="noopener">荔枝 | 通过 Git Hooks 自动部署 Hexo 到 VPS</a></li>
<li><a href="https://stackoverflow.com/questions/31729240/how-to-analyzing-page-speed-in-chrome-dev-tools" target="_blank" rel="noopener">How to analyzing Page Speed in Chrome Dev tools</a></li>
<li><a href="https://segmentfault.com/q/1010000011840948/a-1020000011947156" target="_blank" rel="noopener">chrome devtools 中 network 一栏中的 Finish 时间代表着什么</a></li>
<li><a href="https://help.hotjar.com/hc/en-us/articles/115009335727-Will-Hotjar-Slow-Down-My-Site-" target="_blank" rel="noopener">Will Hotjar Slow Down My Site?</a></li>
<li><a href="https://juejin.im/post/590b451a0ce46300588c43a0" target="_blank" rel="noopener">hexo高阶教程：教你怎么让你的hexo博客在搜索引擎中排第一</a></li>
<li><a href="https://blog.paddings.cn/2016/08/16/blog/Hexo-NexT-SEO/" target="_blank" rel="noopener">Hexo NexT 主题SEO优化指南</a></li>
<li><a href="https://sofree.cc/meta-keywords/" target="_blank" rel="noopener">SEO優化：不要使用Meta Keywords關鍵字</a></li>
<li><a href="https://webmasters.googleblog.com/2009/09/google-does-not-use-keywords-meta-tag.html" target="_blank" rel="noopener">Google does not use the keywords meta tag in web ranking</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2006/01/rss.html" target="_blank" rel="noopener">如何使用RSS | 阮一峰</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客系列：进阶设置篇</title>
    <url>/2018/11/20/hexo-advanced-settings/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇文章介绍了如何为 Hexo 博客集成更多强大的功能。</p>
<p>第一章介绍了在站点中集成基于三方插件的数据统计服务，包括站点PV和PU统计、站点运行时间统计、文章PV统计、站点和文章字数统计等。</p>
<p>第二章介绍了针对于站点的个性化设置方案，包括添加搞怪的网页标题，添加站内搜索功能，添加热门文章排行榜页面，添加豆瓣阅读/电影/游戏等资料页面，添加在线聊天和即时反馈等功能。</p>
<p>第三章介绍了针对于文章页面的个性化设置方案，包括在文章末尾添加评论组件、评分组件、打赏入口、版权声明、推荐文章等，为文章中的图片添加点击灯箱效果，以及为文章设置访问密码。</p>
<a id="more"></a>

<h1 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h1><h2 id="站点访问量统计"><a href="#站点访问量统计" class="headerlink" title="站点访问量统计"></a>站点访问量统计</h2><p>该功能由 <a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a> 提供，效果如下图：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/busuanzi-site-footer.png" alt="站点访问统计" title="站点访问统计"></p>
<p>左侧数据表示独立访客数UV，右侧数据表示网站浏览量PV，访客数和浏览量的区别在于一个用户连续点击n篇文章，会记录n次浏览量，但只记录一次访客数。</p>
<div class="note ">
            <p>由于不蒜子是基于域名来进行统计计算的，所以通过 localhost:4000 端口访问的时候统计数据PV和UV都会异常的大，属于正常现象。</p>
          </div>

<p>在页脚布局模板文件首行添加如下代码：</p>
<figure class="highlight html"><figcaption><span>themes\next\layout\_partial\footer.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在主题配置文件中做出如下修改：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>   <span class="comment"># 访客数</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>   <span class="comment"># 访问量</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure>

<p>刷新浏览器即可生效。</p>
<p>高阶用法：通过修改代码来自定义统计文案，如果你想使用本站统计文案，需要对不蒜子的代码做出如下修改：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_third-party\analytics\busuanzi-counter.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &#123;% if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line"><span class="deletion">-   &lt;span class="site-uv" title="&#123;&#123; __('footer.total_visitors') &#125;&#125;"&gt;</span></span><br><span class="line"><span class="addition">+   &lt;span class="site-uv"&gt;</span></span><br><span class="line"><span class="addition">+     &#123;&#123; __('footer.total_visitors', '&lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;') &#125;&#125;</span></span><br><span class="line"><span class="deletion">-     &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="deletion">-     &lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;</span></span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_views %&#125;</span><br><span class="line"><span class="deletion">-   &lt;span class="site-pv" title="&#123;&#123; __('footer.total_views') &#125;&#125;"&gt;</span></span><br><span class="line"><span class="addition">+   &lt;span class="site-pv"&gt;</span></span><br><span class="line"><span class="addition">+     &#123;&#123; __('footer.total_views', '&lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;') &#125;&#125;</span></span><br><span class="line"><span class="deletion">-     &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="deletion">-     &lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;</span></span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>在自定义样式文件中添加如下样式：</p>
<figure class="highlight css"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//修改不蒜子数据颜色</span><br><span class="line"><span class="selector-class">.busuanzi-value</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#1890ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改统计表述文案：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\languages\zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="string">"历经 %s 次回眸才与你相遇"</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="string">"我的第 %s 位朋友，"</span></span><br></pre></td></tr></table></figure>

<h2 id="站点运行时间统计"><a href="#站点运行时间统计" class="headerlink" title="站点运行时间统计"></a>站点运行时间统计</h2><div class="note info">
            <p>本章节受 <a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">reuixiy | 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 #5.7</a> 启发，自行重构了代码逻辑。</p>
          </div>

<p>在站点底部显示站点已运行时间，效果如下：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/site-running-time.png" alt="站点运行时间" title="站点运行时间"></p>
<p>在主题自定义布局文件中添加以下代码：</p>
<figure class="highlight html"><figcaption><span>thems\next\layout\_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# 页脚站点运行时间统计 #&#125;</span><br><span class="line">&#123;% if theme.footer.ages.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> ages = moment.preciseDiff(moment(),moment(&#123;&#123; theme.footer.ages.birthday &#125;&#125;,<span class="string">"YYYYMMDD"</span>));</span></span><br><span class="line"><span class="javascript">      ages = ages.replace(<span class="regexp">/years?/</span>, <span class="string">"年"</span>);</span></span><br><span class="line"><span class="javascript">      ages = ages.replace(<span class="regexp">/months?/</span>, <span class="string">"月"</span>);</span></span><br><span class="line"><span class="javascript">      ages = ages.replace(<span class="regexp">/days?/</span>, <span class="string">"天"</span>);</span></span><br><span class="line"><span class="javascript">      ages = ages.replace(<span class="regexp">/hours?/</span>, <span class="string">"小时"</span>);</span></span><br><span class="line"><span class="javascript">      ages = ages.replace(<span class="regexp">/minutes?/</span>, <span class="string">"分"</span>);</span></span><br><span class="line"><span class="javascript">      ages = ages.replace(<span class="regexp">/seconds?/</span>, <span class="string">"秒"</span>);</span></span><br><span class="line"><span class="handlebars"><span class="xml">      ages = ages.replace(/\d+/g, '<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color:</span></span></span><span class="template-variable">&#123;&#123; theme.footer.ages.color &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>$&amp;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>');</span></span></span><br><span class="line"><span class="javascript">      div.innerHTML = <span class="string">`&#123;&#123; __('footer.age')&#125;&#125; <span class="subst">$&#123;ages&#125;</span>`</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//插入到copyright之后</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> copyright = <span class="built_in">document</span>.querySelector(<span class="string">".copyright"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">".footer-inner"</span>).insertBefore(div, copyright.nextSibling);</span></span><br><span class="line">    timer();</span><br><span class="line"><span class="actionscript">    setInterval(<span class="string">"timer()"</span>,<span class="number">1000</span>)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">      ...</span><br><span class="line">      &#123;% include '_third-party/exturl.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/bookmark.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/copy-code.swig' %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+     &#123;% include '_custom/custom.swig' %&#125;</span></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>修改主题配置文件：</p>
<figure class="highlight diff"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  footer:</span><br><span class="line">    ...</span><br><span class="line"><span class="addition">+   ages:</span></span><br><span class="line"><span class="addition">+     # site running time</span></span><br><span class="line"><span class="addition">+     enable: true</span></span><br><span class="line"><span class="addition">+     # birthday of your site</span></span><br><span class="line"><span class="addition">+     birthday: 20181001</span></span><br><span class="line"><span class="addition">+     # color of number</span></span><br><span class="line"><span class="addition">+     color: "#1890ff"</span></span><br></pre></td></tr></table></figure>

<p>然后补全对应文案：</p>
<figure class="highlight diff"><figcaption><span>themes\next\languages\zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  footer:</span><br><span class="line">    powered: "由 %s 强力驱动"</span><br><span class="line">    theme: 主题</span><br><span class="line"><span class="addition">+   age: 我已在此等候你</span></span><br><span class="line">    total_views: "历经 %s 次回眸才与你相遇"</span><br><span class="line">    total_visitors: "我的第 %s 位朋友，"</span><br></pre></td></tr></table></figure>

<p>刷新浏览器即可生效。</p>
<div class="note info">
            <p>日期统计计算功能由 <a href="https://momentjs.com/" target="_blank" rel="noopener">moment</a> 和 <a href="https://github.com/codebox/moment-precise-range" target="_blank" rel="noopener">moment-precise-range</a> 提供，也可用原生JS Date对象来实现。</p>
          </div>

<h2 id="文章访问量统计"><a href="#文章访问量统计" class="headerlink" title="文章访问量统计"></a>文章访问量统计</h2><div class="note info">
            <p>本章节参考 <a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">夏末 | 为NexT主题添加文章阅读量统计功能</a></p>
          </div>

<p>该功能基于 <a href="https://leancloud.cn" target="_blank" rel="noopener">LeanCloud</a> 提供后端数据服务，效果如下：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/post-pageviews.png" alt="文章访问量" title="文章访问量"></p>
<p>在LeanCloud上注册账号并创建应用，新建一个名为 Counter 的Class，ACL权限设置为 <strong>无限制</strong>：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/LeanCloud-Counter-class.png" alt="新建Counter类" title="新建Counter类"></p>
<div class="note info">
            <p>在LeanCloud中的Class可以理解为数据库中的数据表。Counter用于存储记录文章访问量，记录是以url作为唯一依据的，所以根据默认的permalink组成结构，如果你更改了文章的发布日期和标题中的任意一个，都会造成文章阅读数值的清零重计。</p>
          </div>

<p>在控制台的 <strong>设置</strong> -&gt; <strong>应用Key</strong> 中获取App ID和App Key填入到主题配置文件中：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="string">***&lt;app_id***</span></span><br><span class="line">  <span class="attr">app_key:</span> <span class="string">***&lt;app_key&gt;***</span></span><br><span class="line">  <span class="attr">security:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">betterPerformance:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>站点上线后可以在 <strong>设置</strong> -&gt; <strong>安全中心</strong> 中添加博客域名到 Web 安全域名中，设置后仅可在该域名下通过 JavaScript SDK 调用服务器资源，借以保护LeanCloud应用的数据安全。</p>
<p>如果想要自定义PV表述文案，可以修改文章布局模板中的相关代码：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &#123;# LeanCould PageView #&#125;</span><br><span class="line">    ...</span><br><span class="line">    &#123;% if theme.post_meta.item_text %&#125;</span><br><span class="line"><span class="deletion">-     &lt;span class="post-meta-item-text"&gt;&#123;&#123;__('post.views') + __('symbol.colon') &#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="addition">+     &lt;span class="post-meta-item-text"&gt;&#123;&#123;__('post.views')&#125;&#125; &lt;/span&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &lt;span class="leancloud-visitors-count"&gt;&lt;/span&gt;</span><br><span class="line"><span class="addition">+   &lt;span&gt;℃&lt;/span&gt;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>修改统计表述文案：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/languages/zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post:</span></span><br><span class="line">  <span class="attr">views:</span> <span class="string">热度</span></span><br></pre></td></tr></table></figure>

<p>刷新浏览器即可生效。</p>
<p>如果遇到如下报错，可能是你配置了 <code>security: true</code> 但又没有做好安全策略配置。</p>
<blockquote>
<p>阅读次数： Counter not initialized! See more at console err msg.</p>
</blockquote>
<p>有以下两种解决方案：</p>
<ul>
<li>下载安装 <a href="https://github.com/theme-next/hexo-leancloud-counter-security" target="_blank" rel="noopener">hexo-leancloud-counter-security</a> 插件</li>
<li>在主题配置中设置 <code>security: false</code></li>
</ul>
<p>个人推荐第二种，简单粗暴。</p>
<p>除了LeanCloud，不蒜子也能提供文章阅读次数统计，但是不蒜子的统计结果只会在文章页显示，而不会显示在首页列表中，相关讨论可以参见 <a href="https://github.com/iissnan/hexo-theme-next/issues/801" target="_blank" rel="noopener">阅读计数。对比LeanCloud和不蒜子</a></p>
<h2 id="站点及文章字数统计"><a href="#站点及文章字数统计" class="headerlink" title="站点及文章字数统计"></a>站点及文章字数统计</h2><p>该功能由 <a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">hexo-symbols-count-time</a> 提供，效果如下图：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/site-word-count.png" alt="站点字数统计" title="站点字数统计"></p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/post-word-count.png" alt="文章字数统计" title="文章字数统计"></p>
<p>在根目录下执行如下命令安装相关依赖</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-symbols-<span class="keyword">count</span>-<span class="built_in">time</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>启用该功能需要同时修改站点配置文件和主题配置文件。</p>
<p>将如下配置项添加到<strong>站点配置文件</strong>中，这些配置项主要用于控制每项统计信息是否显示。</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>   <span class="comment"># 统计单篇文章字数</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">false</span>   <span class="comment"># 取消估算单篇文章阅读时间</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>  <span class="comment"># 统计站点总字数</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">false</span>  <span class="comment"># 取消估算站点总阅读时间</span></span><br></pre></td></tr></table></figure>

<p>在<strong>主题配置文件</strong>中做如下修改，这些配置项主要用于控制统计信息的显示样式。</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">false</span>  <span class="comment"># 统计信息不换行显示</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>  <span class="comment"># 文章统计信息中是否显示“本文字数/阅读时长”等描述文字</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span>   <span class="comment"># 站点统计信息中是否显示“本文字数/阅读时长”等描述文字</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>  <span class="comment"># Average Word Length：平均字符长度</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>  <span class="comment"># Words Per Minute：阅读速度</span></span><br></pre></td></tr></table></figure>

<p>汉字的平均字符长度为1.5，如果在文章中使用纯中文进行写作（没有混杂英文），那么推荐设置 <code>awl: 2</code> 及 <code>wpm: 300</code>，但是如果文章中存在英文，建议设置 <code>awl: 4</code> 及 <code>wpm: 275</code>。</p>
<p>因为修改了站点配置文件，所以需要重新启动服务器才能生效。</p>
<h1 id="站点个性化设置"><a href="#站点个性化设置" class="headerlink" title="站点个性化设置"></a>站点个性化设置</h1><h2 id="搞怪网页标题"><a href="#搞怪网页标题" class="headerlink" title="搞怪网页标题"></a>搞怪网页标题</h2><div class="note info">
            <p>本章节参考 <a href="https://diygod.me/2153/" target="_blank" rel="noopener">DIYgod | 我藏好了哦</a></p>
          </div>

<p>离开和进入页面时动态修改Tab标签中的标题。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/title-trick.png" alt="搞怪网页标题" title="搞怪网页标题"></p>
<p>在主题自定义布局文件中添加以下代码：</p>
<figure class="highlight html"><figcaption><span>themes\next\layout\_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# 搞怪网页标题 #&#125;</span><br><span class="line">&#123;% if theme.title_trick.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> OriginTitile = <span class="built_in">document</span>.title;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> titleTime;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.title = <span class="string">'&#123;&#123; theme.title_trick.leave &#125;&#125;'</span> + OriginTitile;</span></span><br><span class="line">        clearTimeout(titleTime);</span><br><span class="line"><span class="actionscript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.title = <span class="string">'&#123;&#123; theme.title_trick.enter &#125;&#125;'</span> + OriginTitile;</span></span><br><span class="line"><span class="actionscript">        titleTime = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.title = OriginTitile;</span></span><br><span class="line">        &#125;, 2000);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">      ...</span><br><span class="line">      &#123;% include '_third-party/exturl.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/bookmark.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/copy-code.swig' %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+     &#123;% include '_custom/custom.swig' %&#125;</span></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中添加以下代码：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># a trick on website title</span></span><br><span class="line"><span class="attr">title_trick:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">leave:</span> <span class="string">"(つェ⊂)我藏好了哦~"</span></span><br><span class="line">  <span class="attr">enter:</span> <span class="string">"(*´∇｀*) 被你发现啦~"</span></span><br></pre></td></tr></table></figure>

<h2 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h2><p>该功能由 <a href="https://github.com/theme-next/hexo-generator-searchdb" target="_blank" rel="noopener">hexo-generator-searchdb</a> 提供，效果如下图：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/local-search.png" alt="站内搜索" title="站内搜索"></p>
<p>在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>在<strong>主题配置</strong>文件中修改相关字段：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span>  <span class="comment"># 每次输入改变都执行搜索</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">3</span>  <span class="comment"># 每篇文章显示的搜索结果数量</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>在<strong>站点配置</strong>文件中添加以下字段：</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span>  <span class="comment"># 指定搜索范围，可选 post | page | all</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span>  <span class="comment"># 指定页面内容形式，可选 html | raw (Markdown) | excerpt | more</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>在自定义样式文件中添加如下样式规则来增加搜索弹窗的页边距：</p>
<figure class="highlight css"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//增加搜索弹窗的页边距</span><br><span class="line"><span class="selector-class">.local-search-popup</span> <span class="selector-id">#local-search-result</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">25px</span> <span class="number">40px</span></span><br><span class="line">  height: <span class="built_in">calc</span>(100% - 95px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你同时在站点内启用了 wobblewindow 边缘摆动效果，则有可能会出现背景蒙版叠加在弹窗之前的问题，这种层级叠加异常的问题主要是因为 wobblewindow 中修改了弹窗父元素的 <code>position</code> 定位和 <code>z-index</code> 优先级，目前只能通过修改 localsearch 源码来修复该Bug：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_third-party\search\localsearch.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: path,</span><br><span class="line">    dataType: isXml ? "xml" : "json",</span><br><span class="line">    async: true,</span><br><span class="line">    success: function(res) &#123;</span><br><span class="line">      // get the contents from search data</span><br><span class="line">      isfetched = true;</span><br><span class="line"><span class="deletion">-     $('.popup').detach().appendTo('.header-inner');</span></span><br><span class="line"><span class="addition">+     $('.popup').detach().appendTo('body');</span></span><br><span class="line">      var datas = isXml ? $("entry", res).map(function() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          title: $("title", this).text(),</span><br><span class="line">          content: $("content",this).text(),</span><br><span class="line">          url: $("url" , this).text()</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;).get() : res;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<h2 id="热门文章排行榜"><a href="#热门文章排行榜" class="headerlink" title="热门文章排行榜"></a>热门文章排行榜</h2><div class="note info">
            <p>本章节部分思路参考 <a href="https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">nMask | Hexo搭建博客教程 #7.16</a>，自行进行了代码重构。</p>
          </div>

<p>添加文章阅读次数排行统计页面，效果如下图：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/top10.png" alt="热门文章排行榜" title="热门文章排行榜"></p>
<p>该功能同样是基于LeanCloud提供的后端服务支持。具体实现方案如下：</p>
<p>在站点目录下执行以下命令新建页面</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ hexo new<span class="built_in"> page </span>top</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中新增一项菜单入口：</p>
<figure class="highlight diff"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  menu:</span><br><span class="line">    home: / || home</span><br><span class="line"><span class="addition">+   top: /top/ || signal</span></span><br><span class="line">    tags: /tags/ || tags</span><br><span class="line">    categories: /categories/ || th</span><br><span class="line">    archives: /archives/ || archive</span><br><span class="line">    about: /about/ || user</span><br></pre></td></tr></table></figure>

<p>在语言包中新增菜单中文：</p>
<figure class="highlight diff"><figcaption><span>themes\next\languages\zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  menu:</span><br><span class="line">    home: 首页</span><br><span class="line">    archives: 归档</span><br><span class="line">    categories: 分类</span><br><span class="line">    tags: 标签</span><br><span class="line">    about: 关于</span><br><span class="line"><span class="addition">+   top: 排行榜</span></span><br></pre></td></tr></table></figure>

<p>然后在新增的排行榜页面内添加以下内容：</p>
<figure class="highlight html"><figcaption><span>source\top\index.md</span></figcaption><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 热门文章Top 10</span><br><span class="line">comments: false</span><br><span class="line">date: 2018-10-30 00:54:50</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"post-rank"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> APP_ID = ******;  <span class="comment">//输入个人LeanCloud账号AppID</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> APP_KEY = ******;  <span class="comment">//输入个人LeanCloud账号AppKey</span></span></span><br><span class="line">  AV.init(&#123;</span><br><span class="line">    appId: APP_ID,</span><br><span class="line">    appKey: APP_KEY</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(<span class="string">'Counter'</span>);<span class="comment">//表名</span></span></span><br><span class="line"><span class="actionscript">  query.descending(<span class="string">'time'</span>); <span class="comment">//结果按阅读次数降序排序</span></span></span><br><span class="line"><span class="actionscript">  query.limit(<span class="number">10</span>);  <span class="comment">//最终只返回10条结果</span></span></span><br><span class="line"><span class="javascript">  query.find().then( <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> content = response.reduce( <span class="function">(<span class="params">accum, &#123;attributes&#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      accum += `<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"prefix"</span>&gt;</span>热度 $&#123;attributes.time&#125; ℃<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;attributes.url&#125;"</span>&gt;</span>$&#123;attributes.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>`</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> accum;</span></span><br><span class="line"><span class="actionscript">    &#125;,<span class="string">""</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">"#post-rank"</span>).innerHTML = content;</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  .catch( <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(error);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#post-rank</span> &#123;</span></span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-id">#post-rank</span> <span class="selector-class">.prefix</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#ff4d4f</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>本是根据 <a href="https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">nMask | Hexo搭建博客教程 #7.16</a> 引入v0.6.1的脚本来实现该功能，结果发现出现如下Bug：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/LeanCloud-bug.png" alt="LeanCloud v0.6.1 Bug" title="LeanCloud v0.6.1 Bug"></p>
<p>后来根据 <a href="https://leancloud.cn/docs/leanstorage_guide-js.html" target="_blank" rel="noopener">LeanCloud | JavaScript SDK 安装指南</a> 引入v3.10.0的最新脚本，使用过程中虽然功能正常，但是控制台有报错信息:</p>
<blockquote>
<p> Uncaught TypeError: Cannot redefine property: applicationId</p>
</blockquote>
<h2 id="豆瓣阅读-电影-游戏"><a href="#豆瓣阅读-电影-游戏" class="headerlink" title="豆瓣阅读/电影/游戏"></a>豆瓣阅读/电影/游戏</h2><div class="note info">
            <p>本章节参考 <a href="https://github.com/mythsman/hexo-douban" target="_blank" rel="noopener">mythsman/hexo-douban README.md</a></p>
          </div>

<p>为站点添加豆瓣阅读/电影/游戏页面，效果如下：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/douban-movies.png" alt="豆瓣电影" title="豆瓣电影"></p>
<p>在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-douban <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>在站点配置文件中添加以下内容：</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">douban:</span></span><br><span class="line">  <span class="attr">user:</span>  <span class="comment"># 个人豆瓣ID</span></span><br><span class="line">  <span class="attr">builtin:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">book:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">'This is my book title'</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">'This is my book quote'</span></span><br><span class="line">  <span class="attr">movie:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">'This is my movie title'</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">'This is my movie quote'</span></span><br><span class="line">  <span class="attr">game:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">'This is my game title'</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">'This is my game quote'</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>user: 填写豆瓣ID。登陆豆瓣后点击<strong>个人主页</strong>，此时url中最后一段即是用户ID，一般情况下会是一段数字，如果设置了个人域名的话，则个人域名即为ID。</li>
<li>builtin: 是否将生成页面的功能嵌入 <code>hexo s</code> 和 <code>hexo g</code> 中。</li>
<li>timeout: 爬取数据的超时时间。</li>
</ul>
<p>如果只想生成某一个页面（比如只生成读书页面），把其他的配置项注释掉即可。</p>
<p>在主题配置文件中新增菜单入口：</p>
<figure class="highlight diff"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  menu:</span><br><span class="line">    home: / || home</span><br><span class="line">    tags: /tags/ || tags</span><br><span class="line">    categories: /categories/ || th</span><br><span class="line">    archives: /archives/ || tasks</span><br><span class="line"><span class="addition">+   books: /books/ || book  </span></span><br><span class="line"><span class="addition">+   movies: /movies/ || video-camera  </span></span><br><span class="line"><span class="addition">+   games: /games/ || gamepad</span></span><br></pre></td></tr></table></figure>

<p>在语言包中新增菜单中文：</p>
<figure class="highlight diff"><figcaption><span>themes\next\language\zh_CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  menu:</span><br><span class="line">    home: 首页</span><br><span class="line">    archives: 归档</span><br><span class="line">    categories: 分类</span><br><span class="line">    tags: 标签</span><br><span class="line"><span class="addition">+   movies: 电影</span></span><br><span class="line"><span class="addition">+   books: 读书</span></span><br><span class="line"><span class="addition">+   games: 游戏</span></span><br></pre></td></tr></table></figure>

<p>然后在根目录下执行以下命令生成豆瓣阅读/电影/游戏页面：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo douban</span><br></pre></td></tr></table></figure>

<p>可选参数:</p>
<ul>
<li>-b | --books: 只生成豆瓣读书页面</li>
<li>-m | --movies:  只生成豆瓣电影页面</li>
<li>-g | --games: 只生成豆瓣游戏页面</li>
</ul>
<p>执行命令后，插件会根据用户提供的ID爬取豆瓣中的数据信息并在 <code>public</code> 目录下生成对应的页面，当服务器启动或部署后会将页面显示在对应的菜单路由下。</p>
<p>如果在站点配置中设置了 <code>douban.builtin: false</code>，则每次豆瓣数据变动后需要手动执行一次 <code>hexo douban</code> 来刷新页面数据。如果设置了 <code>douban.builtin: true</code>，则每次执行 <code>hexo s</code> 和 <code>hexo g</code> 的时候将会自动同时执行 <code>hexo douban</code> 命令，但这样可能会增加打包编译的时间。建议如果豆瓣数据变动不频繁的情况下该项设为 <code>false</code> 即可。</p>
<p>通常大家都喜欢用 <code>hexo d</code> 来作为 <code>hexo deploy</code> 命令的简化，但是当安装了 <code>hexo douban</code> 之后， <code>hexo d</code> 就会有歧义而无法执行，因为 <code>hexo douban</code> 跟 <code>hexo deploy</code> 的Alias都是 <code>hexo d</code>。</p>
<h2 id="在线聊天"><a href="#在线聊天" class="headerlink" title="在线聊天"></a>在线聊天</h2><p>在线聊天算是一个比较成熟的SaaS商业应用了，业内产品如 <a href="https://www.tidiochat.com/" target="_blank" rel="noopener">Tidio</a>、 <a href="https://talkjs.com/" target="_blank" rel="noopener">TalkJS</a>、<a href="https://www.intercom.com/" target="_blank" rel="noopener">Intercom</a>、<a href="https://www.tawk.to/" target="_blank" rel="noopener">tawk.to</a> 等，使用体验都很好，交互界面也很干净别致。经过比较，本站最终选择了 Tidio：</p>
<ul>
<li>在个人博客这种业务场景中，几乎用不到它的收费功能，可以算是终身免费了。</li>
<li>Tidio提供了多种消息回复渠道，包括网页、桌面应用、iOS/Android APP（需要Google play服务支持）。</li>
<li>除了在线聊天，Tidio还可以在线发送邮件，以及关联接收Fackbook消息。</li>
<li>在几款产品的界面风格中，还是 Tidio 看起来更加优雅一些，深得我爱。</li>
</ul>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/Tidio.png" alt="Tidio 界面" title="Tidio 界面"></p>
<p>首先需要<a href="https://www.tidiochat.com/panel/login" target="_blank" rel="noopener">注册Tidio账号</a>，根据引导填写应用信息。进入控制台后，在 <strong>SETTINGS</strong> -&gt; <strong>Developer</strong> -&gt; <strong>Project data</strong> 中获取到Public Key：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/tidio-public-key.png" alt="Tidio Public Key" title="Tidio Public Key"></p>
<p>在主题配置文件下添加以下代码并补全Public Key：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Tidio online chat</span></span><br><span class="line"><span class="comment"># see: https://www.tidiochat.com</span></span><br><span class="line"><span class="attr">tidio:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">key:</span>  <span class="comment"># Public_Key</span></span><br></pre></td></tr></table></figure>

<p>在主题自定义布局文件中添加以下代码：</p>
<figure class="highlight html"><figcaption><span>themes\next\layout\_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# Tidio 在线联系功能 #&#125;</span><br><span class="line">&#123;% if theme.tidio.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//code.tidio.co/&#123;&#123; theme.tidio.key &#125;&#125;.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>为避免代码加载阻塞页面渲染，需要为脚本添加 <code>async</code> 属性使其异步加载。</p>
<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">      ...</span><br><span class="line">      &#123;% include '_third-party/exturl.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/bookmark.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/copy-code.swig' %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+     &#123;% include '_custom/custom.swig' %&#125;</span></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>刷新页面即可在右下角看到Tidio的会话标志了。接下来可以在Tidio控制台的 <strong>Channel</strong> -&gt; <strong>Live chat</strong> -&gt;  <strong>Appearance</strong> 中根据提示定制聊天对话框的主题外观和语言包：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/Tidio-appearance.png" alt="定制Tidio样式与功能" title="定制Tidio样式与功能"></p>
<h2 id="行为监测与反馈"><a href="#行为监测与反馈" class="headerlink" title="行为监测与反馈"></a>行为监测与反馈</h2><p><a href="https://www.hotjar.com/" target="_blank" rel="noopener">Hotjar</a> 是一款轻量级的监测分析工具，能够提供用户行为监测和用户反馈分析，相比Google Analysis而言，它没有复杂的监测指标与分析报表，更加的简单实用，并且为免费用户提供2000pv/day的数据采集服务，适用于小型网站或个人博客的监测分析。</p>
<p>Hotjar主要提供<strong>ANALYTICS</strong>和<strong>FEEDBACK</strong>两大类服务。</p>
<p>ANALYTICS主要用于用户交互行为的监测分析，属于客观分析，包括以下四项具体功能：</p>
<ul>
<li>Heatmaps: 通过热力图可视化用户的鼠标交互行为，帮助理解用户动机和需求。</li>
<li>Recording: 记录用户在站点的行为轨迹，了解应用的可用性以及用户遭遇的问题。</li>
<li>Funnels: 记录每个页面或者步骤的用户流失率。</li>
<li>Forms: 记录表单中每一项输入的完成率，完成时间以及用户流失率。</li>
</ul>
<p>FEEDBACK主要为用户提供反馈渠道，收集用户观点与数据，属于主观分析，包括以下四项具体功能：</p>
<ul>
<li>Incoming: 即时反馈，了解用户对页面的评价。</li>
<li>Polls: 投票反馈，获取某个问题的用户答案。</li>
<li>Surveys: 问卷调查，以问卷形式获取用户反馈。</li>
<li>Recruiters: 获取用户信息，招募用户用于用户调查或测试反馈。</li>
</ul>
<p>Hotjar通过以上八项具体而实用的功能为用户提供主客观相结合的监测分析服务，可以说它是所有轻量级分析工具中唯一做到了主客观相结合的，同时也是所有主客观分析工具中，做的最轻量的。</p>
<div class="note info">
            <p>更多功能介绍请参考 <a href="https://www.hotjar.com/tour" target="_blank" rel="noopener">Hotjar Features</a></p>
          </div>

<p>本站点中应用了Incoming即时反馈功能，读者可以通过该渠道评价页面或者提交勘误，点击悬挂在屏幕右侧的Feedback按钮弹出对话框，点击人物头像评价后将会跳转到如下界面：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/hotjar-feedback.png" alt="Hotjar Incoming Feedback" title="Hotjar Incoming Feedback"></p>
<p>你可以在此页面输入反馈内容，并通过点击左下角的按钮在当前页面上标识目标元素，之后 hotjar 会将反馈内容连同带有高亮标识的页面截图一起提交到后台：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/hotjar-feedback-screenshot.png" alt="Incoming Feedback with screenshot " title="Incoming Feedback with screenshot"></p>
<div class="note info">
            <p>更多关于 Incoming Feedback 的介绍请参考 <a href="https://www.hotjar.com/incoming-feedback" target="_blank" rel="noopener">Incoming Feedback by Hotjar</a></p>
          </div>

<p>在站点中集成Hotjar的各项功能，需要先 <a href="https://insights.hotjar.com/register" target="_blank" rel="noopener">注册 Hotjar 账号</a>，根据指引一步步填写站点信息，然后在控制面板首页中获取site ID：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/hotjar-site-id.png" alt="Hotjar site ID" title="Hotjar site ID"></p>
<p>在主题配置文件下添加以下代码并补全site ID：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hotjar</span></span><br><span class="line"><span class="comment"># see: https://www.hotjar.com/</span></span><br><span class="line"><span class="attr">hotjar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">siteID:</span>  <span class="comment"># site ID</span></span><br></pre></td></tr></table></figure>

<p>在主题自定义布局文件中添加以下代码：</p>
<figure class="highlight html"><figcaption><span>themes\next\layout\_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# hotjar 页面反馈 #&#125;</span><br><span class="line">&#123;% if theme.hotjar.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    (<span class="function"><span class="keyword">function</span><span class="params">(h,o,t,j,a,r)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">      h.hj=h.hj||<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;(h.hj.q=h.hj.q||[]).push(<span class="built_in">arguments</span>)&#125;;</span></span><br><span class="line"><span class="handlebars"><span class="xml">      h._hjSettings=&#123;hjid:</span><span class="template-variable">&#123;&#123; theme.hotjar.siteID &#125;&#125;</span><span class="xml">,hjsv:6&#125;;</span></span></span><br><span class="line"><span class="actionscript">      a=o.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">      r=o.createElement(<span class="string">'script'</span>);r.async=<span class="number">1</span>;</span></span><br><span class="line">      r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;</span><br><span class="line">      a.appendChild(r);</span><br><span class="line"><span class="javascript">    &#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>,<span class="string">'https://static.hotjar.com/c/hotjar-'</span>,<span class="string">'.js?sv='</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">      ...</span><br><span class="line">      &#123;% include '_third-party/exturl.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/bookmark.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/copy-code.swig' %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+     &#123;% include '_custom/custom.swig' %&#125;</span></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>如此即可将 Hotjar 嵌入到站内，接下来在 Hotjar 控制台菜单中点击 Incoming，然后根据引导一步步配置即时反馈服务即可：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/hotjar-setup-incoming.png" alt="配置 Incoming Feedback" title="配置 Incoming Feedback"></p>
<div class="note info">
            <p>如果你在本站内发现了错别字、病句、失效链接、代码缩进不一致，可以通过页面右侧的Feedback反馈。</p>
          </div>

<h1 id="文章页面个性化设置"><a href="#文章页面个性化设置" class="headerlink" title="文章页面个性化设置"></a>文章页面个性化设置</h1><h2 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h2><p>Next支持多款评论系统：</p>
<ul>
<li><a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a>：欧美UI风格，支持Tweet、Facebook等国外社交软件的三方登陆和一键分享。 <a href="https://blog.disqus.com/disqus-welcomes-the-spruce" target="_blank" rel="noopener">Demo</a></li>
<li><a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">gitment</a>：必须用github账号登陆才能评论，支持Markdown语法，与github issues页面风格一致 <a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Demo</a></li>
<li><a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a>：支持匿名评论，支持Markdown语法，界面简洁美观</li>
<li><a href="http://changyan.kuaizhan.com/" target="_blank" rel="noopener">畅言</a>：国产评论系统，可区分热评和最新评论，论坛贴吧风</li>
<li><a href="https://www.livere.com/" target="_blank" rel="noopener">来必力</a>：支持插入图片和GIF，支持国内外多种社交媒体的三方登陆 <a href="https://www.livere.com/city-demo" target="_blank" rel="noopener">Demo</a></li>
</ul>
<p>博客的评论系统不需要太过复杂的功能，我的要求是一定要轻量级，足够简洁美观，并且支持Markdown语法，因此我首选Valine和gitment，这两个评论系统都是由国内个人开发的，在此向开发者致敬。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/valine-comments.png" alt="Valine 评论系统" title="Valine 评论系统"></p>
<p>Next已经内置了Valine组件，在主题配置文件中开启评论功能即可，同时，由于Valine是基于Leancloud提供后端服务的，所以需要填写LeanCloud的App ID和App Key。</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span>  <span class="string">***&lt;app_id***</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">***&lt;app_key&gt;***</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span>  <span class="comment"># 收到新评论是否邮件通知</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span>  <span class="comment"># 是否开启验证码</span></span><br><span class="line">  <span class="attr">placeholder:</span>  <span class="comment"># 默认填充文字</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span>  <span class="comment"># 设置默认评论列表</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail</span>  <span class="comment"># 评论区头部表单</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span>  <span class="comment"># 每页评论数</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span>  <span class="comment"># 同时开启文章阅读次数统计</span></span><br></pre></td></tr></table></figure>

<p>Valine也附带了阅读统计功能，可以在Valine配置项中设置 <code>visitor: true</code> 开启该功能。为避免后端服务冲突，建议不要同时启用Valine的阅读统计功能和 <code>leancloud_visitors</code>。</p>
<div class="note info">
            <p>关于如何在收到评论时发送邮件提醒请参照 <a href="http://www.zhaojun.im/hexo-valine-admin/" target="_blank" rel="noopener">赵俊 | Hexo 优化 — Valine 扩展之邮件通知</a></p>
          </div>

<p>Next暂时不支持通过配置的方式隐藏文章标题下的评论数量，如要隐藏，可在自定义样式文件中添加如下代码：</p>
<figure class="highlight css"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//屏蔽标题下的评论数量</span><br><span class="line"><span class="selector-class">.post-comments-count</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你是轻度洁癖患者，想要隐藏评论区的浏览器和操作系统版本号以拥有更加干净的评论界面，可在自定义样式文件中添加如下代码：</p>
<figure class="highlight css"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//屏蔽评论组件的多余信息</span><br><span class="line"><span class="selector-id">#comments</span> <span class="selector-class">.vsys</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文末版权声明"><a href="#文末版权声明" class="headerlink" title="文末版权声明"></a>文末版权声明</h2><p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/post-copyright.png" alt="文章版权声明" title="文章版权声明"></p>
<p>在主题配置文件中开启文章底部的版权声明，版权声明默认使用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议，用户可以根据自身需要修改 <code>licence</code> 字段变更协议。</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">&lt;a</span> <span class="string">href="https://creativecommons.org/licenses/by-nc-sa/4.0/"</span> <span class="string">rel="external</span> <span class="string">nofollow"</span> <span class="string">target="_blank"&gt;CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span><span class="string">&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认版权声明中只有 <strong>本文作者</strong>、<strong>本文链接</strong>、<strong>版权声明</strong> 三项，如果你想添加更多内容，如 <strong>创建时间</strong>、<strong>修改时间</strong>、<strong>引用链接</strong> 等，需要修改版权声明的相关代码：</p>
<figure class="highlight html"><figcaption><span>themes\next\layout\_macro\post-copyright.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JS库 clipboard 拷贝内容到粘贴板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/clipboard.js/2.0.1/clipboard.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- JS库 sweetalert 显示提示信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/sweetalert/dist/sweetalert.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"post-copyright"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 本文标题 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; __('post.copyright.title') + __('symbol.colon') &#125;&#125; <span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    &#123;&#123; post.title &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 本文作者 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"post-copyright-author"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; __('post.copyright.author') + __('symbol.colon') &#125;&#125; <span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    &#123;&#123; post.author | default(author) &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 创建时间 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; __('post.created') + __('symbol.colon') &#125;&#125; <span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    &#123;&#123; post.date.format("YYYY年MM月DD日 - HH时MM分") &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 修改时间 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; __('post.modified') + __('symbol.colon') &#125;&#125; <span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    &#123;&#123; post.updated.format("YYYY年MM月DD日 - HH时MM分") &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 引用链接 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"post-copyright-link"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; __('post.copyright.link') + __('symbol.colon') &#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; post.url | default(post.permalink) &#125;&#125;"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; post.title &#125;&#125;"</span>&gt;</span>&#123;&#123; post.url | default(post.permalink) &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"copy-path"</span>  <span class="attr">title</span>=<span class="string">"点击复制引用链接"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">style</span>=<span class="string">"cursor: pointer"</span> <span class="attr">class</span>=<span class="string">"fa fa-clipboard"</span> <span class="attr">data-clipboard-text</span>=<span class="string">"[&#123;&#123; post.author | default(author) &#125;&#125;'s Blog | &#123;&#123; post.title &#125;&#125;](&#123;&#123; post.permalink &#125;&#125;)"</span>  <span class="attr">aria-label</span>=<span class="string">"&#123;&#123; __('post.copy_success') &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 版权声明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"post-copyright-license"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; __('post.copyright.license_title') + __('symbol.colon') &#125;&#125; <span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    &#123;&#123; __('post.copyright.license_content', theme.post_copyright.license) &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> clipboard = <span class="keyword">new</span> ClipboardJS(<span class="string">'.fa-clipboard'</span>);</span></span><br><span class="line"><span class="actionscript">  clipboard.on(<span class="string">'success'</span>, <span class="function"><span class="keyword">function</span><span class="params">(target)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> message = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span></span><br><span class="line"><span class="handlebars"><span class="xml">    message.innerHTML = '<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-check-circle message-icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"message-content"</span>&gt;</span>' + target.trigger.getAttribute('aria-label') + '<span class="tag">&lt;/<span class="name">span</span>&gt;</span>';</span></span></span><br><span class="line">    swal(&#123;</span><br><span class="line">      content: message,</span><br><span class="line"><span class="actionscript">      className: <span class="string">"copy-success-message"</span>,</span></span><br><span class="line">      timer: 1000,</span><br><span class="line"><span class="actionscript">      button: <span class="literal">false</span></span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在版权样式文件中添加如下样式：</p>
<figure class="highlight css"><figcaption><span>themes\next\source\css\_common\components\post\post-copyright.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.swal-overlay</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.copy-success-message</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">12px</span> <span class="built_in">rgba</span>(0,0,0,0.15);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">width</span>: auto;  </span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">16</span>x <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.copy-success-message</span> <span class="selector-class">.swal-content</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">16px</span>;  </span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.copy-success-message</span> <span class="selector-class">.message-icon</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#52c41a</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.copy-success-message</span> <span class="selector-class">.message-content</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后补全版权信息文案字段：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/languages/zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post:</span></span><br><span class="line">  <span class="attr">created:</span> <span class="string">创建时间</span></span><br><span class="line">  <span class="attr">modified:</span> <span class="string">修改时间</span></span><br><span class="line">  <span class="attr">copy_success:</span> <span class="string">复制成功</span>  </span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">本文标题</span></span><br><span class="line">    <span class="attr">author:</span> <span class="string">本文作者</span></span><br><span class="line">    <span class="attr">link:</span> <span class="string">引用链接</span></span><br><span class="line">    <span class="attr">license_title:</span> <span class="string">版权声明</span></span><br><span class="line">    <span class="attr">license_content:</span> <span class="string">"本博客所有文章除特别声明外，均采用 %s 许可协议。转载请注明出处！"</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>点击引用链接后的图标 <i class="fa fa-clipboard"></i> 即可快捷复制Markdown引用链接，并将弹出复制成功的提示语。该功能主要借助 <a href="https://clipboardjs.com/" target="_blank" rel="noopener">clipboard</a> 和 <a href="https://sweetalert.js.org/" target="_blank" rel="noopener">sweetalert</a> 两个js库来实现，并参考 <a href="https://ant.design/components/message/" target="_blank" rel="noopener">antDesign | message组件</a> 重写了弹框样式。</p>
          </div>


<p>在实际使用过程中，并非每篇文章都需要版权声明，如果转载了别人的文章，文末再出现个人版权声明就不太合适。此时可在Front-Matter中设定变量 <code>copyright</code> 用于控制是否显示版权信息。修改文章布局模板中相关代码，使得只有当主题配置文件中 <code>post_copyright.enable</code> 字段和 <code>page.copyright</code> 字段同时为 <code>true</code> 时才会插入版权声明：</p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/_macro/post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &#123;% if theme.post_copyright.enable and not is_index %&#125;</span></span><br><span class="line"><span class="addition">+ &#123;% if theme.post_copyright.enable and page.copyright and not is_index %&#125;</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;% include 'post-copyright.swig' with &#123; post: post &#125; %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>为了批量为每篇新文章设定该变量并赋默认值，可以修改草稿模板内容，这样以来每篇草稿发布为正文后都会默认显示底部版权信息：</p>
<figure class="highlight diff"><figcaption><span>scaffolds\draft.md</span></figcaption><table><tr><td class="code"><pre><span class="line">  title: &#123;&#123; title &#125;&#125;</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line"><span class="addition">+ copyright: true</span></span><br></pre></td></tr></table></figure>

<h2 id="添加打赏功能"><a href="#添加打赏功能" class="headerlink" title="添加打赏功能"></a>添加打赏功能</h2><p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/post-reward.png" alt="文章打赏功能" title="文章打赏功能"></p>
<p>启用主题配置文件中的打赏相关字段，并将个人收款码图片置于 themes\next\source\images\ 目录下，注意保持图片命名与配置文件中一致：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">reward_comment:</span></span><br><span class="line"><span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.png</span></span><br><span class="line"><span class="attr">alipay:</span> <span class="string">/images/alipay.jpg</span></span><br></pre></td></tr></table></figure>

<p>如果要关闭悬停收款码上的文字抖动效果，可以在自定义样式文件中添加以下代码：</p>
<figure class="highlight css"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//关闭打赏收款码的文字抖动效果</span><br><span class="line"><span class="selector-id">#QR</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并非每个页面都需要开启打赏功能，可以在 Front-Matter 中添加 <code>reward</code> 字段来控制是否在本文章中添加打赏信息，然后修改文章布局模板中相关的判定条件：</p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/_macro/post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &#123;% if (theme.alipay or theme.wechatpay or theme.bitcoin) and not is_index %&#125;</span></span><br><span class="line"><span class="addition">+ &#123;% if ( post.reward and (theme.alipay or theme.wechatpay or theme.bitcoin) and not is_index %&#125;</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;% include 'reward.swig' %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便可在草稿模板 scaffolds\draft.md 中统一添加 <code>reward</code> 字段默认值：</p>
<figure class="highlight diff"><figcaption><span>scaffolds\draft.md</span></figcaption><table><tr><td class="code"><pre><span class="line">  title: &#123;&#123; title &#125;&#125;</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line"><span class="addition">+ reward: true</span></span><br></pre></td></tr></table></figure>

<h2 id="添加图片灯箱"><a href="#添加图片灯箱" class="headerlink" title="添加图片灯箱"></a>添加图片灯箱</h2><p>添加灯箱功能，实现点击图片后放大聚焦图片，并支持幻灯片播放、全屏播放、缩略图、快速分享到社交媒体等，该功能由 <a href="https://github.com/fancyapps/fancybox" target="_blank" rel="noopener">fancyBox</a> 提供，效果如下：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/fancybox.png" alt="fancyBox 灯箱" title="fancyBox 灯箱"></p>
<p>在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$ git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/theme</span>-<span class="keyword">next</span>/theme-<span class="keyword">next</span>-fancybox3 themes/<span class="keyword">next</span>/source/<span class="class"><span class="keyword">lib</span>/<span class="title">fancybox</span></span></span><br></pre></td></tr></table></figure>

<p>在主题配置文件中设置 <code>fancybox: true</code>：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>刷新浏览器即可生效。</p>
<h2 id="相关文章推荐"><a href="#相关文章推荐" class="headerlink" title="相关文章推荐"></a>相关文章推荐</h2><p>该功能由 <a href="https://github.com/tea3/hexo-related-popular-posts" target="_blank" rel="noopener">hexo-related-popular-posts</a> 插件提供，效果如下：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/related-post.png" alt="相关文章推荐" title="相关文章推荐"></p>
<p>在站点根目录中执行以下命令安装依赖：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-related-popular-posts <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>在主题配置文件中开启相关文章推荐功能：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">title:</span>  <span class="comment"># custom header, leave empty to use the default one</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>此时会在每篇文章结尾根据标签相关性和内容相关性来推荐相关文章。</p>
<p>事实上并非每篇文章都需要开启该功能，可在文章 Front-Matter 中设置 <code>related_posts</code> 字段来控制是否在文末显示相关文章，然后修改文章布局模板中相关的判定条件：</p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/_macro/post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &#123;% if theme.related_posts.enable and (theme.related_posts.display_in_home or not is_index) %&#125;</span></span><br><span class="line"><span class="addition">+ &#123;% if theme.related_posts.enable and (theme.related_posts.display_in_home or not is_index) and post.related_posts %&#125;</span></span><br><span class="line">    &#123;% include 'post-related.swig' with &#123; post: post &#125; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便可在草稿模板 scaffolds\draft.md 中统一添加 <code>related_posts</code> 字段默认值：</p>
<figure class="highlight diff"><figcaption><span>scaffolds\draft.md</span></figcaption><table><tr><td class="code"><pre><span class="line">  title: &#123;&#123; title &#125;&#125;</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line"><span class="addition">+ related_posts: true</span></span><br></pre></td></tr></table></figure>

<h2 id="文章评分"><a href="#文章评分" class="headerlink" title="文章评分"></a>文章评分</h2><p><a href="https://widgetpack.com" target="_blank" rel="noopener">widgetpack</a> 是一款轻量级的插件，提供四项具体的功能：</p>
<ul>
<li>Comments: 评论系统，类似于留言板</li>
<li>Reviews: 评价系统，类似于商品评价</li>
<li>Rating: 星级评分系统</li>
<li>Google Reviews: 关联展示Google Rating</li>
</ul>
<p>Next主题中已经集成了 widgetpack 的星级评分系统，用户无须再安装或引入插件脚本，只需在 widgetpack 中注册账号并修改主题配置即可，应用效果如下：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/rating.png" alt="文章评分组件" title="文章评分组件"></p>
<p>在 <a href="https://widgetpack.com" target="_blank" rel="noopener">widgetpack</a> 中注册账号，根据引导填写应用名称和域名创建应用，创建后可在页面左上角看到应用id。</p>
<p>在主题配置文件中开启评分功能，填写应用id，并设置评分颜色：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Star rating support to each article.</span></span><br><span class="line"><span class="comment"># To get your ID visit https://widgetpack.com</span></span><br><span class="line"><span class="attr">rating:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span>     <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">color:</span>  <span class="string">fadb14</span></span><br></pre></td></tr></table></figure>

<p>此时刷新浏览器即可在文章末尾看到空的评分栏了。点击评分发现需要以社交账号登陆，而这些社交账号基本都是facebook、twitter等墙外的社交软件，限制了评分系统可用性，我们可以在 widgetpack 控制台中修改评分认证机制。</p>
<p>在控制台中点击左上角展开菜单，在 <strong>Rating</strong> -&gt; <strong>Setting</strong> 中将 Vote via 选项改为 Device(cookie) 以开启匿名评分，该选项将基于设备认证访问者身份：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/rate-vote-via.png" alt="开启匿名评分" title="开启匿名评分"></p>
<p>用户还可以在该页面设定 star 数量和大小。修改后记得勾选右下角的SAVE SETTING才会生效。</p>
<p>在实际使用过程中，并非每篇文章都需要开启评分。此时可在 Front-Matter 中设定变量 rating 用于控制是否开启评分。修改文章布局模板中相关代码，使得只有当主题配置文件中 <code>rating.enable</code> 字段和 <code>page.rating</code> 字段同时为 <code>true</code> 才会插入评分组件：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line"><span class="deletion">-  &#123;% if theme.rating.enable or (theme.vkontakte_api.enable and theme.vkontakte_api.like) or (theme.facebook_sdk.enable and theme.facebook_sdk.like_button) or (theme.needmoreshare2.enable and theme.needmoreshare2.postbottom.enable) or (theme.baidushare and theme.baidushare.type === "button" )%&#125;</span></span><br><span class="line"><span class="addition">+  &#123;% if (theme.rating.enable and post.rating) or (theme.vkontakte_api.enable and theme.vkontakte_api.like) or (theme.facebook_sdk.enable and theme.facebook_sdk.like_button) or (theme.needmoreshare2.enable and theme.needmoreshare2.postbottom.enable) or (theme.baidushare and theme.baidushare.type === "button" )%&#125;</span></span><br><span class="line">    &lt;div class="post-widgets"&gt;</span><br><span class="line">    &#123;% if theme.rating.enable %&#125;</span><br><span class="line">      &lt;div class="wp_rating"&gt;</span><br><span class="line">        &lt;div id="wpac-rating"&gt;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>为了批量为每篇新文章设定该变量并赋默认值，可以修改草稿模板内容，这样以来每篇草稿发布后都会默认开启评分：</p>
<figure class="highlight diff"><figcaption><span>scaffolds\draft.md</span></figcaption><table><tr><td class="code"><pre><span class="line">  title: &#123;&#123; title &#125;&#125;</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line"><span class="addition">+ rating: true</span></span><br></pre></td></tr></table></figure>

<p>站点上线后，可以在控制台菜单的 <strong>Site</strong> -&gt; <strong>Setting</strong> 中勾选 Private，使得组件只对应用内指定的域名上生效，这样以来即时别人错填了你的id也不会将评分数据误提交到你的应用中了。</p>
<div class="note info">
            <p>widgetpack 与前文提到的 hotjar 在评价反馈功能上的侧重点不一样，widgetpack 更侧重于对文章的评分，而hotjar侧重于对整个页面的评分，并提供了文字和截图反馈的渠道。</p>
          </div>

<h2 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h2><p>该功能由 <a href="https://github.com/MikeCoder/hexo-blog-encrypt" target="_blank" rel="noopener">hexo-blog-encrypt</a> 插件提供，效果如下：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-advanced-settings/post-encrypt.png" alt="文章加密" title="文章加密"></p>
<p>在站点根目录中执行以下命令安装依赖：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-blog-<span class="keyword">encrypt</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>在站点配置文件中添加如下字段：</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">default_abstract:</span> <span class="string">此文章已被加密，需要输入密码访问。</span>  <span class="string">//首页文章列表中加密文章的默认描述文案</span></span><br><span class="line">  <span class="attr">default_message:</span> <span class="string">请输入密码以阅读这篇私密文章。</span>  <span class="string">//文章详情页的密码输入框上的默认描述文案</span></span><br></pre></td></tr></table></figure>

<p>重启服务器，这个时候可能需要经历较长一段时间的加密过程，请耐心等待，加密完成后刷新页面将会显示密码输入框，输入密码后才能继续访问文章内容。</p>
<div class="note info">
            <p>该功能只会加密文章正文，其他内容如打赏、版权信息、标签等则不会被加密隐藏，这样看起来有点奇怪，所以建议加密文章隐藏掉打赏和版权信息内容。</p>
          </div>

<p>密码输入错误时将会显示浏览器默认告警弹窗，可以使用 <a href="https://sweetalert.js.org/" target="_blank" rel="noopener">sweetalert</a> 来美化错误提示：</p>
<p>在主题自定义布局文件中添加如下代码：</p>
<figure class="highlight html"><figcaption><span>themes\next\layout\_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/sweetalert/dist/sweetalert.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">      ...</span><br><span class="line">      &#123;% include '_third-party/exturl.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/bookmark.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/copy-code.swig' %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+     &#123;% include '_custom/custom.swig' %&#125;</span></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在 node_modules 依赖库中修改 hexo-blog-encrypt 源码：</p>
<figure class="highlight diff"><figcaption><span>node_modules\hexo-blog-encrypt\lib\blog.encrypt.js</span></figcaption><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line"><span class="deletion">-   alert(decryptionError);</span></span><br><span class="line"><span class="addition">+   swal(&#123;   </span></span><br><span class="line"><span class="addition">+     text: "密码错误!",</span></span><br><span class="line"><span class="addition">+     icon: "error",</span></span><br><span class="line"><span class="addition">+     className: "password-error",</span></span><br><span class="line"><span class="addition">+     timer: 1000,  </span></span><br><span class="line"><span class="addition">+     button: false</span></span><br><span class="line"><span class="addition">+   &#125;);</span></span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>在自定义样式文件中添加如下代码：</p>
<figure class="highlight css"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//密码错误sweetalert弹框样式修改</span><br><span class="line"><span class="selector-class">.swal-overlay</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.password-error</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">12px</span> <span class="built_in">rgba</span>(0,0,0,0.15);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>由于是在node_module中修改的依赖文件，一旦更新或者重装依赖都会覆盖修改，需要重新修改一遍。</p>
          </div>

<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>在集成第三方插件或者自定义新功能的过程中我一直试图秉持这些原则：</p>
<ul>
<li>可以在站点配置/主题配置文件中方便快捷的开启/关闭插件服务</li>
<li>可以在语言包 zh-CN.yml 中快速修改页面中的自定义文案，而不是在代码中将文字表述写死</li>
<li>尽量在自定义样式文件 custom.styl 和自定义布局文件 custom.swig 中添加代码，而非修改主题源码</li>
<li>新增文件统一放在 _custom 目录下</li>
</ul>
<p>所有以上这些原则，尽管实现起来可能更复杂，需要更多的代码，但都是为了让站点更好维护，更灵活方便。</p>
<p>本文介绍了如何通过修改自定义设置和集成三方插件服务搭建一个功能更加完善的个性化Hexo博客，尽管我们的博客可能已经做的令自己很满意了，但至今仍是只能在本地访问，别人看不到。我们建立博客往往都是希望能将自己的文章分享给他人来创造更多价值，如果想要了解如何将站点部署到公网，请参考本系列中最后一篇文章：<a href="/2018/11/20/hexo-deploy-to-VPS/" title="Hexo搭建个人博客系列：部署上线篇">Hexo搭建个人博客系列：部署上线篇</a>。</p>
<div class="reference-linking">参考链接</div>

<ul>
<li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">reuixiy | 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></li>
<li><a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">夏末 | 为NexT主题添加文章阅读量统计功能</a></li>
<li><a href="https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">nMask | Hexo搭建博客教程</a></li>
<li><a href="https://leancloud.cn/docs/leanstorage_guide-js.html" target="_blank" rel="noopener">LeanCloud | JavaScript SDK 安装指南</a></li>
<li><a href="https://diygod.me/2153/" target="_blank" rel="noopener">DIYgod | 我藏好了哦</a></li>
<li><a href="https://github.com/mythsman/hexo-douban" target="_blank" rel="noopener">mythsman/hexo-douban README.md</a></li>
<li><a href="https://asdfv1929.github.io/2018/01/21/daovoice/" target="_blank" rel="noopener">asdfv1929 | Hexo NexT主题内接入网页在线联系功能</a></li>
<li><a href="https://www.hotjar.com/tour" target="_blank" rel="noopener">Hotjar Features</a></li>
<li><a href="https://www.hotjar.com/incoming-feedback" target="_blank" rel="noopener">Incoming Feedback by Hotjar</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客系列：主题美化篇</title>
    <url>/2018/11/20/hexo-theme-beautiful/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了在 Next 主题的基础上进一步对博客进行美化的方案，主要包括:</p>
<ul>
<li>在文章末尾添加结束标记</li>
<li>修改侧边栏的位置到左边</li>
<li>添加不同类型的动态背景效果</li>
<li>添加 live2d 看板娘</li>
<li>为布局元素添加边缘弹性摆动效果</li>
<li>个性化回到顶部按钮</li>
<li>添加不同类型的鼠标点击特效</li>
<li>评论区输入打字礼花特效</li>
</ul>
<p>读者可以根据需要选择其中喜欢的方案应用到站点博客中。</p>
<a id="more"></a>

<h1 id="修改博客字体"><a href="#修改博客字体" class="headerlink" title="修改博客字体"></a>修改博客字体</h1><p>在 <a href="https://www.google.com/fonts" target="_blank" rel="noopener">Google Fonts</a> 上找到心仪的字体，然后在主题配置文件中为不同的应用场景配置字体：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 外链字体库地址，例如 //fonts.googleapis.com (默认值)</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 全局字体，应用在 body 元素上</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Monda</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 标题字体 (h1, h2, h3, h4, h5, h6)</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Roboto</span> <span class="string">Slab</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 文章字体</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Logo 字体</span></span><br><span class="line">  <span class="attr">logo:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 代码字体，应用于 code 以及代码块</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br></pre></td></tr></table></figure>

<h1 id="文章页末美化"><a href="#文章页末美化" class="headerlink" title="文章页末美化"></a>文章页末美化</h1><h2 id="为标签添加图标"><a href="#为标签添加图标" class="headerlink" title="为标签添加图标"></a>为标签添加图标</h2><p>默认情况下标签前缀是 <code>#</code> 字符，用户可以通过修改主题源码将标签的字符前缀改为图标前缀，更改后效果如下：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/20181113045027074.png" alt="标签图标前缀" title="标签图标前缀"></p>
<p>在文章布局模板中找到文末标签相关代码段，将 <code>#</code> 换成 <code>&lt;i class=&quot;fa fa-tags&quot;&gt;&lt;/i&gt;</code> 即可：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &lt;footer class="post-footer"&gt;</span><br><span class="line">    &#123;% if post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">      &lt;div class="post-tags"&gt;</span><br><span class="line">        &#123;% for tag in post.tags %&#125;</span><br><span class="line"><span class="deletion">-          &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span></span><br><span class="line"><span class="addition">+          &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tags"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<p>Next中使用 <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">FontAwesome</a> 作为图标库，用户可以在 FontAwesome 上找到心仪的图标来替换标签的字符前缀。</p>
<h2 id="添加结束标记"><a href="#添加结束标记" class="headerlink" title="添加结束标记"></a>添加结束标记</h2><div class="note info">
            <p>本章节参考 <a href="https://asdfv1929.github.io/2018/01/28/add-the-end/" target="_blank" rel="noopener">asdfv1929 | Hexo NexT主题内给每篇文章后添加结束标语</a></p>
          </div>

<p>在文末添加结束标记，效果如下：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/20181113045252399.png" alt="文末结束标记" title="文末结束标记"></p>
<p>新建布局模板文件 post-end-tag.swig，添加如下代码：</p>
<figure class="highlight html"><figcaption><span>themes\next\layout\_macro\post-end-tag.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;color:#bfbfbf;font-size:16px;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>-------- 本文结束 <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-&#123;&#123; config.post_end_tag.icon &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span> 感谢阅读 --------<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在文章布局模板中添加如下代码：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\post</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;#####################&#125;</span><br><span class="line">&#123;### END POST BODY ###&#125;</span><br><span class="line">&#123;#####################&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ &#123;% if config.post_end_tag.enabled and not is_index %&#125;</span></span><br><span class="line"><span class="addition">+   &lt;div&gt;</span></span><br><span class="line"><span class="addition">+     &#123;% include 'post-end-tag.swig' %&#125;</span></span><br><span class="line"><span class="addition">+   &lt;/div&gt;</span></span><br><span class="line"><span class="addition">+ &#123;% endif %&#125;</span></span><br><span class="line"></span><br><span class="line">&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include 'wechat-subscriber.swig' %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>在站点配置文件末尾添加如下代码：</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment"># 是否开启文末的本文结束标记</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">paw</span> <span class="comment"># 结束标记之间的图标</span></span><br></pre></td></tr></table></figure>

<p>重启服务器后即可在文末看到结束标记。</p>
<h1 id="页面加载进度条"><a href="#页面加载进度条" class="headerlink" title="页面加载进度条"></a>页面加载进度条</h1><p>当网络不好的时候可能会在打开站点或跳转文章时出现短暂的白屏，此时如果能有加载进度提示将会提高用户操作体验。</p>
<p>在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$ git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/theme</span>-<span class="keyword">next</span>/theme-<span class="keyword">next</span>-pace themes/<span class="keyword">next</span>/source/<span class="class"><span class="keyword">lib</span>/<span class="title">fancybox</span></span></span><br></pre></td></tr></table></figure>

<p>在主题配置文件中设置 <code>pace: true</code>。</p>
<p>默认提供了多种主题的进度条加载样式，有顶部提示的，有中间提示的，还有全页面遮挡提示的，个人认为默认的进度条效果就恰如其当，既能够在页面空白的时候起到加载作用，也不会因为太过花里胡哨而喧宾夺主，尤其是当你如果使用了不蒜子的站点访问统计的功能的时候，常常会遇到所有资源都加载完毕而不蒜子还在等待响应，如果这个时候在页面较显眼的位置出现一个停滞不前的进度条，很让人抓狂。</p>
<h1 id="侧边栏放左边"><a href="#侧边栏放左边" class="headerlink" title="侧边栏放左边"></a>侧边栏放左边</h1><p>受 <a href="https://www.ofind.cn/" target="_blank" rel="noopener">猪猪侠的博客</a> 所启发，萌生了想把主题侧边栏放在左侧的想法。</p>
<p>Next主题各系列中只有Pisces和Gemini支持通过主题配置文件来将侧边栏置于左侧或右侧，而Muse和Mist则需要深度修改源码才能实现改变侧边栏位置。</p>
<p>在自定义样式文件中添加如下规则：</p>
<figure class="highlight css"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sidebar-toggle</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改动效脚本代码：</p>
<figure class="highlight diff"><figcaption><span>themes\next\source\js\src\motion.js</span></figcaption><table><tr><td class="code"><pre><span class="line">$(document)</span><br><span class="line">  .on('sidebar.isShowing', function() &#123;</span><br><span class="line">    NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(</span><br><span class="line"><span class="deletion">-     &#123;paddingRight: SIDEBAR_WIDTH&#125;,</span></span><br><span class="line"><span class="addition">+     &#123;paddingLeft: SIDEBAR_WIDTH&#125;,</span></span><br><span class="line">      SIDEBAR_DISPLAY_DURATION</span><br><span class="line">    );</span><br><span class="line">  &#125;)</span><br><span class="line">  .on('sidebar.isHiding', function() &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br><span class="line">  hideSidebar: function() &#123;</span><br><span class="line"><span class="deletion">-   NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingRight: 0&#125;);</span></span><br><span class="line"><span class="addition">+   NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingLeft: 0&#125;);</span></span><br><span class="line">    this.sidebarEl.find('.motion-element').velocity('stop').css('display', 'none');</span><br><span class="line">    this.sidebarEl.velocity('stop').velocity(&#123;width: 0&#125;, &#123;display: 'none'&#125;);</span><br><span class="line"></span><br><span class="line">    sidebarToggleLines.init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此以来就可以将侧边栏放置在左边了，但当窗口宽度缩小到991px之后会出现样式错误：侧边栏收缩消失但是页面左侧仍留有空白间距，此时修改如下代码即可：</p>
<figure class="highlight diff"><figcaption><span>themes\next\source\css\_common\scaffolding\base.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  position: relative; // Required by scrollspy</span><br><span class="line">  font-family: $font-family-base;</span><br><span class="line">  font-size: $font-size-base;</span><br><span class="line">  line-height: $line-height-base;</span><br><span class="line">  color: $text-color;</span><br><span class="line">  background: $body-bg-color;</span><br><span class="line"></span><br><span class="line"><span class="deletion">- +mobile() &#123; padding-left: 0 !important; &#125;</span></span><br><span class="line"><span class="deletion">- +tablet() &#123; padding-left: 0 !important; &#125;  </span></span><br><span class="line"><span class="addition">+ +mobile() &#123; padding-right: 0 !important; &#125;</span></span><br><span class="line"><span class="addition">+ +tablet() &#123; padding-right: 0 !important; &#125;</span></span><br><span class="line">  +desktop-large() &#123; font-size: $font-size-large; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h1><p>Next主题可以通过安装插件快速为站点添加不同效果的动态背景。</p>
<h2 id="粒子漂浮聚合"><a href="#粒子漂浮聚合" class="headerlink" title="粒子漂浮聚合"></a>粒子漂浮聚合</h2><p>应用效果如下图：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/20181115092103046.png" alt="canvas-nest 动态背景" title="canvas-nest 动态背景"></p>
<p>该功能由 <a href="https://github.com/theme-next/theme-next-canvas-nest" target="_blank" rel="noopener">theme-next-canvas-nest</a> 插件提供，在根目录下执行如下命令：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$ git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/theme</span>-<span class="keyword">next</span>/theme-<span class="keyword">next</span>-canvas-nest themes/<span class="keyword">next</span>/source/<span class="class"><span class="keyword">lib</span>/<span class="title">canvas</span>-<span class="title">nest</span></span></span><br></pre></td></tr></table></figure>

<p>然后在主题配置文件中设置 <code>canvas_nest: true</code> 即可。</p>
<p>Next v6.5.0 及以上版本支持更多的自定义选项：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span> <span class="comment"># 是否在移动端显示</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">'0,0,255'</span> <span class="comment"># 动态背景中线条的 RGB 颜色</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.5</span> <span class="comment"># 动态背景中线条透明度</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># 动态背景的 z-index 属性值</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># 动态背景中线条数量</span></span><br></pre></td></tr></table></figure>

<h2 id="Three-三维动效"><a href="#Three-三维动效" class="headerlink" title="Three 三维动效"></a>Three 三维动效</h2><p><a href="https://github.com/theme-next/theme-next-three" target="_blank" rel="noopener">theme-next-three</a> 插件提供了三个类型的背景动效，应用效果如下：</p>
<div class="tabs" id="three-三维动效"><ul class="nav-tabs"><li class="tab active"><a href="#three-三维动效-1">three-waves</a></li><li class="tab"><a href="#three-三维动效-2">canvas-lines</a></li><li class="tab"><a href="#three-三维动效-3">canvas-sphere</a></li></ul><div class="tab-content"><div class="tab-pane active" id="three-三维动效-1"><p>  <img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/20181115091950761.png" alt></p></div><div class="tab-pane" id="three-三维动效-2"><p>  <img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/20181115091914602.png" alt></p></div><div class="tab-pane" id="three-三维动效-3"><p>  <img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/20181115091826700.png" alt></p></div></div></div>

<p>在根目录下执行如下命令安装相关依赖：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$ git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/theme</span>-<span class="keyword">next</span>/theme-<span class="keyword">next</span>-three themes/<span class="keyword">next</span>/source/<span class="class"><span class="keyword">lib</span>/<span class="title">three</span></span></span><br></pre></td></tr></table></figure>

<p>然后在主题配置文件中设置开启对应的动效选项即可。</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># JavaScript 3D library.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-three</span></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>个人认为在站点中添加动态背景并没有实际的意义，只会凭空增加页面内存占用及CPU消耗，所以本站没有添加任何动态背景。</p>
          </div>

<h2 id="随机三角丝带"><a href="#随机三角丝带" class="headerlink" title="随机三角丝带"></a>随机三角丝带</h2><p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/evan-you.png" alt="随机三角丝带" title="随机三角丝带"></p>
<div class="note info">
            <p>该功能由 Vue 作者 <a href="http://evanyou.me/" target="_blank" rel="noopener">尤雨溪</a> 首创。本章节中核心代码来源于 <a href="https://diygod.me/" target="_blank" rel="noopener">DIYgod</a> 编写的 <a href="https://github.com/DIYgod/hexo-theme-sagiri" target="_blank" rel="noopener">sagiri</a> 主题。</p>
          </div>

<p>点击下方按钮下载相应的脚本，并置于 themes\next\source\js\ 目录下：</p>
<p>
<a class="btn" href="https://script-1256884783.file.myqcloud.com/evan-you.js" target="_blank" rel="noopener"><i class="fa fa-download fa-fw"></i>随机三角丝带</a>
</p>

<p>在主题自定义布局文件中添加以下代码：</p>
<figure class="highlight html"><figcaption><span>themes\next\layout\_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# 随机三角丝带背景 #&#125;</span><br><span class="line">&#123;% if theme.evanyou %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"evanyou"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#evanyou</span> &#123;</span></span><br><span class="line">      position: fixed;</span><br><span class="line">      width: 100%;</span><br><span class="line">      height: 100%;</span><br><span class="line">      top: 0;</span><br><span class="line">      left: 0;</span><br><span class="line">      z-index: -1;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/evan-you.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">      ...</span><br><span class="line">      &#123;% include '_third-party/exturl.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/bookmark.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/copy-code.swig' %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+     &#123;% include '_custom/custom.swig' %&#125;</span></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中添加以下代码：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># colorful trilateral riband background</span></span><br><span class="line"><span class="attr">evanyou:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>如果从本地加载JS脚本速度较慢，可以考虑将脚本放到CDN上再引入。</p>
<h1 id="添加看板娘"><a href="#添加看板娘" class="headerlink" title="添加看板娘"></a>添加看板娘</h1><div class="note info">
            <p>本章节部分内容参考 <a href="https://fjkang.github.io/2017/12/08/%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%90%8C%E7%89%A9/" target="_blank" rel="noopener">FJKang | 添加一个萌物</a></p>
          </div>

<p>该功能由 <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a> 插件支持，效果如下图：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/live2d.gif" alt="live2d 看板娘" title="live2d 看板娘"></p>
<p>在站点根目录下执行以下命令安装依赖：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> <span class="comment">--save hexo-helper-live2d</span></span><br></pre></td></tr></table></figure>

<p>在站点配置文件中添加以下下配置项</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment"># https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span> <span class="string">Relative)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 脚本加载源</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span> <span class="comment"># 默认从本地加载脚本</span></span><br><span class="line">  <span class="comment"># scriptFrom: jsdelivr # 从 jsdelivr CDN 加载脚本</span></span><br><span class="line">  <span class="comment"># scriptFrom: unpkg # 从 unpkg CDN 加载脚本</span></span><br><span class="line">  <span class="comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 从自定义地址加载脚本</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span> <span class="comment"># 只在有 &#123;&#123; live2d() &#125;&#125; 标签的页面上加载 / 在所有页面上加载</span></span><br><span class="line">  <span class="attr">log:</span> <span class="literal">false</span> <span class="comment"># 是否在控制台打印日志</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 选择看板娘模型</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-shizuku</span>  <span class="comment"># npm package的名字</span></span><br><span class="line">    <span class="comment"># use: wanko # /live2d_models/ 目录下的模型文件夹名称</span></span><br><span class="line">    <span class="comment"># use: ./wives/wanko # 站点根目录下的模型文件夹名称</span></span><br><span class="line">    <span class="comment"># use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 自定义网络数据源</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">left</span> <span class="comment"># 显示在左边还是右边</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span> <span class="comment"># 宽度</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">180</span> <span class="comment"># 高度</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacityDefault:</span> <span class="number">0.7</span> <span class="comment"># 默认透明度</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>更多配置参数请查看 <a href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" target="_blank" rel="noopener">L2Dwidget | live2d-widget.js</a></p>
          </div>

<p>此时重启服务器暂时还看不到看板娘，需要手动下载或安装模型资源。可以从 <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">hexo live2d 模型预览</a> 里找到你喜欢的角色，然后根据 <a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">live2d-widget-models</a> 中提供的方法来下载模型数据.</p>
<p>例如通过以下命令下载模型 shizuku：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> npm install live2d-widget-<span class="keyword">model</span>-shizuku</span><br></pre></td></tr></table></figure>

<p>因为修改了站点配置文件，所以需要重启服务器才能预览模型效果。</p>
<p>如果设置了 <code>live2d.tagMode: true</code>，则可以在指定页面中插入以下标签：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;&#123;</span> <span class="string">live2d()</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>只有拥有该标签的页面才会渲染live2d模型，这样以来就可以精确控制在哪些页面上显示看板娘了。</p>
<p>如果只想在一级菜单页面上显示看板娘，可以在Header模板中添加以下代码：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_partials\header\index.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="addition">+ &#123;% if is_index %&#125;</span></span><br><span class="line"><span class="addition">+   &#123;&#123; live2d() &#125;&#125;</span></span><br><span class="line"><span class="addition">+ &#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>个人认为在文章内出现看板娘将会影响读者注意力的集中，毕竟一篇博客里最重要的是内容，而不是这些花里胡哨转移注意力的东西。所以本站只在一级菜单页面添加了看板娘，文章页面则保持极致精简的阅读体验。</p>
          </div>

<p>经过测试发现 <code>live2d.mobile.show: false</code> 并没有生效，暂时没有找到好的解决方法，参考 <a href="https://github.com/EYHN/hexo-helper-live2d/issues/12" target="_blank" rel="noopener">EYHN/hexo-helper-live2d Issues #12</a> 后发现可以在自定义样式文件中添加以下代码来解决：</p>
<figure class="highlight css"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#live2dcanvas</span> &#123;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">none</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  +<span class="selector-tag">tablet</span>() &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>不要乱点不该点的地方，会生气的。</p>
          </div>

<h1 id="边缘摆动效果"><a href="#边缘摆动效果" class="headerlink" title="边缘摆动效果"></a>边缘摆动效果</h1><p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/wobblewindow.gif" alt="wobblewindow 边缘摆动" title="wobblewindow 边缘摆动"></p>
<p>在 <a href="https://www.ofind.cn/" target="_blank" rel="noopener">猪猪侠的博客</a> 里发现的这种特效，觉得挺有意思的，就从他Github上给扒过来了</p>
<p>点击下方按钮下载脚本，并置于 themes\next\source\js\ 目录下：</p>
<p>
<a class="btn" href="https://script-1256884783.file.myqcloud.com/wobblewindow.js" target="_blank" rel="noopener"><i class="fa fa-download fa-fw"></i>wobblewindow.js</a>
</p>

<p>在主题自定义布局文件中添加以下代码：</p>
<figure class="highlight html"><figcaption><span>themes\next\layout\_script\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# wobble窗口摆动特效 #&#125;</span><br><span class="line">&#123;% if theme.wobble %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/wobblewindow"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//只在桌面版网页启用特效</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>( <span class="built_in">window</span>.innerWidth &gt; <span class="number">768</span>  )&#123;</span></span><br><span class="line"><span class="javascript">      $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        &#123;% if theme.wobble.header %&#125;</span><br><span class="line"><span class="javascript">          $(<span class="string">'#header'</span>).wobbleWindow(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">            radius: </span><span class="template-variable">&#123;&#123; theme.wobble.radius &#125;&#125;</span><span class="xml">,</span></span></span><br><span class="line"><span class="actionscript">            movementTop: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">            movementLeft: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">            movementRight: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">            debug: <span class="literal">false</span>,</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">        &#123;% if theme.wobble.sidebar %&#125;</span><br><span class="line"><span class="javascript">          $(<span class="string">'#sidebar'</span>).wobbleWindow(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">            radius: </span><span class="template-variable">&#123;&#123; theme.wobble.radius &#125;&#125;</span><span class="xml">,</span></span></span><br><span class="line"><span class="actionscript">            movementLeft: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">            movementTop: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">            movementBottom: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">            position: <span class="string">'fixed'</span>,</span></span><br><span class="line"><span class="actionscript">            debug: <span class="literal">false</span>,</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">        &#123;% if theme.wobble.footer %&#125;</span><br><span class="line"><span class="javascript">          $(<span class="string">'#footer'</span>).wobbleWindow(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">            radius: </span><span class="template-variable">&#123;&#123; theme.wobble.radius &#125;&#125;</span><span class="xml">,</span></span></span><br><span class="line"><span class="actionscript">            movementBottom: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">            movementLeft: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">            movementRight: <span class="literal">false</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">            offsetX: </span><span class="template-variable">&#123;&#123; theme.wobble.offset &#125;&#125;</span><span class="xml">,</span></span></span><br><span class="line"><span class="actionscript">            position: <span class="string">'absolute'</span>,</span></span><br><span class="line"><span class="actionscript">            debug: <span class="literal">false</span>,</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">      ...</span><br><span class="line">      &#123;% include '_third-party/exturl.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/bookmark.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/copy-code.swig' %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+     &#123;% include '_custom/custom.swig' %&#125;</span></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在自定义样式文件中添加以下样式：</p>
<figure class="highlight css"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//窗口波动效果相关样式</span><br><span class="line">if hexo-config('wobble')  &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.wobbleTransparentBK</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,0,0) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.wobbleTransparentLine</span>&#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(0,0,0,0) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //Next.Muse中为Header和Footer添加背景色</span><br><span class="line">  <span class="selector-id">#header</span>, <span class="selector-id">#footer</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(245, 245, 245);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //防止sidebar和footer同时开启动效时堆叠异常</span><br><span class="line">  <span class="selector-id">#sidebar</span>, <span class="selector-tag">header</span> &#123;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span> <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //防止挡住页末文章的阅读全文按钮</span><br><span class="line">  <span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>Next.Muse主题方案中Header和Footer是没有背景色的，所以需要添加背景色后才能看出边缘摆动效果。另外，实现边缘摆动效果所需的 <code>z-index</code> 属性可能会导致元素堆叠异常，需要添加以上样式来矫正。</p>
          </div>

<p>在主题配置文件中添加以下代码：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># window woblle</span></span><br><span class="line"><span class="attr">wobble:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 是否开启边缘波动效果</span></span><br><span class="line">  <span class="attr">radius:</span> <span class="number">50</span>  <span class="comment"># 波动半径</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span>  <span class="comment"># 开启侧边栏边缘摆动</span></span><br><span class="line">  <span class="attr">header:</span> <span class="literal">true</span>  <span class="comment"># 开启头部边缘摆动</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="literal">true</span>  <span class="comment"># 开启脚部边缘摆动</span></span><br></pre></td></tr></table></figure>

<p>用户可以根据需要在配置文件中为选择开启边缘摆动效果的布局元素。刷新浏览器，然后将鼠标移动到布局边缘上尽情的挑逗它吧。</p>
<p>如果从本地加载JS脚本速度较慢，可以考虑将脚本放到CDN上再引入。</p>
<h1 id="个性化回到顶部"><a href="#个性化回到顶部" class="headerlink" title="个性化回到顶部"></a>个性化回到顶部</h1><p>从 <a href="https://diygod.me/" target="_blank" rel="noopener">DIYgod的博客</a> 里扒来的，效果如下：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/back-to-top.gif" alt="回到顶部" title="回到顶部"></p>
<p>原理很简单，将 back-to-top 按钮添加图片背景，并添加CSS3动效即可。</p>
<p>首先，找到自己喜欢的图片素材放到 source\images\ 目录下。</p>
<p>你可以点击下方按钮下载本站所使用的小猫上吊素材（<br>小猫咪这么可爱，当然要多放点孜然啦…）</p>
<a class="btn" href="/images/scroll.png" download>
  <i class="fa fa-download fa-fw"></i>
  下载图片
</a>

<p>然后在自定义样式文件中添加如下代码：</p>
<figure class="highlight css"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//自定义回到顶部样式</span><br><span class="line"><span class="selector-class">.back-to-top</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">60px</span>;</span><br><span class="line">  width: 70px;  //图片素材宽度</span><br><span class="line">  height: 900px;  //图片素材高度</span><br><span class="line">  <span class="selector-tag">top</span>: <span class="selector-tag">-900px</span>;</span><br><span class="line">  <span class="selector-tag">bottom</span>: <span class="selector-tag">unset</span>;</span><br><span class="line">  <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> <span class="selector-class">.5s</span> <span class="selector-tag">ease-in-out</span>;</span><br><span class="line">  background: url("/images/scroll.png");</span><br><span class="line"></span><br><span class="line">  //隐藏箭头图标</span><br><span class="line">  &gt; <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-class">.back-to-top-on</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: unset;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100vh</span> &lt; (<span class="number">900px</span> + <span class="number">200px</span>) ? <span class="built_in">calc</span>( 100vh - 900px - 200px ) : <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刷新浏览器即可预览效果。</p>
<h1 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h1><p>从各个站点里搜罗了以下四个比较常用的鼠标点击特效：</p>
<div class="tabs" id="鼠标点击特效"><ul class="nav-tabs"><li class="tab active"><a href="#鼠标点击特效-1">礼花特效</a></li><li class="tab"><a href="#鼠标点击特效-2">爆炸特效</a></li><li class="tab"><a href="#鼠标点击特效-3">浮出爱心</a></li><li class="tab"><a href="#鼠标点击特效-4">浮出文字</a></li></ul><div class="tab-content"><div class="tab-pane active" id="鼠标点击特效-1"><p>  <img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/cursor-fireworks.gif" alt></p></div><div class="tab-pane" id="鼠标点击特效-2"><p>  <img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/cursor-explosion.gif" alt></p></div><div class="tab-pane" id="鼠标点击特效-3"><p>  <img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/cursor-love.gif" alt></p></div><div class="tab-pane" id="鼠标点击特效-4"><p>  <img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/cursor-text.gif" alt></p></div></div></div>

<p>点击下方按钮下载相应的脚本，并置于 themes\next\source\js\cursor\ 目录下：</p>
<p>
<a class="btn" href="https://script-1256884783.file.myqcloud.com/cursor/fireworks.js" target="_blank" rel="noopener"><i class="fa fa-download fa-fw"></i>礼花特效</a>
<a class="btn" href="https://script-1256884783.file.myqcloud.com/cursor/explosion.min.js" target="_blank" rel="noopener"><i class="fa fa-download fa-fw"></i>爆炸特效</a>
<a class="btn" href="https://script-1256884783.file.myqcloud.com/cursor/love.min.js" target="_blank" rel="noopener"><i class="fa fa-download fa-fw"></i>浮出爱心</a>
<a class="btn" href="https://script-1256884783.file.myqcloud.com/cursor/text.js" target="_blank" rel="noopener"><i class="fa fa-download fa-fw"></i>浮出文字</a>
</p>

<p>在主题自定义布局文件中添加以下代码：</p>
<figure class="highlight html"><figcaption><span>themes\next\layout\_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# 鼠标点击特效 #&#125;</span><br><span class="line">&#123;% if theme.cursor_effect == "fireworks" %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"js/cursor/fireworks.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% elseif theme.cursor_effect == "explosion" %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">class</span>=<span class="string">"fireworks"</span> <span class="attr">style</span>=<span class="string">"position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"</span> &gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/animejs/2.2.0/anime.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"js/cursor/explosion.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% elseif theme.cursor_effect == "love" %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"js/cursor/love.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% elseif theme.cursor_effect == "text" %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"js/cursor/text.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">      ...</span><br><span class="line">      &#123;% include '_third-party/exturl.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/bookmark.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/copy-code.swig' %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+     &#123;% include '_custom/custom.swig' %&#125;</span></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中添加以下代码：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># mouse click effect: fireworks | explosion | love | text</span></span><br><span class="line"><span class="attr">cursor_effect:</span> <span class="string">fireworks</span></span><br></pre></td></tr></table></figure>

<p>这样即可在配置文件中一键快速切换鼠标点击特效。</p>
<p>如果从本地加载JS脚本速度较慢，可以考虑将脚本放到CDN上再引入。</p>
<h1 id="打字特效"><a href="#打字特效" class="headerlink" title="打字特效"></a>打字特效</h1><div class="note info">
            <p>本章节参考 <a href="https://qianling.pw/hexo-optimization/" target="_blank" rel="noopener">千灵夙赋 | Hexo 优化汇总 #31</a>，原文出自 <a href="https://www.ilxtx.com/comment-input-effects.html" target="_blank" rel="noopener">龙笑天下 | 给 WordPress 博客网站添加评论输入打字礼花及震动特效</a></p>
          </div>

<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-theme-beautify/typing-effect.gif" alt="打字特效" title="打字特效"></p>
<p>点击下方按钮下载相应的脚本，并置于 themes\next\source\js\ 目录下：</p>
<p>
<a class="btn" href="https://script-1256884783.file.myqcloud.com/activate-power-mode.min.js" target="_blank" rel="noopener"><i class="fa fa-download fa-fw"></i>打字特效</a>
</p>

<p>在主题自定义布局文件中添加以下代码：</p>
<figure class="highlight html"><figcaption><span>themes\next\layout\_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# 打字特效 #&#125;</span><br><span class="line">&#123;% if theme.typing_effect %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/activate-power-mode.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    POWERMODE.colorful = </span><span class="template-variable">&#123;&#123; theme.typing_effect.colorful &#125;&#125;</span><span class="xml">;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    POWERMODE.shake = </span><span class="template-variable">&#123;&#123; theme.typing_effect.shake &#125;&#125;</span><span class="xml">;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'input'</span>, POWERMODE);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">      ...</span><br><span class="line">      &#123;% include '_third-party/exturl.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/bookmark.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/copy-code.swig' %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+     &#123;% include '_custom/custom.swig' %&#125;</span></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中添加以下代码：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># typing effect</span></span><br><span class="line"><span class="attr">typing_effect:</span></span><br><span class="line">  <span class="attr">colorful:</span> <span class="literal">true</span>  <span class="comment"># 礼花特效</span></span><br><span class="line">  <span class="attr">shake:</span> <span class="literal">false</span>  <span class="comment"># 震动特效</span></span><br></pre></td></tr></table></figure>

<p>如果从本地加载JS脚本速度较慢，可以考虑将脚本放到CDN上再引入。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本文记录了本站在Next的基础上的进阶美化方案，除了一些简单的样式修改外，还添加了一些由插件支持的高级动效，包括动态背景、看板娘、边缘摆动、鼠标点击和打字特效等。笔者认为，动效可以使得站点变有趣，但同时也会增加网页的资源消耗，以及影响用户的关注点，有时候会喧宾夺主适得其反，建议珍爱PC资源，合理使用动效。</p>
<p>本文内容仅涉及到主题美化，也就是说仅使得网页看起来更好看或者更炫酷，但并没有使其功能上变得更强大。如果你希望为站点集成更高级的功能，可以关注本系列的后续文章：</p>
<ul>
<li>想要深度定制个性化站点，请参考本系列中的 <a href="/2018/11/20/hexo-advanced-settings/" title="Hexo搭建个人博客系列：进阶设置篇">Hexo搭建个人博客系列：进阶设置篇</a>。</li>
<li>想要了解如何将站点部署到公网，请参考本系列中的 <a href="/2018/11/20/hexo-deploy-to-VPS/" title="Hexo搭建个人博客系列：部署上线篇">Hexo搭建个人博客系列：部署上线篇</a></li>
</ul>
<div class="reference-linking">参考链接</div>

<ul>
<li><a href="https://asdfv1929.github.io/2018/01/28/add-the-end/" target="_blank" rel="noopener">asdfv1929 | Hexo NexT主题内给每篇文章后添加结束标语</a></li>
<li><a href="https://fjkang.github.io/2017/12/08/%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%90%8C%E7%89%A9/" target="_blank" rel="noopener">FJKang | 添加一个萌物</a></li>
<li><a href="http://evanyou.me/" target="_blank" rel="noopener">尤雨溪的个人主页</a></li>
<li><a href="https://diygod.me/" target="_blank" rel="noopener">DIYgod的博客</a></li>
<li><a href="https://www.ofind.cn/" target="_blank" rel="noopener">猪猪侠的博客</a></li>
<li><a href="https://qianling.pw/hexo-optimization/" target="_blank" rel="noopener">千灵夙赋 | Hexo 优化汇总</a></li>
<li><a href="https://www.ilxtx.com/comment-input-effects.html" target="_blank" rel="noopener">龙笑天下 | 给 WordPress 博客网站添加评论输入打字礼花及震动特效</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客系列：写作技巧篇</title>
    <url>/2018/11/20/hexo-whirting-skills/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍 Hexo 博客的写作技巧。</p>
<p>第一章中介绍了 Hexo 中写作相关的基本概念，包括三种基本布局，标签与分类，Markdown 写作语法。</p>
<p>第二章中介绍了 Hexo 中常用的内置标签，包括 note 标签、 label 标签、 button 标签、 tab 标签以及代码块的高级用法，通过使用写作标签可以快速编写样式丰富的文档片段。</p>
<p>第三章中介绍了在文档中插入图片、音乐、视频等多媒体元素的方案。</p>
<p>第四章中根据个人使用经验为大家推荐了几款优雅实用的 Markdown 写作工具。</p>
<a id="more"></a>

<h1 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h1><p>在博客目录下执行如下命令新建一篇文章</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> [layout] &lt;<span class="built_in">title</span>&gt;</span><br></pre></td></tr></table></figure>

<p>如果未指定文章的布局（layout），则默认使用 <code>post</code> 布局，生成的文档存放于 <code>source\_posts\</code> 目录下，打开后使用Markdown语法进行写作，保存后刷新浏览器即可看到文章。</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局是什么概念呢，你可以理解为新建文档时的一个模板，基于布局生成的文档将会继承布局的样式。</p>
<p>Hexo默认有三种布局：<code>post</code>、 <code>page</code> 和 <code>draft</code>，用户可以在 <code>scaffolds</code> 目录下新建文档来自定义布局格式，还可以修改站点配置文件中的 <code>default_layout</code>参数来指定生成文档时的默认布局。</p>
<h3 id="文章（post）"><a href="#文章（post）" class="headerlink" title="文章（post）"></a>文章（post）</h3><p>基于 <code>post</code> 布局生成的文档存在于 <code>source\_posts\</code> 目录下，该目录下的文档会作为博客正文显示在网站中。</p>
<h3 id="页面（page）"><a href="#页面（page）" class="headerlink" title="页面（page）"></a>页面（page）</h3><p><code>page</code> 布局用于生成类似 <strong>首页</strong> 和 <strong>归档</strong> 这样的页面。默认的Next主题样式中只包含首页和归档这两个链接，可以通过修改主题配置文件中的 <code>menu</code> 字段来新增更多页面菜单。</p>
<figure class="highlight diff"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line"><span class="addition">+ tags: /tags/ || tags</span></span><br><span class="line"><span class="addition">+ categories: /categories/ || th</span></span><br><span class="line"><span class="addition">+ archives: /archives/ || archive</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>||</code> 之前的值表示菜单链接，之后的值表示所用的 <code>FontAwesome</code> 图标名称。</p>
<p>刷新页面后即可看到页面内多了几项菜单。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-writing-skills/20181103115805642.png" alt="新增菜单入口" title="新增菜单入口"></p>
<p>此时点击 <strong>关于</strong>、<strong>标签</strong> 和 <strong>分类</strong> 都会跳转到404页面，原因是我们只开放了页面入口，却没有创造对应于链接的页面视图，此时就需要通过 <code>hexo new page &lt;title&gt;</code> 命令来新建页面。</p>
<p>基于 <code>page</code> 布局的新建命令将会在 <code>source</code> 目录下新建一个 <code>&lt;title&gt;</code> 文件夹，并在该文件夹下创建一个 <code>index.md</code> 文件，编辑该文件即可修改页面内容。</p>
<p>例如，通过 <code>hexo new page tags</code> 命令将会生成如下目录。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">└──  <span class="keyword">source</span>             </span><br><span class="line">  ├── _posts          </span><br><span class="line">  └── <span class="keyword">tags</span></span><br><span class="line">    └── <span class="built_in">index</span>.md</span><br></pre></td></tr></table></figure>

<p>编辑 <code>index.md</code> 文件，在Front-Matter中添加 <code>type: tags</code> ，Next主题将自动在该页面内显示标签云。</p>
<figure class="highlight diff"><figcaption><span>source\tags\index.md</span></figcaption><table><tr><td class="code"><pre><span class="line">  title: 标签</span><br><span class="line">  date: 2018-10-19 22:57:00</span><br><span class="line"><span class="addition">+ type: tags</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>Front-Matter是文件最上方以 <code>---</code> 分隔的区域，用于指定本文件的各种参数值</p>
          </div>

<p>在菜单中点击 <strong>标签</strong> 跳转到刚创建的标签页面。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-writing-skills/20181104120213426.png" alt="Hexo 标签页面" title="Hexo 标签页面"></p>
<p>同理可通过 <code>page</code> 布局生成 <strong>关于</strong> 和 <strong>分类</strong> 两个页面。</p>
<h3 id="草稿（draft）"><a href="#草稿（draft）" class="headerlink" title="草稿（draft）"></a>草稿（draft）</h3><p><code>draft</code> 布局用于创建草稿，生成的文档存在于 source\_drafts\ 目录中，默认配置下将不会把该目录下的文档渲染到网站中。</p>
<p>通过以下命令将草稿发布为正式文章：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ hexo publish <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该命令会将 source\_drafts\ 目录下以 <title> 开头的草稿发布到 sources\_posts\ 目录下。另外，<code>hexo publish *</code> 会将最新创建的一篇草稿发布为正式文章，并以Front-Matter中的title作为文件名称。</title></p>
<p>考虑到一些文章可能需要数天才能完成，建议将新建文档时的默认布局设置为 <code>draft</code>：</p>
<figure class="highlight diff"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="deletion">- default_layout: post</span></span><br><span class="line"><span class="addition">+ default_layout: draft</span></span><br></pre></td></tr></table></figure>

<h2 id="标签与分类"><a href="#标签与分类" class="headerlink" title="标签与分类"></a>标签与分类</h2><p>我们刚提到了标签，也提到了分类，那么标签和分类是什么，其区别是什么。</p>
<p>标签和分类都是用于对文章进行归档的一种方式，标签是一种列表结构，而分类是一种树结构。我们以人作为例子，从标签的角度考虑，我可以拥有程序员、高颜值、幽默等标签，这些标签之间没有层级关系；从分类的角度考虑，我是亚洲人、中国人、河南人，这些分类之间是有明确的包含关系的。</p>
<p>可以在Front-Matter中添加 <code>catergories</code> 和 <code>tags</code> 字段为文章添加标签和分类，如我为本文添加了 <strong>Hexo</strong> 和 <strong>Markdown</strong> 两个标签，并将其归类到了 <strong>技术/博客</strong> 类别，对应的Front-Matter结构如下：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">title: Hexo搭建个人博客系列：写作技巧篇</span><br><span class="line"><span class="keyword">tags:</span> Hexo Markdown</span><br><span class="line">categories:</span><br><span class="line">- 技术</span><br><span class="line">- 博客</span><br></pre></td></tr></table></figure>

<h2 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h2><p>Markdown是一种标记语言，语法简单，易阅读易编写，可以让用户完全脱离鼠标写出样式丰富的文档，广受程序员喜爱，目前许多网站都已经支持通过Markdown语法来写文章或者发表评论。</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>Markdown语法</th>
<th>效果预览</th>
</tr>
</thead>
<tbody><tr>
<td>标题</td>
<td><code># 标题1</code><br><code>## h2</code><br><code>### h3</code></td>
<td><div style="font-weight: bold"><div style="font-size: 24px">标题一</div><div style="font-size: 22px">标题二</div><div style="font-size: 20px">标题三</div></div></td>
</tr>
<tr>
<td>加粗</td>
<td><code>**文字加粗**</code></td>
<td><strong>文字加粗</strong></td>
</tr>
<tr>
<td>引用</td>
<td><code>&gt; 引用文字</code></td>
<td><blockquote>引用文字</blockquote></td>
</tr>
<tr>
<td>有序列表</td>
<td><code>1. 第一项</code><br><code>2. 第二项</code><br><code>3. 第三项</code></td>
<td><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></td>
</tr>
<tr>
<td>无序列表</td>
<td><code>- 第一项</code><br><code>- 第二项</code><br><code>- 第三项</code></td>
<td><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></td>
</tr>
<tr>
<td>链接</td>
<td><code>[链接](url)</code></td>
<td><a href="url">链接</a></td>
</tr>
<tr>
<td>图片</td>
<td><code>![图片](image.jpg)</code></td>
<td><i class="fa fa-image"></i></td>
</tr>
<tr>
<td>水平线</td>
<td><code>---</code></td>
<td><hr></td>
</tr>
<tr>
<td>代码</td>
<td><code>`code`</code></td>
<td><code>code</code></td>
</tr>
<tr>
<td>代码块</td>
<td><code>```code snippet```</code></td>
<td><figure class="highlight"><table><tbody><tr><td class="code"><pre>code snippet</pre></td></tr></tbody></table></figure></td>
</tr>
</tbody></table>
<div class="note info">
            <p>更多语法请参考 <a href="https://www.markdownguide.org/basic-syntax" target="_blank" rel="noopener">基础语法 | Markdown Guide</a> 和 <a href="https://www.markdownguide.org/extended-syntax" target="_blank" rel="noopener">扩展语法 | Markdown Guide</a></p>
          </div>

<h1 id="Hexo内置标签"><a href="#Hexo内置标签" class="headerlink" title="Hexo内置标签"></a>Hexo内置标签</h1><div class="note info">
            <p>本章节参考 <a href="https://almostover.ru/2016-01/hexo-theme-next-test/" target="_blank" rel="noopener">Ivan.nginx | Hexo Theme Next主题样式测试</a> 及 <a href="https://theme-next.iissnan.com/tag-plugins.html" target="_blank" rel="noopener">内置标签 - NexT 使用文档</a></p>
          </div>

<h2 id="文本居中标签"><a href="#文本居中标签" class="headerlink" title="文本居中标签"></a>文本居中标签</h2><p>居中标签效果如下：</p>
<blockquote class="blockquote-center"><p>我不去想是否能够成功，既然选择了远方，便只顾风雨兼程。</p>
</blockquote>

<p>一般在引用单行文本时使用，如作为文章开篇题词。</p>
<p>可以通过以下几种方式使用该标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其中 class="blockquote-center" 是必须的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">class</span>=<span class="string">"blockquote-center"</span>&gt;</span>blah blah blah<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 标签方式 --&gt;</span></span><br><span class="line">&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 标签别名 --&gt;</span></span><br><span class="line">&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码块进阶用法"><a href="#代码块进阶用法" class="headerlink" title="代码块进阶用法"></a>代码块进阶用法</h2><p>可以通过为代码块附加参数的形式为其添加更丰富的信息提示，效果如下：</p>
<figure class="highlight js"><figcaption><span>Hellow World</span><a href="http://yearito.cn" target="_blank" rel="noopener">链接地址</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>);</span><br></pre></td></tr></table></figure>

<p>代码块进阶语法规则：</p>
<div style="background-color: #f7f7f7; margin: 20px 0; padding: 10px;border-radius: 5px; font-family: consolas;">
  &#x60;&#x60;&#x60; [language] [title] [url] [link text]<br>
  code snippet <br>
  &#x60;&#x60;&#x60;
</div>

<p>其中，各参数意义如下：</p>
<ul>
<li>langugae：语言名称，引导渲染引擎正确解析并高亮显示关键字</li>
<li>title：代码块标题，将会显示在左上角</li>
<li>url：链接地址，如果没有指定link text则会在右上角显示link</li>
<li>link text：链接名称，指定url后有效，将会显示在右上角</li>
</ul>
<p>url 必须为有效链接地址才会以链接的形式显示在右上角，否则将作为标题显示在左上角。以url为分界，左侧除了第一个单词会被解析为language，其他所有单词都会被解析为title，而右侧的所有单词都会被解析为link text。</p>
<p>如果不想填写title，可以在language和url之间添加至少三个空格。</p>
<div class="note info">
            <p>代码块支持多种语言高亮预设，详细的语言列表可查看<a href="https://almostover.ru/2016-07/hexo-highlight-code-styles/" target="_blank" rel="noopener">Ivan.nginx | Hexo代码块中的颜色方案</a>。</p>
          </div>

<p>可以在站点配置文件中设置 <code>highlight.auto_detect: true</code> 来开启自动语言检测高亮。</p>
<figure class="highlight diff"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"> highlight:</span><br><span class="line">   enable: true</span><br><span class="line">   line_number: false</span><br><span class="line"><span class="deletion">-  auto_detect: false</span></span><br><span class="line"><span class="addition">+  auto_detect: true</span></span><br><span class="line">   tab_replace:</span><br></pre></td></tr></table></figure>

<p>如果设置语言为diff，可以在代码前添加 <code>+</code> 和 <code>-</code> 来使用如上所示的高亮增删行提示效果，在展示代码改动痕迹时比较实用。</p>
<div class="note info">
            <p>更多代码块高亮的个性化设置请参见 <a href="https://www.ofind.cn/blog/HEXO/HEXO%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E6%8B%93%E5%B1%95%E4%BF%AE%E6%94%B9.html#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E6%A0%87%E8%AE%B0" target="_blank" rel="noopener">猪猪侠 | Hexo下的语法高亮拓展修改</a></p>
          </div>

<h2 id="note标签"><a href="#note标签" class="headerlink" title="note标签"></a>note标签</h2><p>通过note标签可以为段落添加背景色，语法如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="built_in"> note </span>[class] %&#125;</span><br><span class="line">文本内容 (支持行内标签)</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>支持的class种类包括 <code>default</code> <code>primary</code> <code>success</code> <code>info</code> <code>warning</code> <code>danger</code>，也可以不指定class。</p>
<p>各种class种类的效果如下：</p>
<div class="note primary">
            <p><strong>primary</strong> note tag</p>
          </div>

<div class="note success">
            <p><strong>success</strong> note tag</p>
          </div>

<div class="note info">
            <p><strong>info</strong> note tag</p>
          </div>

<div class="note warning">
            <p><strong>warning</strong> note tag</p>
          </div>

<div class="note danger">
            <p><strong>danger</strong> note tag</p>
          </div>

<div class="note ">
            <p>undefined class note tag</p>
          </div>

<p>更多配置可在主题配置文件中设置</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note 标签样式预设</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">modern</span>  <span class="comment"># simple | modern | flat | disabled</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span>  <span class="comment"># 是否显示图标</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span>  <span class="comment"># 圆角半径</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span>  <span class="comment"># 默认背景减淡效果，以百分比计算</span></span><br></pre></td></tr></table></figure>

<h2 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h2><p>通过label标签可以为文字添加背景色，语法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&#123;% label [<span class="class"><span class="keyword">class</span>]<span class="meta">@text</span>  %&#125;</span></span><br></pre></td></tr></table></figure>

<p>支持的class种类包括 <code>default</code> <code>primary</code> <code>success</code> <code>info</code> <code>warning</code> <code>danger</code>，默认使用 <code>default</code> 作为缺省。</p>
<p>使用示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I heard the echo, &#123;% label default@from the valleys and the heart %&#125;</span><br><span class="line">Open to the lonely soul of &#123;% label info@sickle harvesting %&#125;</span><br><span class="line">Repeat outrightly, but also repeat the well-being of</span><br><span class="line">Eventually &#123;% label warning@swaying in the desert oasis %&#125;</span><br><span class="line">&#123;% label success@I believe %&#125; I am</span><br><span class="line">&#123;% label primary@Born as the bright summer flowers %&#125;</span><br><span class="line">Do not withered undefeated fiery demon rule</span><br><span class="line">Heart rate and breathing to bear &#123;% label danger@the load of the cumbersome %&#125;</span><br><span class="line">Bored</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center"><p>I heard the echo, <span class="label default">from the valleys and the heart</span><br><br>Open to the lonely soul of <span class="label info">sickle harvesting</span><br><br>Repeat outrightly, but also repeat the well-being of<br><br>Eventually <span class="label warning">swaying in the desert oasis</span><br><br><span class="label success">I believe</span> I am <br><br><span class="label primary">Born as the bright summer flowers</span><br><br>Do not withered undefeated fiery demon rule<br><br>Heart rate and breathing to bear <span class="label danger">the load of the cumbersome</span><br><br>Bored</p>
</blockquote>

<p>可在主题配置文件中设置 <code>label: false</code> 来取消label标签默认CSS样式。</p>
<h2 id="button按钮"><a href="#button按钮" class="headerlink" title="button按钮"></a>button按钮</h2><p>通过button标签可以快速添加带有主题样式的按钮，语法如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&#123;% button /<span class="type">path</span>/<span class="keyword">to</span>/url/, <span class="type">text</span>, icon [<span class="keyword">class</span>], title %&#125;</span><br></pre></td></tr></table></figure>

<p>也可简写为：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&#123;% btn /<span class="type">path</span>/<span class="keyword">to</span>/url/, <span class="type">text</span>, icon [<span class="keyword">class</span>], title %&#125;</span><br></pre></td></tr></table></figure>

<p>其中， 图标ID来源于 <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">FontAwesome</a> 。</p>
<p>使用示例如下：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">btn</span> #, 文本 %&#125;</span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">btn</span> #, 文本 &amp; 标题,, 标题 %&#125;</span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">btn</span> #, 文本 &amp; 图标, home %&#125;</span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">btn</span> #, 文本 &amp; 大图标 (固定宽度), home fa-fw fa-lg %&#125;</span></span><br></pre></td></tr></table></figure>

<p><a class="btn" href="#">文本</a></p>
<p><a class="btn" href="#" title="标题">文本 & 标题</a></p>
<p><a class="btn" href="#"><i class="fa fa-home"></i>文本 & 图标</a></p>
<p><a class="btn" href="#"><i class="fa fa-home fa-fw fa-lg"></i>文本 & 大图标 (固定宽度)</a></p>

<h2 id="tab标签"><a href="#tab标签" class="headerlink" title="tab标签"></a>tab标签</h2><p>tab标签用于快速创建tab选项卡，语法如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% tabs [Unique name], [index] %&#125;</span><br><span class="line">  <span class="comment">&lt;!-- tab [Tab caption]@[icon] --&gt;</span></span><br><span class="line">  标签页内容（支持行内标签）</span><br><span class="line">  <span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<p>其中，各参数意义如下：</p>
<ul>
<li>Unique name: 全局唯一的Tab名称，将作为各个标签页的id属性前缀</li>
<li>index: 当前激活的标签页索引，如果未定义则默认选中显示第一个标签页，如果设为-1则默认隐藏所有标签页</li>
<li>Tab caption: 当前标签页的标题，如果不指定则会以Unique name加上索引作为标题</li>
<li>icon: 在标签页标题中添加Font awesome图标</li>
</ul>
<p>使用示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Tab标签列表 %&#125;</span><br><span class="line">  &lt;!-- tab 标签页1 --&gt;</span><br><span class="line">    标签页1文本内容</span><br><span class="line">  &lt;!-- endtab --&gt;</span><br><span class="line">  &lt;!-- tab 标签页2 --&gt;</span><br><span class="line">    标签页2文本内容</span><br><span class="line">  &lt;!-- endtab --&gt;</span><br><span class="line">  &lt;!-- tab 标签页3 --&gt;</span><br><span class="line">    标签页3文本内容</span><br><span class="line">  &lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<div class="tabs" id="tab标签列表"><ul class="nav-tabs"><li class="tab active"><a href="#tab标签列表-1">标签页1</a></li><li class="tab"><a href="#tab标签列表-2">标签页2</a></li><li class="tab"><a href="#tab标签列表-3">标签页3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab标签列表-1"><p>  标签页1文本内容</p></div><div class="tab-pane" id="tab标签列表-2"><p>  标签页2文本内容</p></div><div class="tab-pane" id="tab标签列表-3"><p>  标签页3文本内容</p></div></div></div>

<h2 id="引用站内链接"><a href="#引用站内链接" class="headerlink" title="引用站内链接"></a>引用站内链接</h2><p>可以通过如下语法引入站内文章的地址或链接：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">post_path</span> slug %&#125;</span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name">post_link</span> slug [title] %&#125;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>slug</code> 表示 <code>_post</code> 目录下的Markdown文件名。</p>
<p><code>post_path</code> 标签将会渲染为文章的地址，即 <code>permalink</code>；而 <code>post_link</code> 标签将会渲染为链接，可以通过 <code>title</code> 指定链接标题。</p>
<p>如以下标签将会生成 <code>/2018/11/20/hexo-whirting-skills/</code></p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">post_path</span> hexo-writing-skills %&#125;</span></span><br></pre></td></tr></table></figure>

<p>而以下标签则会生成 <a href="/2018/11/20/hexo-whirting-skills/" title="链接标题">链接标题</a></p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">post_link</span> hexo-writing-skills 链接标题 %&#125;</span></span><br></pre></td></tr></table></figure>

<p>这种站内引用方式比直接使用url引用的形式更为可靠，因为即使修改了 <code>permalink</code> 格式，或者修改了文章的路由地址，只要Markdown文件名没有发生改变，引用链接都不会失效。</p>
<h2 id="插入Swig代码"><a href="#插入Swig代码" class="headerlink" title="插入Swig代码"></a>插入Swig代码</h2><p>如果需要在页面内插入Swig代码，包括原生HTML代码，JavaScript脚本等，可以通过 raw 标签来禁止Markdown引擎渲染标签内的内容。语法如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&#123;%<span class="built_in"> raw </span>%&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>

<p>该标签通常用于在页面内引入三方脚本实现特殊功能，尤其是当该三方脚本尚无相关hexo插件支持的时候，可以通过写原生Web页面的形式引入脚本并编写实现逻辑。</p>
<h2 id="插入Gist"><a href="#插入Gist" class="headerlink" title="插入Gist"></a>插入Gist</h2><p>如果需要在页面内插入Gist上的代码片段时，可以使用如下标签:</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;% gist gist_id [filename] %&#125;</span><br></pre></td></tr></table></figure>

<p>其中，各参数意义如下：</p>
<ul>
<li>gist_id: Gist仓库页面url中最后一段随机字符串</li>
<li>filename: Gist中的文件名</li>
</ul>
<p>如果Gist中只有一个文件，可以不用指定filename，也可以通过JavaScript脚本的形式直接引入，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://gist.github.com/Coodool/cb4ff46a3523955dd4b918dd775b6774.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果Gist中有多个文件，可以在标签内输入filename来指定只引入某个文件，如果没有指定filename，将会引入Gist中的所有文件。另外，引用JavaScript脚本形式无法精确控制只引入某一个文件，将会同时引入Gist中的所有文件。</p>
<p>如果指定了与Gist无法匹配的filename，页面上将不会显示任何标签内容。所以，一般在Gist只有一个文件的情况下无需指定filename。</p>
<div class="note warning">
            <p>在页面中引入Gist代码段将会同时从github服务器上下载脚本与CSS样式文件，由于国内访问github服务器延迟较高，往往资源文件连接和下载的速度很慢，会阻塞页面的渲染进程导致短时白屏。</p>
          </div>

<h1 id="插入多媒体"><a href="#插入多媒体" class="headerlink" title="插入多媒体"></a>插入多媒体</h1><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>Markdown并不会保存插入的图片资源本身，只是记录了获取资源的链接。因此我们需要选择一款合适的图床来支持博客写作，目前各大云服务商都提供了对象存储服务，如七牛云KODO、又拍云USS、腾讯云COS、阿里云OSS等。</p>
<p>所以在Markdown中插入一张图片要分为以下几步来进行：</p>
<ol>
<li>将图片资源上传到图床中</li>
<li>获取图片外链</li>
<li>插入到Markdown文档中</li>
</ol>
<p>对于博客这种低频访问的应用场景，各大服务商的服务其实并没有显著的差异，并且前期的使用都提供了免费的流量，所以我认为图床的选择主要参考以下几个方面：</p>
<ul>
<li><p>图床是否提供了便捷的图形化管理工具用于图片的上传下载？</p>
<p>如阿里云有ossbrowser，腾讯云有cosbrowser，七牛云有QsunSync等，但就本人使用体验来说，七牛云QsunSync的UI界面确实很拙劣，功能较为单一，而腾讯云cosbrowser的界面就相对美观优雅的多，并以Windows资源管理器的交互方式为用户提供资源的上传、下载和管理服务。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-writing-skills/20181023103058966.png" alt="腾讯云COS客户端界面截图" title="腾讯云COS客户端界面截图"></p>
</li>
<li><p>是否能够方便的插入到Markdown文档中？</p>
<p>这就和服务商的关系不大了，主要看主流Markdown文档编辑器对各大图床的支持程度。其实关于在Markdown中更便捷的插入图片这事儿，最上心的还是文档编辑器的开发者，为了给用户提供更方便的文档写作体验，各大文档编辑器以及支持了Markdown语法的笔记软件都花了不少心思，解决方案无外乎两种，第一种是内置图片存储服务，如有道云笔记（需付费）、石墨文档，第二种是集成了云服务商的图床服务，如Hexo Editor、Mweb等，前者插入图片方便，适用于个人笔记，而后者能够提供CDN加速服务，适用于博客等公开文档。</p>
<p>其中Hexo Editor支持腾讯云和七牛云的一键上传服务，MWeb支持Imgur、七牛云、又拍云，也可自定义图床服务。</p>
</li>
</ul>
<div class="note info">
            <p>本站使用腾讯云COS提供对象存储服务。</p>
          </div>

<h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><p>在网页版云音乐中找到歌曲，点击生成外链播放器：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-writing-skills/20181104044431732.png" alt="获取歌曲外链" title="获取歌曲外链"></p>
<p>根据个人喜好选择播放器尺寸和播放模式：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-writing-skills/20181104044659251.png" alt="获取插件代码" title="获取插件代码"></p>
<p>将获取到的 <code>iframe</code> 代码添加到页面中，默认样式如下：</p>
<div class="fluid-vids" style="position: relative; margin-bottom: 20px; width: 100%; padding-top: 10.75%;"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="329" height="86" src="//music.163.com/outchain/player?type=2&amp;id=34613621&amp;auto=0&amp;height=66" style="width: 100%; height: 100%; position: absolute; top: 0px; left: 0px;">
</iframe></div>

<p>播放器宽度将会被拉长占满整个页宽，看起来有点别扭。查看控制台之后发现 <code>iframe</code> 在渲染的时候被处理过，外层包了一个类名为 <code>fluid-vids</code> 的 <code>div</code> 元素。顺藤摸瓜，找到了相关代码，原来是为了让嵌入的视频支持自适应布局，恰好也将 <code>music.163.com</code> 域名包含在了处理逻辑内，只需要将该行删除即可。</p>
<figure class="highlight js"><figcaption><span>themes\next\source\js\src\utils.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SUPPORTED_PLAYERS = [</span><br><span class="line">  <span class="string">'www.youtube.com'</span>,</span><br><span class="line">  <span class="string">'player.vimeo.com'</span>,</span><br><span class="line">  <span class="string">'player.youku.com'</span>,</span><br><span class="line">  <span class="comment">//'music.163.com',</span></span><br><span class="line">  <span class="string">'www.tudou.com'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>这样播放器样式就变成左对齐固定宽度了，如果你还想让播放器居中，可以将 <code>iframe</code> 包在 <code>&lt;center&gt;</code> 标签内。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">329</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=34613621&amp;auto=0&amp;height=66"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<center>
  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="329" height="86" src="//music.163.com/outchain/player?type=2&id=34613621&auto=0&height=66">
  </iframe>
</center>

<div class="note warning">
            <p>其实这种通过HTML标签实现CSS样式的做法并不合适，写前端代码的时候不推荐这么做，并且HTML5中也已经废除了 <code>&lt;center&gt;</code> <code>&lt;strong&gt;</code> 等纯粹为了改变样式而存在的HTML标签，HTML标签应该只负责文档结构，所有样式相关的工作应该交给CSS来实现。</p>
          </div>

<p>如果你发现播放器前后都有空行，可以在控制台中查看元素，检查 <code>iframe</code> 元素前后是否多了 <code>&lt;br&gt;</code> 元素：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-writing-skills/20181027111824579.png" alt="播放器前后空行代码" title="播放器前后空行代码"></p>
<p>造成这样的原因是Markdown渲染引擎把 <code>&lt;center&gt;</code> 标签和 <code>&lt;iframe&gt;</code> 标签之间的回车当作 <code>&lt;br&gt;</code> 来处理了。参考链接: <a href="https://github.com/hexojs/hexo/issues/1388" target="_blank" rel="noopener">Hexo issues #1388</a></p>
<p>简单的解决方案是将HTML标签写到一行内，但这样会降低代码可编辑性。</p>
<p>另外一种方案是在站点配置文件中添加如下代码：</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">gfm:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">breaks:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>重启服务器之后更改才会生效。</p>
<div class="note warning">
            <p>网易云音乐中部分歌曲因版权保护已经无法生成外链了，即使是通过控制台强行拿到外链地址，嵌入网页后也无法播放。</p>
          </div>

<h2 id="Aplayer音频播放器"><a href="#Aplayer音频播放器" class="headerlink" title="Aplayer音频播放器"></a>Aplayer音频播放器</h2><p><a href="https://aplayer.js.org/#/" target="_blank" rel="noopener">APlayer</a>是由 <a href="https://github.com/DIYgod" target="_blank" rel="noopener">DIYgod</a> 编写的HTML5音频播放器，提供了另一种音频播放方案。</p>
<div class="note ">
            <p>了解诞生背景： <a href="https://diygod.me/2167/" target="_blank" rel="noopener">APlayer - 送给小狐狸和小兔子的 HTML5 播放器</a></p>
          </div>

<p>借助 <a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">hexo-tag-aplayer</a> 插件，可以通过标签的形式方便快捷的插入音频组件。</p>
<p>在站点根目录下执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-tag-aplayer --save</span><br></pre></td></tr></table></figure>

<p>然后在页面中按照以下标签格式插入歌曲链接和相关信息：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;</span><br></pre></td></tr></table></figure>

<p>其中，各参数意义如下：</p>
<ul>
<li>title: 曲目标题</li>
<li>author: 曲目作者</li>
<li>url: 音乐文件 URL 地址</li>
<li>picture_url: (可选) 音乐对应的图片地址</li>
<li>narrow: （可选）播放器袖珍风格</li>
<li>autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能</li>
<li>width:xxx: (可选) 播放器宽度 (默认: 100%)</li>
<li>lrc:xxx: （可选）歌词文件 URL 地址</li>
</ul>
<p>示例效果如下：</p>

        <div id="aplayer-xHGNUNrI" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-xHGNUNrI"),
            narrow: false,
            autoplay: false,
            showlrc: 3,
            music: {
              title: "前前世世 -《君の名は。》",
              author: "RADWIMPS",
              url: "https://moeplayer.b0.upaiyun.com/aplayer/yourname.mp3",
              pic: "http://pic.5577.com/up/2016-12/201612891712576.png",
              lrc: "https://moeplayer.b0.upaiyun.com/aplayer/yourname.lrc"
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<p>当开启 Hexo 的 <a href="https://hexo.io/zh-cn/docs/asset-folders.html#%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%B9" target="_blank" rel="noopener">文章资源文件夹</a> 功能时，可以将图片、音乐文件、歌词文件放入与文章对应的资源文件夹中，然后直接引用，示例如下：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">&#123;<span class="meta">%</span> aplayer <span class="string">"Caffeine"</span> <span class="string">"Jeff Williams"</span> <span class="string">"caffeine.mp3"</span> <span class="string">"picture.jpg"</span> <span class="string">"lrc:caffeine.txt"</span> <span class="meta">%</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要统一实现固定宽度和居中样式，可以在自定义样式文件中添加如下样式规则</p>
<figure class="highlight css"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//Aplayer 播放器居中</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.aplayer</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span> auto;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>插入播放列表功能请参考： <a href="https://github.com/MoePlayer/hexo-tag-aplayer#with-playlist" target="_blank" rel="noopener">hexo-tag-aplayer | With playlist</a></p>
          </div>

<h2 id="Dpalyer视频播放器"><a href="#Dpalyer视频播放器" class="headerlink" title="Dpalyer视频播放器"></a>Dpalyer视频播放器</h2><p><a href="http://dplayer.js.org/#/" target="_blank" rel="noopener">DPlayer</a> 是一款简洁美观的HTML5视频播放器，同样出自 <a href="https://github.com/DIYgod" target="_blank" rel="noopener">DIYgod</a> 之手，支持弹幕互动。</p>
<div class="note ">
            <p>了解诞生背景： <a href="https://diygod.me/2648/" target="_blank" rel="noopener">DPlayer – 最好看的弹幕播放器送给最好看的宫园薰</a></p>
          </div>

<p>借助 <a href="https://github.com/MoePlayer/hexo-tag-dplayer" target="_blank" rel="noopener">hexo-tag-dplayer</a> 插件，可以通过标签的形式方便快捷的插入视频组件。</p>
<p>在站点根目录下执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-tag-dplayer --save</span><br></pre></td></tr></table></figure>

<p>然后在页面中按照以下标签格式插入歌曲链接和相关信息：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;% dplayer <span class="string">"url=video-url"</span> <span class="string">"pic=image-url"</span> ... [<span class="string">"key=value"</span>] %&#125;</span><br></pre></td></tr></table></figure>

<p>此处列举部分重要 <code>key</code> 的参数意义:</p>
<div class="tabs" id="tab标签列表"><ul class="nav-tabs"><li class="tab active"><a href="#tab标签列表-1">播放器</a></li><li class="tab"><a href="#tab标签列表-2">视频</a></li><li class="tab"><a href="#tab标签列表-3">字幕</a></li><li class="tab"><a href="#tab标签列表-4">弹幕</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab标签列表-1"><ul>
<li>autoplay：是否开启视频自动播放，默认为 <code>fasle</code></li>
<li>loop：是否开启视频循环播放，默认为 <code>false</code></li>
<li>screenshot：是否开启截图，默认为 <code>false</code></li>
<li>mutex：是否禁止多个播放器同时播放，默认为 <code>true</code></li>
<li>dmunlimited：是否开启海量弹幕模式，默认为 <code>false</code></li>
<li>preload：预加载模式，可选 <code>note</code> <code>metadata</code> <code>auto</code></li>
<li>theme：主题色</li>
<li>lang：语言，可选 <code>en</code> <code>zh-cn</code> <code>zh-tw</code></li>
<li>logo：左上角的Logo</li>
<li>volume：默认音量，默认为0.7</li>
<li>width：播放器宽度</li>
<li>height：播放器长度</li>
</ul></div><div class="tab-pane" id="tab标签列表-2"><ul>
<li>url：视频链接</li>
<li>pic：视频封面</li>
<li>thumbnails：视频缩略图，可以使用 <a href="https://github.com/MoePlayer/DPlayer-thumbnails" target="_blank" rel="noopener">DPlayer-thumbnails</a> 生成</li>
<li>vidtype：视频类型，可选 <code>auto</code> <code>hls</code> <code>flv</code> <code>dash</code> 或其他自定义类型</li>
</ul></div><div class="tab-pane" id="tab标签列表-3"><ul>
<li>suburl：字幕链接</li>
<li>subtype：字幕类型，可选 <code>webvtt</code> <code>ass</code>，目前只支持 <code>webvtt</code></li>
<li>subbottom：字幕距离播放器底部的距离，如 <code>10px</code> <code>10%</code></li>
<li>subcolor：字幕颜色</li>
</ul></div><div class="tab-pane" id="tab标签列表-4"><ul>
<li>id：弹幕id</li>
<li>api：弹幕api</li>
<li>token：弹幕后端验证 token</li>
<li>addition：额外外挂弹幕</li>
<li>dmuser：弹幕用户名</li>
<li>maximum：弹幕最大数量</li>
</ul></div></div></div>

<p>示例效果如下：</p>
<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"screenshot":true,"video":{"url":"https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4","pic":"https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>

<p>也可以通过raw标签引入原生Dplayer以使用更多配置项，示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dplayer"</span> <span class="attr">className</span>=<span class="string">"dplayer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">class</span>=<span class="string">"dplayer-css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> dp = <span class="keyword">new</span> DPlayer(&#123;</span></span><br><span class="line"><span class="javascript">    container: <span class="built_in">document</span>.querySelector(<span class="string">'#dplayer'</span>),</span></span><br><span class="line"><span class="actionscript">    autoplay: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">    theme: <span class="string">'#FADFA3'</span>,</span></span><br><span class="line"><span class="actionscript">    loop: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">    screenshot: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">    hotkey: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">    logo: <span class="string">'logo.png'</span>,</span></span><br><span class="line">    volume: 0.7,</span><br><span class="line"><span class="actionscript">    mutex: <span class="literal">true</span>,</span></span><br><span class="line">    video: &#123;</span><br><span class="line"><span class="actionscript">      url: <span class="string">'demo.mp4'</span>,</span></span><br><span class="line"><span class="actionscript">      pic: <span class="string">'demo.png'</span>,</span></span><br><span class="line"><span class="actionscript">      thumbnails: <span class="string">'thumbnails.jpg'</span>,</span></span><br><span class="line"><span class="actionscript">      type: <span class="string">'auto'</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    subtitle: &#123;</span><br><span class="line"><span class="actionscript">      url: <span class="string">'webvtt.vtt'</span>,</span></span><br><span class="line"><span class="actionscript">      type: <span class="string">'webvtt'</span>,</span></span><br><span class="line"><span class="actionscript">      fontSize: <span class="string">'25px'</span>,</span></span><br><span class="line"><span class="actionscript">      bottom: <span class="string">'10%'</span>,</span></span><br><span class="line"><span class="actionscript">      color: <span class="string">'#b7daff'</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    danmaku: &#123;</span><br><span class="line"><span class="actionscript">      id: <span class="string">'demo'</span>,</span></span><br><span class="line"><span class="actionscript">      api: <span class="string">'https://api.prprpr.me/dplayer/'</span>,</span></span><br><span class="line"><span class="actionscript">      token: <span class="string">'demo'</span>,</span></span><br><span class="line">      maximum: 3000,</span><br><span class="line"><span class="actionscript">      user: <span class="string">'DIYgod'</span>,</span></span><br><span class="line">      margin: &#123;</span><br><span class="line"><span class="actionscript">        bottom: <span class="string">'15%'</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="actionscript">      unlimited: <span class="literal">true</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    contextmenu: [</span><br><span class="line">      &#123;</span><br><span class="line"><span class="actionscript">        text: <span class="string">'custom contextmenu'</span>,</span></span><br><span class="line"><span class="actionscript">        link: <span class="string">'https://github.com/MoePlayer/DPlayer'</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>更多配置参数请参考 <a href="http://dplayer.js.org/#/zh-Hans/?id=%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">Dplayer 官方中文文档</a></p>
          </div>

<h1 id="写作工具"><a href="#写作工具" class="headerlink" title="写作工具"></a>写作工具</h1><p>Hexo写作必备一款好用的Markdown文档编辑器，下面推荐几款我比较喜欢的。</p>
<h2 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title="Sublime Text 3"></a>Sublime Text 3</h2><p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-writing-skills/20181106041459974.png" alt="Sublime Text 3 用户界面" title="Sublime Text 3 用户界面"></p>
<p>Sublime Text 3 是一款轻量级的文档编辑器，响应速度极快，社区活跃，主题插件也很丰富，在Windows下可以取代记事本成为默认的文档编辑器，也可以通过集成不同的编程依赖包成为功能强大的IDE，还可以搭配上Markdown插件成为网络作家的写作工具。</p>
<p>推荐两个比较实用的Markdown写作插件：Markdown Editing和OmniMarkupPreviewer。</p>
<h3 id="Markdown-Editing"><a href="#Markdown-Editing" class="headerlink" title="Markdown Editing"></a><a href="https://github.com/SublimeText-Markdown/MarkdownEditing" target="_blank" rel="noopener">Markdown Editing</a></h3><p>支持Markdown语法高亮，提供Markdown编辑的快捷键，提供多种主题样式。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Alt + V</td>
<td>在选中文本上创建行内链接或将剪贴板内容粘贴为所选文本的行内链接</td>
</tr>
<tr>
<td>Ctrl + Alt + R</td>
<td>在选中文本上创建参考式链接或将剪贴板内容粘贴为所选文本的参考式链接</td>
</tr>
<tr>
<td>Shift + Win + K</td>
<td>在选中文本上创建行内图片或将剪贴板内容粘贴为所选文本的行内图片</td>
</tr>
<tr>
<td>Alt + B</td>
<td>加粗强调，当未选中文本时默认加粗光标所在单词，再次按键取消加粗</td>
</tr>
<tr>
<td>Alt + I</td>
<td>斜体强调，当未选中文本时默认倾斜光标所在单词，再次按键取消斜体</td>
</tr>
<tr>
<td>Ctrl + 1~6</td>
<td>在空行上添加对应数字级别的标题，选中已有标题时按键可修改标题级别</td>
</tr>
<tr>
<td>Alt + Shift + 6</td>
<td>添加脚注</td>
</tr>
<tr>
<td>Shift + Tab</td>
<td>折叠/展开当前章节</td>
</tr>
<tr>
<td>Ctrl + Shift + Tab</td>
<td>折叠指定级别下的所有章节</td>
</tr>
<tr>
<td>Ctrl + Alt + Shift + PageUp/PageDown</td>
<td>跳转到上/下一个同级或更高级的其他标题</td>
</tr>
<tr>
<td>Ctrl + Shift + PageUp/PageDown</td>
<td>跳转到上/下一个标题</td>
</tr>
<tr>
<td>Ctrl + Shift + R</td>
<td>显示Markdown文件标题</td>
</tr>
</tbody></table>
<h3 id="OmniMarkupPreviewer"><a href="#OmniMarkupPreviewer" class="headerlink" title="OmniMarkupPreviewer"></a><a href="https://github.com/timonwong/OmniMarkupPreviewer" target="_blank" rel="noopener">OmniMarkupPreviewer</a></h3><p>用于在浏览器中实时预览Markdown文档，用户可以边在Sublime中写作边在浏览器中查看文档的实时变化，而不需要手动刷新浏览器。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Alt + O</td>
<td>在浏览器中预览</td>
</tr>
<tr>
<td>Ctrl + Alt + X</td>
<td>导出为HMTL</td>
</tr>
<tr>
<td>Ctrl + Alt + C</td>
<td>以HTML格式拷贝到剪贴板</td>
</tr>
</tbody></table>
<div class="note warning">
            <p>PlainTasks插件（一款Todo List工具）会与OmniMarkupPreviewer产生冲突，导致OmniMarkupPreviewer功能异常，如编辑后无法实时预览，<a href="https://github.com/timonwong/OmniMarkupPreviewer/issues/111" target="_blank" rel="noopener">资源样式加载错误</a> 等。如果不想卸载PlainTasks，可以在使用OmniMarkupPreviewer时暂时禁用PlainTasks，具体做法为在Sublime Text的User Settings中添加如下代码：</p>
          </div>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"ignored_packages":[</span><br><span class="line">  <span class="string">"PlainTasks"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h2 id="Hexo-Editor"><a href="#Hexo-Editor" class="headerlink" title="Hexo Editor"></a><a href="https://github.com/zhuzhuyule/HexoEditor" target="_blank" rel="noopener">Hexo Editor</a></h2><p>Hexo Editor是专为Hexo博客写作打造的文件编辑器，界面极简美观，支持实时预览，支持图片上传。</p>
<p><img src="https://raw.githubusercontent.com/zhuzhuyule/HexoEditor/master/screenshots/main.png" alt="Hexo Editor 用户界面" title="Hexo Editor 用户界面"></p>
<div class="note warning">
            <p>本人在实际使用过程中发现该软件功能不太稳定，插入图片有时候会卡顿，甚至出现程序崩溃的现象。</p>
          </div>

<h3 id="编辑快捷键"><a href="#编辑快捷键" class="headerlink" title="编辑快捷键"></a>编辑快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Tab</td>
<td>增加缩进</td>
</tr>
<tr>
<td>Shift + Tab</td>
<td>减少缩进</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>加粗</td>
</tr>
<tr>
<td>Ctrl + I</td>
<td>斜体</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>删除当前行</td>
</tr>
<tr>
<td>Ctrl + `</td>
<td>将当前单词标记为代码</td>
</tr>
<tr>
<td>Ctrl + L</td>
<td>插入无序列表</td>
</tr>
<tr>
<td>Ctrl + Alt + L</td>
<td>插入有序列表</td>
</tr>
<tr>
<td>Ctrl + ]</td>
<td>降低标题级别</td>
</tr>
<tr>
<td>Ctrl + [</td>
<td>提升标题级别</td>
</tr>
<tr>
<td>Ctrl + =</td>
<td>插入引用</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>插入链接</td>
</tr>
<tr>
<td>Ctrl + Alt + U</td>
<td>插入图片</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>插入表格</td>
</tr>
<tr>
<td>Ctrl + V</td>
<td>粘贴为纯文本（去除格式）</td>
</tr>
<tr>
<td>Shift + Ctrl + V</td>
<td>粘贴（保留源格式）</td>
</tr>
<tr>
<td>Alt + F</td>
<td>格式化表格</td>
</tr>
</tbody></table>
<h3 id="操作快捷键"><a href="#操作快捷键" class="headerlink" title="操作快捷键"></a>操作快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + N</td>
<td>新建Hexo文档</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>new hexo document</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>open md document</td>
</tr>
<tr>
<td>Ctrl + S</td>
<td>save md document</td>
</tr>
<tr>
<td>Shift + Ctrl + S</td>
<td>save as</td>
</tr>
<tr>
<td>Alt + Ctrl + S</td>
<td>open settings</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>toggle write mode</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>toggle preview mode</td>
</tr>
<tr>
<td>Ctrl + R</td>
<td>toggle read mode</td>
</tr>
</tbody></table>
<h2 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a>MWeb</h2><p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-writing-skills/20181023095629471.png" alt="Mweb 用户界面" title="Mweb 用户界面"></p>
<p>MWeb是Mac平台上一款专业的Markdown写作、记笔记、静态博客生成软件，支持图片上传。他的与众不同在于，除了具备一般Markdown编辑器所具有的一切基本功能之外，还支持以下特性：</p>
<ul>
<li>支持LaTeX公式、TOC</li>
<li>支持丰富的画图库，如mermaid、Graphviz、echarts、plantuml、流程图、时序图等</li>
<li>支持插入图片后自动上传到图床</li>
<li>拥有及其强大的发布功能，支持一键发布到各大博客平台和笔记软件中</li>
</ul>
<p>尽管拥有如此丰富的特性，但界面仍保持清爽简洁，开发者说到：</p>
<blockquote>
<p>原则上，首先是追求界面简洁和高性能，然后才是强大易用，功能全面。</p>
</blockquote>
<p>目前由oulvhai一人独自开发维护。</p>
<h2 id="Dillinger"><a href="#Dillinger" class="headerlink" title="Dillinger"></a><a href="https://dillinger.io/" target="_blank" rel="noopener">Dillinger</a></h2><p>一款优雅的在线Markdown编辑器，界面美观简洁。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-writing-skills/20181020114433264.png" alt="Dillinger 用户界面" title="Dillinger 用户界面"></p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本文介绍了Hexo博客的几项关键写作技巧，包括Markdown的基本语法，Hexo主题的内置标签等，本文还介绍了如何在文章中利用图床外链插入图片，如何利用Aplayer / Dplayer等音视频播放器插件在页面内插入多媒体元素等，并列举了几款写作工具以供选择，希望你能从中找到用起来最顺手的一款。如果你有更高级的个性化需求，你可以关注本系列的后续几篇文章：</p>
<ul>
<li>想要进一步美化主题，添加动效以及交互，请参考本系列中的 <a href="/2018/11/20/hexo-theme-beautiful/" title="Hexo搭建个人博客系列：主题美化篇">Hexo搭建个人博客系列：主题美化篇</a>。</li>
<li>想要深度定制个性化站点，请参考本系列中的 <a href="/2018/11/20/hexo-advanced-settings/" title="Hexo搭建个人博客系列：进阶设置篇">Hexo搭建个人博客系列：进阶设置篇</a>。</li>
<li>想要了解如何将站点部署到公网，请参考本系列中的 <a href="/2018/11/20/hexo-deploy-to-VPS/" title="Hexo搭建个人博客系列：部署上线篇">Hexo搭建个人博客系列：部署上线篇</a></li>
</ul>
<div class="reference-linking">参考链接</div>

<ul>
<li><a href="https://www.markdownguide.org/" target="_blank" rel="noopener">Markdown指南</a></li>
<li><a href="https://theme-next.iissnan.com/tag-plugins.html" target="_blank" rel="noopener">NexT使用文档 | 内置标签</a></li>
<li><a href="https://almostover.ru/2016-01/hexo-theme-next-test/" target="_blank" rel="noopener">Ivan.Nginx | Hexo Theme Next主题样式测试</a></li>
<li><a href="https://almostover.ru/2016-07/hexo-highlight-code-styles/" target="_blank" rel="noopener">Ivan.Nginx | Hexo代码块中的颜色方案</a></li>
<li><a href="https://www.ofind.cn/blog/HEXO/HEXO下的语法高亮拓展修改.html" target="_blank" rel="noopener">猪猪侠 | Hexo下的语法高亮拓展修改</a></li>
<li><a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md" target="_blank" rel="noopener">hexo-tag-aplayer | 中文文档</a></li>
<li><a href="https://github.com/MoePlayer/hexo-tag-dplayer" target="_blank" rel="noopener">hexo-tag-dplayer | README</a></li>
<li><a href="http://dplayer.js.org/#/zh-Hans/" target="_blank" rel="noopener">Dplayer 官方中文文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客系列：基础建站篇</title>
    <url>/2018/11/20/hexo-get-started/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Hexo 是一个高效简洁的静态博客框架，支持 Markdown 写作语法，插件丰富，主题优雅，部署方便。目前已成为多数人博客建站的选择。</p>
<a id="more"></a>

<p>本文为 Hexo 搭建个人博客系列中的第一篇。第一章中介绍了如何在本地搭建 Hexo 博客，第二章中介绍了如何安装使用 Next 主题，第三章和第四章分别介绍了针对于站点和文章详情页的一些基础优化方案。</p>
<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><p>在命令行中通过 npm 来安装 Hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p><code>-g</code> 表示全局安装，会将 Hexo 命令加入环境变量中，以使其在 cmd 下有效。</p>
<div class="note info">
            <p>Hexo 依赖于 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a> 和 <a href="https://git-scm.com/download/" target="_blank" rel="noopener">git</a> ，所以在安装 Hexo 之前先确保已安装了这两项应用。</p>
          </div>

<p>新建博客目录，然后在该路径下执行初始化命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>官方教程中提到要在项目目录下执行 <code>npm install</code> 命令，事实上不必如此，在执行 <code>hexo init</code> 的过程中就已经自动安装好了项目依赖。</p>
          </div>

<p>执行完毕后，将会生成以下文件结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules       //依赖安装目录</span><br><span class="line">├── scaffolds          //模板文件夹，新建的文章将会从此目录下的文件中继承格式</span><br><span class="line">|   ├── draft.md         //草稿模板</span><br><span class="line">|   ├── page.md          //页面模板</span><br><span class="line">|   └── post.md          //文章模板</span><br><span class="line">├── source             //资源文件夹，用于放置图片、数据、文章等资源</span><br><span class="line">|   └── _posts           //文章目录</span><br><span class="line">├── themes             //主题文件夹</span><br><span class="line">|   └── landscape        //默认主题</span><br><span class="line">├── .gitignore         //指定不纳入git版本控制的文件</span><br><span class="line">├── _config.yml        //站点配置文件</span><br><span class="line">├── db.json            </span><br><span class="line">├── package.json</span><br><span class="line">└── package-lock.json</span><br></pre></td></tr></table></figure>

<p>在根目录下执行如下命令启动 hexo 的内置 Web 服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>该命令将会调用 Markdown 引擎解析项目中的博客内容生成网页资源，资源将会存于内存中，所以用户执行完命令之后在项目文件夹中是找不到相关的 Web 资源目录的。该命令还会启动一个简易的 Web 服务器用于提供对内存中网页资源的访问（工作机制类似于 webpack-dev-server），Web 服务器默认监听4000端口，用户可在浏览器中通过地址 <code>localhost:4000</code> 访问博客。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-get-started/20181102070503130.png" alt="Hexo 默认主题首页" title="Hexo 默认主题首页"></p>
<p>此外，可以通过添加命令行参数来支持高级用法：</p>
<ul>
<li>当4000端口已被其他应用占用时，可以添加 <code>-p</code> / <code>--port</code> 参数来设置 Web 服务监听的端口号，如<code>hexo s -p 8000</code> ,这时访问地址为 <code>localhost:8000</code> 。</li>
<li>默认情况下，hexo 监听项目目录的文件变化，用户对于项目文件的任何改动都会触发实时解析编译并更新内存中的网页资源，也就是说，用户在本地修改后刷新浏览器就可以看到改动效果。如果不希望 hexo 监听项目目录的文件变化，可以添加 <code>-s</code> / <code>--static</code> 参数，这样本地改动就不会触发 hexo 实时解析更新。</li>
</ul>
<h1 id="更换Next主题"><a href="#更换Next主题" class="headerlink" title="更换Next主题"></a>更换Next主题</h1><p>Next 作为一款符合广大程序员审美的主题，还是有着较高的出场率的。Hexo 中切换主题的方式非常简单，只需要将主题文件拷贝至根目录下的 <code>themes</code> 文件夹中， 然后修改 <code>_config.yml</code> 文件中的 <code>theme</code> 字段即可。</p>
<p>在根目录下执行以下命令下载主题文件：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">$ git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/theme</span>-<span class="keyword">next</span>/hexo-theme-<span class="keyword">next</span>.git themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>注意！ Next 仓库已经从 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">iissnan/hexo-theme-next</a> 转移到了 <a href="https://github.com/theme-next/hexo-theme-next/releases" target="_blank" rel="noopener">theme-next/hexo-theme-next</a> ，并在新仓库中发布了 v7.5.0 版本，后续维护也将在新仓库中开展。如果你仍在使用旧仓库中的 Next 版本，可能会遇到各种 Bug 。</p>
          </div>

<p>打开站点配置文件，将 <code>theme</code> 字段的值修改为 <code>next</code>。</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>这个时候刷新浏览器页面并不会发生变化，需要重启服务器并刷新才能使主题生效。</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-get-started/20181102095611506.png" alt="Next 主题首页" title="Next 主题首页"></p>
<div class="note info">
            <p>如果重启服务器仍无效，尝试使用 <code>hexo clean</code> 清除缓存</p>
          </div>

<p>Next 默认主题风格为 Muse，用户可以在主题配置文件中修改 <code>scheme</code> 字段以选择自己喜欢的主题风格：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<h1 id="站点优化"><a href="#站点优化" class="headerlink" title="站点优化"></a>站点优化</h1><p>根目录下的 _config.yml 文件负责站点的相关配置，用户可以通过修改该文件来自定义站点内容或功能，修改后需要重启服务器才能看到效果。</p>
<p>本节通过修改站点配置文件完善了网站标题、网站描述、社交链接、站点版权信息、友情链接等，效果如下图：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-get-started/Snipaste_2018-11-17_17-01-51.png" alt="站点概览" title="站点概览"></p>
<h2 id="完善站点基础信息"><a href="#完善站点基础信息" class="headerlink" title="完善站点基础信息"></a>完善站点基础信息</h2><p>在站点配置文件中完善网站基本信息：</p>
<blockquote>
<p>文件位置：~/blog/_config.yml</p>
</blockquote>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Time</span> <span class="bullet">-</span> <span class="string">Container</span>  <span class="comment"># 站点名称</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">Stay</span> <span class="string">hungry,</span> <span class="string">stay</span> <span class="string">foolish.</span>  <span class="comment"># 站点描述</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># 设置网站语言为简体中文</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">staySimple</span>  <span class="comment"># 作者名称</span></span><br></pre></td></tr></table></figure>

<p>每个字段的冒号与值之间需要 <strong>间隔一个空格</strong>。</p>
<h2 id="首页显示文章摘要"><a href="#首页显示文章摘要" class="headerlink" title="首页显示文章摘要"></a>首页显示文章摘要</h2><p>根据默认的主题配置，首页将会显示每一篇文章的全文，如果想要只显示文章摘要，可以在主题配置文件中做出如下更改：</p>
<blockquote>
<p>文件位置：~/blog/themes/next/_config.yml</p>
</blockquote>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 开启自动摘要提取</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span>   <span class="comment"># 摘要长度</span></span><br></pre></td></tr></table></figure>

<p>此时将会从文章中提取150个字符作为摘要。</p>
<p>用户可以在文章中通过 <code>&lt;!-- more --&gt;</code> 标记来精确划分摘要信息，标记之前的段落将作为摘要显示在首页。</p>
<p>如果在文章的 Front-Matter 中有非空的 <code>description</code> 字段，则该字段的内容会被作为摘要显示在首页。</p>
<h2 id="修改站点页脚"><a href="#修改站点页脚" class="headerlink" title="修改站点页脚"></a>修改站点页脚</h2><p>在主题配置文件中修改网站页脚信息：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span>  <span class="comment"># 底部信息区</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span>  <span class="comment"># 建站时间</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">heart</span>   <span class="comment"># 图标名称</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span>   <span class="comment"># 开启动画</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">"#ff0000"</span>   <span class="comment"># 图标颜色</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 显示由 Hexo 强力驱动</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span>  <span class="comment"># 隐藏 Hexo 版本号</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 显示所用的主题名称</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span>  <span class="comment"># 隐藏主题版本号</span></span><br></pre></td></tr></table></figure>

<p>更改后效果如下：</p>
<p><img src="http://yearito-1256884783.image.myqcloud.com/hexo-get-started/20181102094925440.png" alt="站点页脚" title="站点页脚"></p>
<h2 id="修改网站-Favicon"><a href="#修改网站-Favicon" class="headerlink" title="修改网站 Favicon"></a>修改网站 Favicon</h2><p>Favicon 即浏览器标签左侧的图标。下载自己喜欢的图标置于 <code>themes\next\source\images\</code> 目录下，命名方式参考主题配置文件中的 <code>favicon</code> 字段。</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span>  <span class="comment"># 小图标</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span>  <span class="comment"># 大图标</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span>  <span class="comment"># 苹果图标</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span>  <span class="comment"># safari浏览器标签页图标</span></span><br></pre></td></tr></table></figure>

<h2 id="添加友链"><a href="#添加友链" class="headerlink" title="添加友链"></a>添加友链</h2><p>在主题配置文件中修改相应字段：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">links_icon:</span> <span class="string">link</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">友情链接</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">inline</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">yearito:</span> <span class="string">http://yearito.cn/</span></span><br></pre></td></tr></table></figure>

<h2 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h2><p>用户可以在主题配置文件中根据样例提示添加个人社交软件链接：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/yourname</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:yourname@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line">  <span class="attr">Weibo:</span> <span class="string">https://weibo.com/yourname</span> <span class="string">||</span> <span class="string">weibo</span></span><br><span class="line">  <span class="attr">Google:</span> <span class="string">https://plus.google.com/yourname</span> <span class="string">||</span> <span class="string">google</span></span><br><span class="line">  <span class="attr">Twitter:</span> <span class="string">https://twitter.com/yourname</span> <span class="string">||</span> <span class="string">twitter</span></span><br><span class="line">  <span class="attr">FB Page:</span> <span class="string">https://www.facebook.com/yourname</span> <span class="string">||</span> <span class="string">facebook</span></span><br><span class="line">  <span class="attr">VK Group:</span> <span class="string">https://vk.com/yourname</span> <span class="string">||</span> <span class="string">vk</span></span><br><span class="line">  <span class="attr">StackOverflow:</span> <span class="string">https://stackoverflow.com/yourname</span> <span class="string">||</span> <span class="string">stack-overflow</span></span><br><span class="line">  <span class="attr">YouTube:</span> <span class="string">https://youtube.com/yourname</span> <span class="string">||</span> <span class="string">youtube</span></span><br><span class="line">  <span class="attr">Instagram:</span> <span class="string">https://instagram.com/yourname</span> <span class="string">||</span> <span class="string">instagram</span></span><br><span class="line">  <span class="attr">Skype:</span> <span class="string">skype:yourname?call|chat</span> <span class="string">||</span> <span class="string">skype</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span>   </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 显示社交软件图标</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span>  <span class="comment"># 显示图标的同时显示文字</span></span><br></pre></td></tr></table></figure>

<p>如果要取消社交图标前的小圆点，可以在自定义样式文件中添加如下样式规则：</p>
<figure class="highlight css"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//隐藏社交图标前的圆点</span><br><span class="line"><span class="selector-class">.links-of-author</span> <span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-class">.links-of-author</span> <span class="selector-class">.exturl</span> &#123;</span><br><span class="line">  &amp;:before &#123;</span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">none</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加版权协议"><a href="#添加版权协议" class="headerlink" title="添加版权协议"></a>添加版权协议</h2><p>在主题配置文件中开启相关字段并选择知识共享协议：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h2 id="点击头像回到首页"><a href="#点击头像回到首页" class="headerlink" title="点击头像回到首页"></a>点击头像回到首页</h2><div class="note info">
            <p>本章节参考 <a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">reuixiy | 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化#5.13</a></p>
          </div>

<p>修改侧边栏模板代码:</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\sidebar.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &#123;% if theme.avatar.url %&#125;</span><br><span class="line"><span class="addition">+   &lt;a href="/"&gt;</span></span><br><span class="line">      &lt;img class="site-author-image" itemprop="image"</span><br><span class="line">        src="&#123;&#123; url_for( theme.avatar.url | default(theme.images + '/avatar.gif') ) &#125;&#125;"</span><br><span class="line">        alt="&#123;&#123; author &#125;&#125;" /&gt;</span><br><span class="line"><span class="addition">+   &lt;/a&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文章页优化"><a href="#文章页优化" class="headerlink" title="文章页优化"></a>文章页优化</h1><p>主题目录下的 themes\next\_config.yml 文件负责与主题相关的配置，用户可以通过修改该文件来自定义与主题相关的内容或功能，修改后刷新浏览器即可即时生效。</p>
<h2 id="修改文章目录导航"><a href="#修改文章目录导航" class="headerlink" title="修改文章目录导航"></a>修改文章目录导航</h2><h3 id="取消数字编号"><a href="#取消数字编号" class="headerlink" title="取消数字编号"></a>取消数字编号</h3><p>在主题配置文件中关闭目录中的数字编号：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span>  <span class="comment"># 关闭目录中的数字编号</span></span><br></pre></td></tr></table></figure>

<p>这里建议不关闭目录中的数字编号</p>
<h3 id="展开全部目录层级"><a href="#展开全部目录层级" class="headerlink" title="展开全部目录层级"></a>展开全部目录层级</h3><p>默认情况下文章的多级目录是折叠的，点击才会触发下级菜单的展开，并且同时只能展开一个目录分支，这会造成在点击不同目录标题的时候目录跳来跳去。如果你想实现默认展开全部目录的功能，可以在自定义样式文件中添加以下代码：</p>
<figure class="highlight css"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//TOC目录默认全部展开</span><br><span class="line"><span class="selector-class">.post-toc</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认展开两级目录"><a href="#默认展开两级目录" class="headerlink" title="默认展开两级目录"></a>默认展开两级目录</h3><p>通常文章内会出现多级标题，对应的目录里就会有多级导航出现，这时候一些原本你不希望出现的次要标题也会在目录中出现并且无法折叠。可以通过以下样式实现默认只展开两级目录，这样一来就通过一个折中的方案完美解决了目录折叠的问题。</p>
<figure class="highlight css"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//TOC目录默认展开两级</span><br><span class="line"><span class="selector-class">.post-toc</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-level-1</span>&gt;<span class="selector-class">.nav-child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="只显示两级目录"><a href="#只显示两级目录" class="headerlink" title="只显示两级目录"></a>只显示两级目录</h3><p>如果你根本不想让三级及以上的标题出现TOC导航目录中，可以考虑在自定义样式文件中添加以下代码：</p>
<figure class="highlight css"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//TOC目录默认只显示两级目录</span><br><span class="line"><span class="selector-class">.nav-level-2</span> &gt; <span class="selector-class">.nav-child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主动隐藏文章目录"><a href="#主动隐藏文章目录" class="headerlink" title="主动隐藏文章目录"></a>主动隐藏文章目录</h3><p>如果你写了一篇并不算长的文章，没有层层嵌套的多级目录结构，此时侧边的文章目录空荡荡的就有点鸡肋了。修改侧边栏布局模板中的相关逻辑代码：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\sidebar.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &#123;% set display_toc = is_post and theme.toc.enable %&#125;</span></span><br><span class="line"><span class="addition">+ &#123;% set display_toc = is_post and theme.toc.enable and not page.hide_toc %&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后就可在 Front-Matter 中设定变量 hide_toc 用于控制是否隐藏侧边目录。</p>
<h2 id="修改文章-meta-信息"><a href="#修改文章-meta-信息" class="headerlink" title="修改文章 meta 信息"></a>修改文章 meta 信息</h2><p>默认主题配置中，标题下方会显示文章的创建时间、文章的修改时间、文章分类信息等元数据，用户可以在主题配置文件中自定义设置需要显示的 meta 信息：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span>  <span class="comment"># 显示文字说明</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span>  <span class="comment"># 显示文章创建时间</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span>  <span class="comment"># 隐藏文章修改时间</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span>  <span class="comment"># 只有当修改时间和创建时间不是同一天的时候才显示</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">false</span>  <span class="comment"># 隐藏分类信息</span></span><br></pre></td></tr></table></figure>

<h2 id="中英文之间自动添加空格"><a href="#中英文之间自动添加空格" class="headerlink" title="中英文之间自动添加空格"></a>中英文之间自动添加空格</h2><p>该功能由 <a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">pangu</a>  提供，在 Next v7.5.0 版本中集成了插件到项目中，如果使用只需在主题配置文件中设置 <code>pangu: true</code> 即可启用该动能。</p>
<div class="note warning">
            <p>不推荐使用 hexo-filter-auto-spacing 实现该功能，该插件会导致目录中带有中英文的标题失效，无法跳转到文章指定章节。</p>
          </div>

<h2 id="修正文末导航跳转逻辑"><a href="#修正文末导航跳转逻辑" class="headerlink" title="修正文末导航跳转逻辑"></a>修正文末导航跳转逻辑</h2><div class="note info">
            <p>本章节参考 <a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">reuixiy | 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化#5.2</a></p>
          </div>

<p>如果不是看到 reuixiy 的文章，可能一辈子都不会注意到这个奇葩的逻辑：文章底部的左侧/右侧箭头分别导航到更旧/更新的文章链接，就好像你在手机相册里左滑却看到了更久以前的照片，细细想想这个逻辑毫无社会主义可言，至少没有中国特色。</p>
<p>修改文章布局模板：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% if not is_index and (post.prev or post.next) %&#125;</span><br><span class="line">  &lt;div class="post-nav"&gt;</span><br><span class="line">    &lt;div class="post-nav-next post-nav-item"&gt;</span><br><span class="line"><span class="deletion">-      &#123;% if post.next %&#125;</span></span><br><span class="line"><span class="addition">+      &#123;% if post.prev %&#125;</span></span><br><span class="line"><span class="deletion">-        &lt;a href="&#123;&#123; url_for(post.next.path) &#125;&#125;" rel="next" title="&#123;&#123; post.next.title &#125;&#125;"&gt;</span></span><br><span class="line"><span class="addition">+        &lt;a href="&#123;&#123; url_for(post.prev.path) &#125;&#125;" rel="prev" title="&#123;&#123; post.prev.title &#125;&#125;"&gt;</span></span><br><span class="line"><span class="deletion">-          &lt;i class="fa fa-chevron-left"&gt;&lt;/i&gt; &#123;&#123; post.next.title &#125;&#125;</span></span><br><span class="line"><span class="addition">+          &lt;i class="fa fa-chevron-left"&gt;&lt;/i&gt; &#123;&#123; post.prev.title &#125;&#125;</span></span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;span class="post-nav-divider"&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class="post-nav-prev post-nav-item"&gt;</span><br><span class="line"><span class="deletion">-      &#123;% if post.prev %&#125;</span></span><br><span class="line"><span class="addition">+      &#123;% if post.next %&#125;</span></span><br><span class="line"><span class="deletion">-        &lt;a href="&#123;&#123; url_for(post.prev.path) &#125;&#125;" rel="prev" title="&#123;&#123; post.prev.title &#125;&#125;"&gt;</span></span><br><span class="line"><span class="addition">+        &lt;a href="&#123;&#123; url_for(post.next.path) &#125;&#125;" rel="next" title="&#123;&#123; post.next.title &#125;&#125;"&gt;</span></span><br><span class="line"><span class="deletion">-          &#123;&#123; post.prev.title &#125;&#125; &lt;i class="fa fa-chevron-right"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+          &#123;&#123; post.next.title &#125;&#125; &lt;i class="fa fa-chevron-right"&gt;&lt;/i&gt;</span></span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><div class="note info">
            <p>不同版本的 Hexo 和 Next 主题之间配置项可能存在差异，本系列文章中的配置有效性以 Hexo v3.7.1和 Next v6.4.2 为准。</p>
          </div>

<p>至此你已经在本地搭建起了 Hexo 博客，更换到了 Next 主题，并对站点进行了一些基本的自定义配置，看起来已经是一个可以正常使用的站点了。但可能仅仅这样还无法满足你的高级需求，你可以关注本系列的后续几篇文章，将分别从不同的角度一步步的帮助你搭建一个功能更加强大，界面更加优雅的个人博客站点：</p>
<ul>
<li>想要了解和写作有关的语法技巧，请参考本系列中的 <a href="/2018/11/20/hexo-whirting-skills/" title="Hexo搭建个人博客系列：写作技巧篇">Hexo搭建个人博客系列：写作技巧篇</a>。</li>
<li>想要进一步美化主题，添加动效及交互，请参考本系列中的 <a href="/2018/11/20/hexo-theme-beautiful/" title="Hexo搭建个人博客系列：主题美化篇">Hexo搭建个人博客系列：主题美化篇</a>。</li>
<li>想要深度定制个性化站点，请参考本系列中的 <a href="/2018/11/20/hexo-advanced-settings/" title="Hexo搭建个人博客系列：进阶设置篇">Hexo搭建个人博客系列：进阶设置篇</a>。</li>
<li>想要了解如何将站点部署到公网，请参考本系列中的 <a href="/2018/11/20/hexo-deploy-to-VPS/" title="Hexo搭建个人博客系列：部署上线篇">Hexo搭建个人博客系列：部署上线篇</a></li>
</ul>
<div class="reference-linking">参考链接</div>

<ul>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></li>
<li><a href="https://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT使用文档</a> （部分章节与 v6.x 配置不兼容）</li>
<li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">reuixiy | 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>序</title>
    <url>/2018/09/20/ck33bhg84000sw4mkdlua4974/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="http://yearito-1256884783.image.myqcloud.com/thumbnails/elephant.jpg" alt="题图" title="Photo by Emma Kjellstrand"></p>
<blockquote class="blockquote-center">写作是一个好习惯，深以为然。这是一个回顾、梳理、总结的过程，更是一个重新思考的过程。</blockquote>

<p>第一次看到Next主题的Hexo博客，就被它极致的简洁所吸引，那时就曾想，以后一定要自己搭建一个博客，寻找一方净土，记录生活感悟和技术成长，今日终如愿。</p>
<a id="more"></a>

<blockquote>
<p>学而不思则惘，思而不学则殆。</p>
</blockquote>
<p>记录生活，可以把自己从喧闹的现实生活中释放出来，放空自己，使得内心重归平静，然后思考自己过去这一年，或者这几个月做了些什么有意义的事，完成了什么重要的任务，并进一步思考，未来的路应该怎么走，而不是被现实的压力驱赶着，一直低头赶路。在这个讯息爆炸的年代，每天都有太多的事情发生，和自己有关的，和自己没关的，都未经过滤从各种社交媒体渠道钻进大脑里占据一部分空间，我越来越难以回忆起来，去年的这个时候我在做些什么，在想些什么，对未来的人生有着怎么样的想法。所以我需要通过文字这种媒介，让过去不止是淹没在时间长河中再也打捞不起来的过去，而是一条清晰的锁链，我拽着锁链的这一头，就能与过去的自己对话，了解自己的人生观、价值观、性格、为人处世的原则是如何悄然发生变化的。</p>
<p>技术笔记则可以帮助自己理清解决问题的思路，归纳知识体系。在工作中遇到了技术难题，如果一味的搜索、尝试，直到柳暗花明突然解决问题，而没有停下手头的工作来思考并记录整个始末的话，则是错失了一大笔财富，或许一年后你再遇到同样问题的时候，依然要花费时间重新探索。我觉得，每过一段时间的技术积淀，都要停下脚步来重新思考，梳理一下零散的知识体系，或者记录一些关键问题的探索方案，延续已付出的时间和努力的价值。解决了问题并不代表就懂了会了，面试的时候别人问起同样的问题你不一定就可以当场总结表达出来，但如果你能自己写下来，或者讲给别人听，那么你才真正拥有这份知识。</p>
<p>某个话题的文章已经有很多人写过了，并且有的大佬已经写的很深刻到位了，为什么还要再写一遍?</p>
<p>我字写的比别人好看。</p>
<p>即使同样一个技术方案已经有一百个人在自己的博客里总结过，但还是很有可能你翻遍了网络都找不到一篇让你100%称心如意的，或是社区文章广告多，或是截图太粗糙，或是太过啰嗦，还有可能是别人一个中文逗号写成了英文逗号，而你这时只能看着发呆却无能无力，这就是强迫症了。你可以参考别人的技术方案，集众所长，亲自实践，然后融入自己的思考写出一篇新文章。这里有两点很重要，第一，亲自实践，第二，重新思考。即使并没有做出创新性的贡献，自己重新归纳一遍也有助于梳理流程，深化理解。</p>
<blockquote>
<p>工欲善其事必先利其器。</p>
</blockquote>
<p>一开始用印象笔记写作，后来因为不支持Markdown就迁移到了为知笔记。为知虽然原生支持Markdown，但是没有解决图片上传这个痛点，并且内置的编辑器有点简陋，没法实时预览，我一般用Sublime作为默认写作编辑器。付费使用为知笔记一年多后，我发现了有道云笔记，极致简洁的UI让我一见倾心，于是又把所有的笔记从为知转到了有道云，并且2018年7月16日有道云v6.5.0又推出了Markdown上传本地图片的功能（会员专享），完美解决了我的需求。简洁的UI，轻量级的应用，精准聚焦于用户核心需求，这很优雅，对，要优雅，我觉得好的互联网产品一定要优雅。与此相比，印象笔记和为知笔记则略显臃肿，功能繁琐，UI复杂，都不够优雅。除了有道云，网易的另一款产品网易邮箱大师也凭借极简的UI交互俘获了我，除了经常发不出邮件之外其他都挺好。</p>
<p>我是尤其钟爱这类极简而优雅的产品的，有道云、网易邮箱大师、石墨以及MIUI。</p>
<p>有道云用户体验这么好，为什么又要建站写博客。</p>
<ul>
<li>因为Hexo更优雅</li>
<li>程序员就是要瞎折腾</li>
<li>解锁新的技能，成就感+1</li>
<li>老婆面前炫耀的资本，成功驯服一头小萝莉</li>
</ul>
<p>一方面，我越来越觉得，要把感悟、经验、知识分享出来，给他人带来价值，或者经受批判而后成长。</p>
<p>另一方面，工作后人际关系更加复杂，喧嚣的社交网络已经不再适合谈及生活与思想，只有自己开辟一片净土，在此延续另一种形态的社交。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习总结</title>
    <url>/2018/07/09/Computer-network-learning-summary/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这部分内容主要是基于一些关于计算机网络基础的学习总结，内容不全面，只讲述了其中的一小部分，后续会再补充，如有错误，还请见谅。</p>
<a id="more"></a>

<p> 计算机网络常见概念</p>
<h2 id="网卡和路由器"><a href="#网卡和路由器" class="headerlink" title="网卡和路由器"></a>网卡和路由器</h2><p>网卡是一个有mac地址的物理设备，通过mac地址与局域网内的交换机通信，交换机可以识别mac地址。</p>
<p>而单纯的中继器，集线器，双绞线等设备只识别物理层设备。</p>
<p>路由器则工作在3层(ip层)，必须要有ip才能工作，所以路由器每一个接口都对应一个ip，维护一个可以识别ip的路由表，进行ip数据报转发。</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机具有自学习能力，学习的是交换表的内容。交换表中存储着 MAC 地址到接口的映射。</p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网是一种星型拓扑结构局域网。</p>
<p>早期使用集线器进行连接，它是一种物理层设备，作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离。之后再将这个比特传向其它所有接口。特别是，如果集线器同时收到来自两个不同接口的帧，那么就发生了碰撞。</p>
<p>目前以太网使用交换机替代了集线器，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p>
<h2 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h2><p>正常情况下，局域网中的链路层广播在整个局域网可达，而vlan可以在物理局域网中划分虚拟局域网，使广播帧只有在vlan当中的主机才能收到。</p>
<p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息，例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p>
<h2 id="DHCP协议-动态主机配置协议"><a href="#DHCP协议-动态主机配置协议" class="headerlink" title="DHCP协议(动态主机配置协议)"></a>DHCP协议(动态主机配置协议)</h2><p>首先DHCP是为了让主机获得一个ip地址，所以主机会发一个0.0.0.0为发送方，255.255.255.255为接收方的ip数据报，也就是广播数据报，并且广播数据包只在局域网中有效，然后链路层解析为数据帧，发送给局域网内的DHCP服务器。</p>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>arp负责把ip地址解析成局域网内的一个mac地址，只在局域网中有效。逆arp则把mac地址解析成ip地址。</p>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" alt></a></p>
<p>ARP 实现由 IP 地址得到 MAC 地址。</p>
<p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg" alt></a></p>
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。</p>
<blockquote>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
</blockquote>
<h2 id="网关和NAT"><a href="#网关和NAT" class="headerlink" title="网关和NAT"></a>网关和NAT</h2><p>当需要和外部局域网访问时，需要经过网关服务器以便兼容不同协议栈。局域网内部使用内网ip，经过网关时要转成外网ip，网关会帮你完成改写操作，当收到数据报时，网关又会帮你把ip改为内网ip。这种修改ip隐藏内部网络的方式叫做NAT。</p>
<p>nat穿透的方式是主机和网关服务器协定一个ip地址作为主机服务的ip，所以主机可以通过这个ip和外网交流。</p>
<h2 id="DNS协议和http请求过程"><a href="#DNS协议和http请求过程" class="headerlink" title="DNS协议和http请求过程"></a>DNS协议和http请求过程</h2><p>访问一个域名时，会发送dns报文请求（应用层）给本地的DNS服务器，解析出域名对应的ip，然后三次握手建立连接，（当然TCP数据报由本地局域网经过网关转给外网，再经过多次路由才到达目标主机），然后发送http请求获得响应报文</p>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" alt></a></p>
<p>ICMP 报文分为差错报告报文和询问报文。</p>
<p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/aa29cc88-7256-4399-8c7f-3cf4a6489559.png" alt></a></p>
<pre><code>1. Ping
Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。

Ping 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报。

2. Traceroute
Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径，事实上，traceroute也封装着无法交付的udp，和ping类似。。</code></pre><p>源主机向目的主机发送一连串的 IP 数据报，每个数据包的ttl时间不同，所以可以跟踪每一跳路由的信息。</p>
<p>==但是因为数据报封装的是无法交付的UDP报文，因此目的主机要向源主机发送 ICMP终点不可达差错报告报文。之后源主机知道了到达目的主机所经过的路由器 IP地址以及到达每个路由器的往返时间。==</p>
<h2 id="虚拟专用网VPN和内网ip"><a href="#虚拟专用网VPN和内网ip" class="headerlink" title="虚拟专用网VPN和内网ip"></a>虚拟专用网VPN和内网ip</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>有三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
<p>这些ip也称为内网ip，用于局域网间的通信，只能通过网关抵达公网。</p>
<p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/1556770b-8c01-4681-af10-46f1df69202c.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/1556770b-8c01-4681-af10-46f1df69202c.jpg" alt></a></p>
<p>使用隧道技术实现vpn。</p>
<pre><code>原理是；普通的内网ip无法被访问到，一般可以使用nat技术让网关作为中转人，而ip数据报也会改写成网关服务器的地址。

如果想让数据报保留内网地址，并且实现跨公网访问，那么只能通过隧道技术，把内网数据报加密包装在公网ip数据报中，然后通过公网ip抵达对方的专用网络，进行拆包和发送。

为什么vpn能翻墙呢，因为我们通过对vpn服务器的连接，可以将内网ip数据报装在里面，发送给vpn，vpn解析后再发送给真正的服务器。

由于本地网关阻拦了某些网站的请求，所以我们要把这个请求加密封装，然后通过隧道把数据发给一个海外服务器，让他真正完成请求。</code></pre><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层的协议主要是http，ftp这类协议，http访问超文本html，而ftp访问文件系统。</p>
<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>通过浏览器可以方便地进行dns解析，建立tcp连接，发送http请求，得到http响应，这些工作都是浏览器完成的。</p>
<h3 id="http1-0-1-1和2-0"><a href="#http1-0-1-1和2-0" class="headerlink" title="http1.0 1.1和2.0"></a>http1.0 1.1和2.0</h3><h4 id="1-0和1-1的主要变化"><a href="#1-0和1-1的主要变化" class="headerlink" title="1.0和1.1的主要变化"></a>1.0和1.1的主要变化</h4><pre><code>1 http1.0经过多年发展，在1.1提出了改进。
首先是提出了长连接，http请求可以在一次tcp连接中不断发送。

2 然后是http1.1支持只发送header而不发送body。原因是先用header判断能否成功，再发数据，节约带宽，事实上，post请求默认就是这样做的。

3 http1.1的host字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到host。</code></pre><h4 id="http1-0和http2-0的区别。"><a href="#http1-0和http2-0的区别。" class="headerlink" title="http1.0和http2.0的区别。"></a>http1.0和http2.0的区别。</h4><pre><code>http2.0变化巨大。

1 http支持多路复用，同一个连接可以并发处理多个请求，方法是把http数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个http请求顺序到达。

2 http2.0支持服务端推送，就是服务端在http请求到达后，除了返回数据之外，还推送了额外的内容给客户端。

3HTTP2.0压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少。

4http2.0只适用于https场景，因为其在http和tcp中间加了一层ssl层。</code></pre><h3 id="get和post"><a href="#get和post" class="headerlink" title="get和post"></a>get和post</h3><pre><code>get和post本质都是http请求，只不过对他们的作用做了界定和适配，并且让他们适应各自的场景。

1本质区别是get只是一次http请求，post先发请求体再发请求体，实际上是两次请求

2表面区别：

get可以cache而post不能，因为浏览器是这么安排的

一般设计get是幂等的而post不是

get的参数放在url传递，而post放在请求体里，因为get没有请求体。
所以get请求不安全，并且有长度限制（url不能太长），而post几乎没有限制，请求体可以很大。</code></pre><h3 id><a href="#" class="headerlink" title></a></h3><h4 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h4><p>并且浏览器还维护了cookie以便记录用于对网站的一些信息，下次请求时在http报文中带上这些数据，服务器接收以后根据cookie中的sessionid获取对应的session即可</p>
<h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><p>session一般维护在内存中，有时候也会持久化到数据库，但是如果session由单点维护可能出现宕机等情况，于是一般会采用分布式的方案。</p>
<pre><code>session存放的几种方案。
0 存在内存中。用sessionid标识用户。
这样的session十分依赖于cookie。如果浏览器禁用了cookie则session无用武之地。

当然也可以把内容存在数据库里，缺点是数据库访问压力较大。

1有做法会将session内容存在cookie中，但前提是经过了加密，然后下次服务器对其进行解密，但是这样浏览器需要维护太多内容了。

2当用户登录或者执行某些操作，则使用用户的一部分字段信息进行加密算法得到一串字符串成为token，用于唯一标识用户，或者是某些操作，比如登录，支付，服务端生成该token返回给用户，用户提交请求时必须带上这个token，就可以确认用户信息以及操作是否合法了。

这样我们不需要存session，只需要在想得到用户信息时解密token即可。

token还有一个好处就是可以在移动端和pc端兼容，因为移动端不支持cookie。

3token和oauth。经常有第三方授权登录的例子，本质就是使用token。首先我们打开授权登录页，登陆后服务端返回token，我们提交第三方的请求时，带上这个token，第三方不知道他是啥意思，并且token过段时间就过期了。</code></pre><h4 id="cas单点登录"><a href="#cas单点登录" class="headerlink" title="cas单点登录"></a>cas单点登录</h4><p>单点登录是为了多个平台之间公用一个授权系统，做法是，所有登录都要指向统一登录服务，登陆成功以后在认证中心建立session，并且得到ticket，然后重定向页面，此时页面也会向认证中心确认ticket是否合法，然后就可以访问其他系统的页面了。</p>
<p>从而访问其他系统时，由于已经有了认证中心的cookie，所以直接带上ticket访问即可。</p>
<p>每次访问新系统时需要在认证中心注册session，然后单点退出时再把这些session退出，才能实现用户登出。</p>
<h2 id="web安全和https"><a href="#web安全和https" class="headerlink" title="web安全和https"></a>web安全和https</h2><h3 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h3><p>MD5等加密方法可以用来对密码进行加密。一般还会加盐</p>
<h3 id="xss跨站脚本攻击"><a href="#xss跨站脚本攻击" class="headerlink" title="xss跨站脚本攻击"></a>xss跨站脚本攻击</h3><p>利用有输入功能网站的输入框来注入JavaScript脚本代码，用户访问该页面时会自动执行某些脚本代码，导致cookie等个人信息泄露，可能会被转发到其他网站。</p>
<p>解决办法是对输入进行检验，利用一个些工具类就可以做到。</p>
<h3 id="跨站点请求伪造csrf"><a href="#跨站点请求伪造csrf" class="headerlink" title="跨站点请求伪造csrf"></a>跨站点请求伪造csrf</h3><p>首先用户访问了一个网站并登陆，会把cookie保留在浏览器，<br>然后某些网站用一些隐性链接诱导用户点击，点击时发送请求会携带浏览器中的cookie，比如支付宝的账号密码，通过该cookie再去伪造一个支付宝支付请求，达到伪造请求的目的。 </p>
<p>解决这个问题的办法就是禁止js请求跨域名。但是他为ajax提供了特殊定制。</p>
<h3 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h3><ol>
<li><p>概念<br>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p>
</li>
<li><p>防范手段<br>（一）使用参数化查询</p>
</li>
</ol>
<p>以下以 Java 中的 PreparedStatement 为例，它是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p>
<p>（二）单引号转换</p>
<p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p>
<h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
<p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p>
<p>DDoS攻击通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。 </p>
<p>这种攻击方式可分为以下几种：</p>
<pre><code>通过使网络过载来干扰甚至阻断正常的网络通讯；
通过向服务器提交大量请求，使服务器超负荷；
阻断某一用户访问服务器；
阻断某服务与特定系统或个人的通讯。</code></pre><p>攻击现象</p>
<pre><code>被攻击主机上有大量等待的TCP连接；
网络中充斥着大量的无用的数据包；
源地址为假 制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯；
利用受害主机提供的传输协议上的缺陷反复高速的发出特定的服务请求，使主机无法处理所有正常请求；
严重时会造成系统死机。</code></pre><p>总体来说，对DoS和DDoS的防范主要从下面几个方面考虑：</p>
<pre><code>尽可能对系统加载最新补丁，并采取有效的合规性配置，降低漏洞利用风险；

采取合适的安全域划分，配置防火墙、入侵检测和防范系统，减缓攻击。

采用分布式组网、负载均衡、提升系统容量等可靠性措施，增强总体服务能力。</code></pre><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>https博大精深，首先先来看看他的基础知识</p>
<pre><code>1对称加密和非对称加密

对称加密两方使用同一把密钥加密和解密，传输密钥时如果丢失就会被破解。

2非对称加密两方各有一把私钥，而公钥公开，A用私钥加密，把公钥和数据传给B，B用公钥解密。同理，B用私钥对数据进行加密，返回给A，A也用公钥进行解密。

3非对称加密只要私钥不丢就很安全，但是效率比较低，所以一般使用非对称加密传输对称加密的密钥，使用对称加密完成数据传输。

4数字签名，为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行md5加密，如果和签名一样，则说明数据确实是真的。

5数字证书，对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。

所以为了保证发送方的公钥是真的，CA证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。</code></pre><p>​<br>​<br>    6 https过程</p>
<pre><code>用户发送请求，服务器返回一个数字证书。

用户在浏览器端生成一个随机数，使用证书中的公钥加密，发送给服务端。

服务端使用公钥解密该密文，得到随机数。

往后两者使用该随机数作为公钥进行对称加密。


番外：关于公钥加密私钥解密与私钥加密公钥解密说明
第一种是签名,使用私钥加密,公钥解密,用于让所有公钥所有者验证私钥所有者的身份并且用来防止私钥所有者发布的内容被篡改.但是不用来保证内容不被他人获得. 

第二种是加密,用公钥加密,私钥解密,用于向公钥所有者发布信息,这个信息可能被他人篡改,但是无法被他人获得.搜索 </code></pre><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><pre><code>UDP 和 TCP 的特点
用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</code></pre><p>TCP是传输层最重要的协议。</p>
<blockquote>
<p>由于网络层只提供最大交付的服务，尽可能地完成路由转发，以及把链路层报文传送给任意一台主机。他做的工作很专注，所以不会提供其他的可靠性保证。</p>
<p>但是真实网络环境下随时会发生丢包，乱序，数据内容出错等情况，这些情况必须得到处理，于是我们使用传输层tcp来解决这些问题。</p>
</blockquote>
<h3 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h3><p>伪首部的意义：伪首部并非TCP&amp;UDP数据报中实际的有效成分。伪首部是一个虚拟的数据结构，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算校验和。</p>
<p><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" alt="image"></p>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>
<h3 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h3><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt></a></p>
<ul>
<li><p><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li><p><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
</li>
<li><p><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
</li>
<li><p><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</li>
<li><p><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</li>
<li><p><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
</li>
<li><p><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
</li>
<li></li>
</ul>
<h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><pre><code>为了保证tcp的可靠传输，需要建立起一条通路，也就是所谓连接。这条通路必须保证有效并且能正确结束。</code></pre><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/e92d0ebc-7d46-413b-aec1-34a39602f787.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt></a></p>
<p>​<br>    三次握手</p>
<pre><code>1 首先客户端发送连接请求syn，携带随机数x。
2 服务端返回请求ack，x + 1,说明服务端对x进行了回复。
3 客户端返回请求ack，y，说明接受到了信息并且开始传输数据，起始数据为y。

客户端状态时syn_send和establish
服务端则是从listen到syn_rcvd，再到establish</code></pre><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt></a></p>
<pre><code>四次挥手

1 首先客户端请求断开连接，发送fin请求，服务端返回fin的ack，继续处理断开前需要处理完的数据。

2 过了一会，服务端处理完数据发送给客户端ack，表明已经关闭，客户端最后再发一个ack给服务端，如果服务端已关闭则无反应，客户端经过两个ttl后挥手完毕，确认服务端断开。这两个ttl成为time wait状态，用于确定服务端真的关闭。

3 客户端发完fin后的状态从establish变为fin1——wait，服务端发完ack后的状态从establish变为closewait。

4 客户端收到第一个ack后进入fin_2wait状态，服务端过了一会发送last——ack给客户端，说明关闭好了，客户端收到ack后进入timewait，然后发送ack。双方都closed。</code></pre><h3 id="半连接syn和洪泛法攻击"><a href="#半连接syn和洪泛法攻击" class="headerlink" title="半连接syn和洪泛法攻击"></a>半连接syn和洪泛法攻击</h3><p>黑客开启大量的syn请求而不发送ack，服务端开启半连接等待ack，直到资源耗尽，所以必须检测来访ip</p>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>三次握手的原因</p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>也就是说，如果只有两次握手，服务端返回ack后直接通信，那么如果客户端因为网络问题没有收到ack，可能会再次请求连接，但时服务端不知道这其实是同一个请求，于是又打开了一个连接，相当于维护了很多的无用连接。</p>
<h3 id="time-wait的作用"><a href="#time-wait的作用" class="headerlink" title="time wait的作用"></a>time wait的作用</h3><p>1 需要服务端可靠地终止连接，如果处于time_wait客户端发给服务端的ack报文丢失，则服务端会再发一次fin，此时客户端不应该关闭。</p>
<p>2 保证迟来的tcp报文有时间被丢弃，因为2msl里超时抵达的报文都会被丢弃。</p>
<h2 id="可靠传输协议"><a href="#可靠传输协议" class="headerlink" title="可靠传输协议"></a>可靠传输协议</h2><p>TCP协议有三个重要属性。</p>
<pre><code>可靠传输，主要通过有序接收，确认后发送，以及超时重传来实现，并且使用分片来提高发送效率，通过检验和避免错误。

流量控制，主要通过窗口限制接收和发送速率。

拥塞控制，主要通过不同拥塞状态的算法来处理拥塞，一开始发的比较慢，然后指数增加，当丢包时再降低速度，重新开始第一阶段，避免拥塞。</code></pre><p>总结以下就是几个特点：</p>
<p>TCP 可靠传输</p>
<pre><code>TCP 使用超时重传来实现可靠传输：

1 如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</code></pre><p>​<br>    2 滑动窗口可以连续发送多个数据再统一进行确认。</p>
<pre><code>   因为发送端希望在收到确认前，继续发送其它报文段。比如说在收到0号报文的确认前还发出了1-3号的报文，这样提高了信道的利用率。

3 滑动窗口只重传丢失的数据报

但可以想想，0-4发出去后可能要重传，所以需要一个缓冲区维护这些报文，所以就有了窗口。

4每当完成一个确认窗口往前滑动一格，可以传新的一个数据，因此可以顺序发送顺序确认</code></pre><p>TCP 流量控制</p>
<pre><code>流量控制是为了控制发送方发送速率，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</code></pre><p>TCP 拥塞控制</p>
<pre><code>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。

TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

一般刚开始时慢开始，然后拥塞避免，出现个别丢包时（连续三个包序号不对），

则执行快重传，然后进入快恢复阶段，接着继续拥塞避免。如果发生多次超时也就是拥塞时，直接进入慢开始。</code></pre><blockquote>
<p>这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
</blockquote>
<p> ==发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口==。</p>
<p>滑动窗口协议综合实现了上述这一些内容：</p>
<p>为什么要使用滑动窗口，因为滑动窗口可以实现可靠传输，流量控制和拥塞控制（拥塞控制用的是拥塞窗口变量）</p>
<h3 id="tcp的粘包拆包"><a href="#tcp的粘包拆包" class="headerlink" title="tcp的粘包拆包"></a>tcp的粘包拆包</h3><p>tcp报文是流式的数据，没有标识数据结束，只有序号等字段，tcp协议自动完成数据报的切分。由于tcp使用缓冲区发送，又没有标识结束，当缓冲区的数据没清空又有新数据进来，就会发生粘包，如果数据太大存装不下，就会被拆包。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h2 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h2><p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt></a></p>
<ul>
<li><p><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</p>
</li>
<li><p><strong>首部长度</strong> : 占 4 位，因此最大值为 15。</p>
</li>
<li><p><strong>总长度</strong> : 包括首部长度和数据部分长度。</p>
</li>
<li><p><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p>
</li>
</ul>
<p>==*   <strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。==</p>
<ul>
<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
</ul>
<ul>
<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/23ba890e-e11c-45e2-a20c-64d217f83430.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/23ba890e-e11c-45e2-a20c-64d217f83430.png" alt></a></p>
<p>总结：</p>
<pre><code>ip层只保证尽最大努力交付，他所承载的一切都是对路由，转发，已经网络传输最友好的设计。

路由器负责记录路由表和转发ip数据报，路由表记录着ip地址和下一跳路由的端口的对应关系。

由于路由聚合的缘故，一般用170.177.233.0/24就可以标识好几个网络了。

以前会使用A，B，C类地址，和子网，现在直接使用地址聚合，前24位是网络号，后面8位是主机号。

## 某个聚合路由地址划分网络给n台机器，是否符合要求。。

要看这个网络中的主机号能否达到n个。</code></pre><h3 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h3><p>IP 地址的编址方式经历了三个历史阶段：</p>
<ul>
<li>分类</li>
<li>子网划分</li>
<li>无分类</li>
</ul>
<h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#1-%E5%88%86%E7%B1%BB" target="_blank" rel="noopener"></a>1. 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<p><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/pics/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" target="_blank" rel="noopener"><img src="https://github.com/CyC2018/Interview-Notebook/raw/master/pics/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" alt></a>  </p>
<ol start="2">
<li>子网划分</li>
</ol>
<pre><code>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。注意，外部网络看不到子网的存在。

IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}

要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</code></pre><ol start="3">
<li>无分类</li>
</ol>
<pre><code>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。

IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}

CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。

CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</code></pre><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。</p>
<p>把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>
<p>总结</p>
<pre><code>使用分类法的ip必须标识是哪一类地址，比较麻烦，而且一旦设置为某类地址它就只能使用那一部分地址空间了。

使用子网掩码可以避免使用分类并且更灵活地决定网络号和主机号的划分。但是需要配置子网掩码，比较复杂。

CIDR 138.1.2.11/24
使用CIDR避免了子网划分，直接使用后n位作为网络号，简化了子网的配置（实际上用n代替了子网掩码）。并且在路由器中可以使用地址聚合，一个ip可以聚合多个网络号。</code></pre><h3 id="ip分片详谈"><a href="#ip分片详谈" class="headerlink" title="ip分片详谈"></a>ip分片详谈</h3><p>在TCP/IP分层中，数据链路层用MTU（Maximum Transmission Unit，最大传输单元）来限制所能传输的数据包大小，MTU是指一次传送的数据最大长度，不包括数据链路层数据帧的帧头，如以太网的MTU为1500字节，实际上数据帧的最大长度为1512字节，其中以太网数据帧的帧头为12字节。</p>
<p>当发送的IP数据报的大小超过了MTU时，IP层就需要对数据进行分片，否则数据将无法发送成功。</p>
<p>IP分片的实现</p>
<blockquote>
<p>IP分片发生在IP层，不仅源端主机会进行分片，中间的路由器也有可能分片，因为不同的网络的MTU是不一样的，如果传输路径上的某个网络的MTU比源端网络的MTU要小，路由器就可能对IP数据报再次进行分片。而分片数据的重组只会发生在目的端的IP层。</p>
</blockquote>
<p>==避免IP分片==</p>
<blockquote>
<p>在网络编程中，我们要避免出现IP分片，那么为什么要避免呢？原因是IP层是没有超时重传机制的，如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大。由此可见，IP分片会大大降低传输层传送数据的成功率，所以我们要避免IP分片。</p>
</blockquote>
<pre><code>对于UDP包，我们需要在应用层去限制每个包的大小，一般不要超过1472字节，即以太网MTU（1500）—UDP首部（8）—IP首部（20）。

对于TCP数据，应用层就不需要考虑这个问题了，因为传输层已经帮我们做了。</code></pre><p>在建立连接的三次握手的过程中，连接双方会相互通告MSS（Maximum Segment =Size，最大报文段长度），MSS一般是MTU—IP首部（20）—TCP首部（20），每次发送的TCP数据都不会超过双方MSS的最小值，所以就保证了IP数据报不会超过MTU，避免了IP分片。</p>
<ol start="3">
<li>外部网关协议 BGP</li>
</ol>
<pre><code>BGP（Border Gateway Protocol，边界网关协议）

AS 之间的路由选择很困难，主要是因为互联网规模很大。并且各个 AS 内部使用不同的路由选择协议，就无法准确定义路径的度量。并且 AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。

BGP 只能寻找一条比较好的路由，而不是最佳路由。

每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</code></pre><h3 id="路由选择协议和算法"><a href="#路由选择协议和算法" class="headerlink" title="路由选择协议和算法"></a>路由选择协议和算法</h3><blockquote>
<p>路由选择协议<br>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>可以把路由选择协议划分为两大类：</p>
<p>自治系统内部的路由选择：RIP 和 OSPF<br>自治系统间的路由选择：BGP</p>
</blockquote>
<p>总结：</p>
<pre><code>1. 内部网关协议 RIP
RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1，跳数最多为 15，超过 15 表示不可达。

RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。

2. 内部网关协议 OSPF
开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。

开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</code></pre><p>OSPF 具有以下特点：</p>
<pre><code>计算出最短路径，然后向本自治系统中的所有路由器发送信息，这种方法是洪泛法。

发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。

变化时，路由器才会发送信息。

所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</code></pre><p>总结：</p>
<pre><code>AS是一个自治域，一般是指相似度很大公用一个协议的路由器族，比如同一个运营商的网络。

因特网中AS之间的路由选择协议是BGP。

AS内的路由选择协议有RIP和OSPF。

RIP两两交换，最后大家都同步。

OSPF找到最短路径。告诉大家。</code></pre><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>链路层最主要是指局域网内的网络交互了，使用mac地址通过交换机进行通信，其中用得最多的局域网协议就是以太网。</p>
<p>链路层使用MTU表示最大传输帧长度，报文长度不能超过MTU,否则会进行分片，比如比较大的IP数据报就会被分片，为了避免被分片。一般要控制IP报文长度。</p>
<p>广播：</p>
<p>要理解什么是广播风暴，就必须先理解网络通信技术。 网络上的一个节点，它发送一个数据帧或包，被传输到由广播域定义的本地网段上的每个节点就是广播。</p>
<blockquote>
<p>网络广播分为第2层广播和第3层广播。第2层广播也称硬件广播，用于在局域网内向所有的结点发送数据，通常不会穿过局域网的边界（路由器），除非它变成一个单播。广播将是一个二进制的全1或者十六进制全F的地址。而第3层广播用于在这个网络内向所有的结点发送数据。</p>
</blockquote>
<p>帧的传输方式，即单播帧（Unicast Frame）、多播帧（Multicast Frame）和广播帧（Broadcast Frame）。</p>
<pre><code>1、单播帧
单播帧也称“点对点”通信。此时帧的接收和传递只在两个节点之间进行，帧的目的MAC地址就是对方的MAC地址，网络设备（指交换机和路由器）根据帧中的目的MAC地址，将帧转发出去。

2、多播帧
多播帧可以理解为一个人向多个人（但不是在场的所有人）说话，这样能够提高通话的效率。多播占网络中的比重并不多，主要应用于网络设备内部通信、网上视频会议、网上视频点播等。

3、广播帧
广播帧可以理解为一个人对在场的所有人说话，这样做的好处是通话效率高，信息一下子就可以传递到全体。在广播帧中，帧头中的目的MAC地址是“FF.FF.FF.FF.FF.FF”，代表网络上所有主机网卡的MAC地址。

广播帧在网络中是必不可少的，如客户机通过DHCP自动获得IP地址的过程就是通过广播帧来实现的。而且，由于设备之间也需要相互通信，因此在网络中即使没有用户人为地发送广播帧，网络上也会出现一定数量的广播帧。

同单播和多播相比，广播几乎占用了子网内网络的所有带宽。网络中不能长时间出现大量的广播帧，否则就会出现所谓的“广播风暴”（每秒的广播帧数在1000以上）。拿开会打一个比方，在会场上只能有一个人发言，如果所有人都同时发言的话，会场上就会乱成一锅粥。广播风暴就是网络长时间被大量的广播数据包所占用，使正常的点对点通信无法正常进行，其外在表现为网络速度奇慢无比。出现广播风暴的原因有很多，一块故障网卡就可能长时间地在网络上发送广播包而导致广播风暴。

使用路由器或三层交换机能够实现在不同子网间隔离广播风暴的作用。当路由器或三层交换机收到广播帧时并不处理它，使它无法再传递到其他子网中，从而达到隔离广播风暴的目的。因此在由几百台甚至上千台电脑构成的大中型局域网中，为了隔离广播风暴，都要进行子网划分。
使用vlan完全可以隔离广播风暴。</code></pre><blockquote>
<p>在交换以太网上运行TCP/IP环境下：<br>二层广播是在数据链路层的广播，它 的广播范围是二层交换机连接的所有端口；二层广播不能通过路由器。</p>
<p>三层广播就是在网络层的广播，它的范围是同一IP子网内的设备，子网广播也不能通过路由器。</p>
<p>第三层的数据必须通过第二层的封装再发送，所以三层广播必然通过二层广播来实现。</p>
<p>设想在同一台二层交换机上连接2个ip子网的设备，所有的设备都可以接收到二层广播，但三层广播只对本子网设备有效，非本子网的设备也会接收到广播包，但会被丢弃。</p>
</blockquote>
<p>广播风暴（broadcast storm）</p>
<p>简单的讲是指当广播数据充斥网络无法处理，并占用大量网络带宽，导致正常业务不能运行，甚至彻底瘫痪，这就发生了“广播风暴”</p>
<p>。一个数据帧或包被传输到本地网段 （由广播域定义）上的每个节点就是广播；由于网络拓扑的设计和连接问题，或其他原因导致广播在网段内大量复制，传播数据帧，导致网络性能下降，甚至网络瘫痪，这就是广播风暴。</p>
<p>要避免广播风暴，可以采用恰当划分VLAN、缩小广播域、隔离广播风暴，还可在千兆以太网口上启用广播风暴控制，最大限度地避免网络再次陷入瘫痪。</p>
<h2 id="微信公众号"><a href="#微信公众号" class="headerlink" title="微信公众号"></a>微信公众号</h2>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>知识体系</title>
    <url>/2017/05/27/Study-Map-One/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="✏️-算法"><a href="#✏️-算法" class="headerlink" title="✏️ 算法"></a>✏️ 算法</h2><ul>
<li><a href="notes/剑指%20Offer%20题解%20-%20目录1.md">剑指 Offer 题解</a> <br></li>
<li><a href="notes/Leetcode%20题解%20-%20目录1.md">Leetcode 题解</a> <br></li>
<li><a href="notes/算法%20-%20目录1.md">算法</a> <br></li>
<li><a href="https://xiaozhuanlan.com/CyC2018" target="_blank" rel="noopener">后端面试进阶指南</a></li>
</ul>
<h2 id="💻-操作系统"><a href="#💻-操作系统" class="headerlink" title="💻 操作系统"></a>💻 操作系统</h2><ul>
<li><a href="notes/计算机操作系统%20-%20目录1.md">计算机操作系统</a> <br></li>
<li><a href="notes/Linux.md">Linux</a></li>
</ul>
<h2 id="☁️-网络"><a href="#☁️-网络" class="headerlink" title="☁️ 网络"></a>☁️ 网络</h2><ul>
<li><a href="notes/计算机网络%20-%20目录1.md">计算机网络</a> <br></li>
<li><a href="notes/HTTP.md">HTTP</a> <br></li>
<li><a href="notes/Socket.md">Socket</a></li>
</ul>
<h2 id="🎨-面向对象"><a href="#🎨-面向对象" class="headerlink" title="🎨 面向对象"></a>🎨 面向对象</h2><ul>
<li><a href="notes/设计模式%20-%20目录1.md">设计模式</a> <br></li>
<li><a href="notes/面向对象思想.md">面向对象思想</a></li>
</ul>
<h2 id="💾-数据库"><a href="#💾-数据库" class="headerlink" title="💾 数据库"></a>💾 数据库</h2><ul>
<li><a href="notes/数据库系统原理.md">数据库系统原理</a> <br></li>
<li><a href="notes/SQL.md">SQL</a> <br></li>
<li><a href="notes/Leetcode-Database%20题解.md">Leetcode-Database 题解</a> <br></li>
<li><a href="notes/MySQL.md">MySQL</a> <br></li>
<li><a href="notes/Redis.md">Redis</a></li>
</ul>
<h2 id="☕️-Java"><a href="#☕️-Java" class="headerlink" title="☕️ Java"></a>☕️ Java</h2><ul>
<li><a href="notes/Java%20基础.md">Java 基础</a> <br></li>
<li><a href="notes/Java%20容器.md">Java 容器</a> <br></li>
<li><a href="notes/Java%20并发.md">Java 并发</a> <br></li>
<li><a href="notes/Java%20虚拟机.md">Java 虚拟机</a> <br></li>
<li><a href="notes/Java%20IO.md">Java I/O</a></li>
</ul>
<h2 id="💡-系统设计"><a href="#💡-系统设计" class="headerlink" title="💡 系统设计"></a>💡 系统设计</h2><ul>
<li><a href="notes/系统设计基础.md">系统设计基础</a> <br></li>
<li><a href="notes/分布式.md">分布式</a> <br></li>
<li><a href="notes/集群.md">集群</a> <br></li>
<li><a href="notes/攻击技术.md">攻击技术</a> <br></li>
<li><a href="notes/缓存.md">缓存</a> <br></li>
<li><a href="notes/消息队列.md">消息队列</a></li>
</ul>
<h2 id="🔧-工具"><a href="#🔧-工具" class="headerlink" title="🔧 工具"></a>🔧 工具</h2><ul>
<li><a href="notes/Git.md">Git</a> <br></li>
<li><a href="notes/Docker.md">Docker</a> <br></li>
<li><a href="notes/正则表达式.md">正则表达式</a> <br></li>
<li><a href="notes/构建工具.md">构建工具</a></li>
</ul>
<!--⭐️欢迎关注我的公众号 CyC2018，在公众号后台回复关键字 📚 **资料** 可领取复习大纲，这份大纲是我花了一整年时间整理的面试知识点列表，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点。可以说我基本是按照这份大纲来进行复习的，这份大纲对我拿到了 BAT 头条等 Offer 起到很大的帮助。你们完全可以和我一样根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些复习时间。
<br/><br/>
<div align="center">
  <img src="https://cyc-1256109796.cos.ap-guangzhou.myqcloud.com/%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" width="200px">
</div> -->


]]></content>
      <categories>
        <category>知识体系Map</category>
      </categories>
      <tags>
        <tag>知识体系Map</tag>
      </tags>
  </entry>
</search>
